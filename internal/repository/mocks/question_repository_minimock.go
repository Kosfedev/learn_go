// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Kosfedev/learn_go/internal/repository.QuestionRepository -o question_repository_minimock.go -n QuestionRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Kosfedev/learn_go/internal/model"
	"github.com/gojuno/minimock/v3"
)

// QuestionRepositoryMock implements mm_repository.QuestionRepository
type QuestionRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddOptions          func(ctx context.Context, questionID int64, options []*model.NewQuestionOption) (err error)
	funcAddOptionsOrigin    string
	inspectFuncAddOptions   func(ctx context.Context, questionID int64, options []*model.NewQuestionOption)
	afterAddOptionsCounter  uint64
	beforeAddOptionsCounter uint64
	AddOptionsMock          mQuestionRepositoryMockAddOptions

	funcCreate          func(ctx context.Context, question *model.NewQuestion) (i1 int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, question *model.NewQuestion)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mQuestionRepositoryMockCreate

	funcDelete          func(ctx context.Context, id int64) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mQuestionRepositoryMockDelete

	funcDeleteOptions          func(ctx context.Context, ids []int64) (err error)
	funcDeleteOptionsOrigin    string
	inspectFuncDeleteOptions   func(ctx context.Context, ids []int64)
	afterDeleteOptionsCounter  uint64
	beforeDeleteOptionsCounter uint64
	DeleteOptionsMock          mQuestionRepositoryMockDeleteOptions

	funcGet          func(ctx context.Context, id int64) (qp1 *model.Question, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id int64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mQuestionRepositoryMockGet

	funcUpdate          func(ctx context.Context, id int64, updatedQuestion *model.UpdatedQuestion) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, id int64, updatedQuestion *model.UpdatedQuestion)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mQuestionRepositoryMockUpdate
}

// NewQuestionRepositoryMock returns a mock for mm_repository.QuestionRepository
func NewQuestionRepositoryMock(t minimock.Tester) *QuestionRepositoryMock {
	m := &QuestionRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddOptionsMock = mQuestionRepositoryMockAddOptions{mock: m}
	m.AddOptionsMock.callArgs = []*QuestionRepositoryMockAddOptionsParams{}

	m.CreateMock = mQuestionRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*QuestionRepositoryMockCreateParams{}

	m.DeleteMock = mQuestionRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*QuestionRepositoryMockDeleteParams{}

	m.DeleteOptionsMock = mQuestionRepositoryMockDeleteOptions{mock: m}
	m.DeleteOptionsMock.callArgs = []*QuestionRepositoryMockDeleteOptionsParams{}

	m.GetMock = mQuestionRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*QuestionRepositoryMockGetParams{}

	m.UpdateMock = mQuestionRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*QuestionRepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mQuestionRepositoryMockAddOptions struct {
	optional           bool
	mock               *QuestionRepositoryMock
	defaultExpectation *QuestionRepositoryMockAddOptionsExpectation
	expectations       []*QuestionRepositoryMockAddOptionsExpectation

	callArgs []*QuestionRepositoryMockAddOptionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionRepositoryMockAddOptionsExpectation specifies expectation struct of the QuestionRepository.AddOptions
type QuestionRepositoryMockAddOptionsExpectation struct {
	mock               *QuestionRepositoryMock
	params             *QuestionRepositoryMockAddOptionsParams
	paramPtrs          *QuestionRepositoryMockAddOptionsParamPtrs
	expectationOrigins QuestionRepositoryMockAddOptionsExpectationOrigins
	results            *QuestionRepositoryMockAddOptionsResults
	returnOrigin       string
	Counter            uint64
}

// QuestionRepositoryMockAddOptionsParams contains parameters of the QuestionRepository.AddOptions
type QuestionRepositoryMockAddOptionsParams struct {
	ctx        context.Context
	questionID int64
	options    []*model.NewQuestionOption
}

// QuestionRepositoryMockAddOptionsParamPtrs contains pointers to parameters of the QuestionRepository.AddOptions
type QuestionRepositoryMockAddOptionsParamPtrs struct {
	ctx        *context.Context
	questionID *int64
	options    *[]*model.NewQuestionOption
}

// QuestionRepositoryMockAddOptionsResults contains results of the QuestionRepository.AddOptions
type QuestionRepositoryMockAddOptionsResults struct {
	err error
}

// QuestionRepositoryMockAddOptionsOrigins contains origins of expectations of the QuestionRepository.AddOptions
type QuestionRepositoryMockAddOptionsExpectationOrigins struct {
	origin           string
	originCtx        string
	originQuestionID string
	originOptions    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOptions *mQuestionRepositoryMockAddOptions) Optional() *mQuestionRepositoryMockAddOptions {
	mmAddOptions.optional = true
	return mmAddOptions
}

// Expect sets up expected params for QuestionRepository.AddOptions
func (mmAddOptions *mQuestionRepositoryMockAddOptions) Expect(ctx context.Context, questionID int64, options []*model.NewQuestionOption) *mQuestionRepositoryMockAddOptions {
	if mmAddOptions.mock.funcAddOptions != nil {
		mmAddOptions.mock.t.Fatalf("QuestionRepositoryMock.AddOptions mock is already set by Set")
	}

	if mmAddOptions.defaultExpectation == nil {
		mmAddOptions.defaultExpectation = &QuestionRepositoryMockAddOptionsExpectation{}
	}

	if mmAddOptions.defaultExpectation.paramPtrs != nil {
		mmAddOptions.mock.t.Fatalf("QuestionRepositoryMock.AddOptions mock is already set by ExpectParams functions")
	}

	mmAddOptions.defaultExpectation.params = &QuestionRepositoryMockAddOptionsParams{ctx, questionID, options}
	mmAddOptions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddOptions.expectations {
		if minimock.Equal(e.params, mmAddOptions.defaultExpectation.params) {
			mmAddOptions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOptions.defaultExpectation.params)
		}
	}

	return mmAddOptions
}

// ExpectCtxParam1 sets up expected param ctx for QuestionRepository.AddOptions
func (mmAddOptions *mQuestionRepositoryMockAddOptions) ExpectCtxParam1(ctx context.Context) *mQuestionRepositoryMockAddOptions {
	if mmAddOptions.mock.funcAddOptions != nil {
		mmAddOptions.mock.t.Fatalf("QuestionRepositoryMock.AddOptions mock is already set by Set")
	}

	if mmAddOptions.defaultExpectation == nil {
		mmAddOptions.defaultExpectation = &QuestionRepositoryMockAddOptionsExpectation{}
	}

	if mmAddOptions.defaultExpectation.params != nil {
		mmAddOptions.mock.t.Fatalf("QuestionRepositoryMock.AddOptions mock is already set by Expect")
	}

	if mmAddOptions.defaultExpectation.paramPtrs == nil {
		mmAddOptions.defaultExpectation.paramPtrs = &QuestionRepositoryMockAddOptionsParamPtrs{}
	}
	mmAddOptions.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddOptions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddOptions
}

// ExpectQuestionIDParam2 sets up expected param questionID for QuestionRepository.AddOptions
func (mmAddOptions *mQuestionRepositoryMockAddOptions) ExpectQuestionIDParam2(questionID int64) *mQuestionRepositoryMockAddOptions {
	if mmAddOptions.mock.funcAddOptions != nil {
		mmAddOptions.mock.t.Fatalf("QuestionRepositoryMock.AddOptions mock is already set by Set")
	}

	if mmAddOptions.defaultExpectation == nil {
		mmAddOptions.defaultExpectation = &QuestionRepositoryMockAddOptionsExpectation{}
	}

	if mmAddOptions.defaultExpectation.params != nil {
		mmAddOptions.mock.t.Fatalf("QuestionRepositoryMock.AddOptions mock is already set by Expect")
	}

	if mmAddOptions.defaultExpectation.paramPtrs == nil {
		mmAddOptions.defaultExpectation.paramPtrs = &QuestionRepositoryMockAddOptionsParamPtrs{}
	}
	mmAddOptions.defaultExpectation.paramPtrs.questionID = &questionID
	mmAddOptions.defaultExpectation.expectationOrigins.originQuestionID = minimock.CallerInfo(1)

	return mmAddOptions
}

// ExpectOptionsParam3 sets up expected param options for QuestionRepository.AddOptions
func (mmAddOptions *mQuestionRepositoryMockAddOptions) ExpectOptionsParam3(options []*model.NewQuestionOption) *mQuestionRepositoryMockAddOptions {
	if mmAddOptions.mock.funcAddOptions != nil {
		mmAddOptions.mock.t.Fatalf("QuestionRepositoryMock.AddOptions mock is already set by Set")
	}

	if mmAddOptions.defaultExpectation == nil {
		mmAddOptions.defaultExpectation = &QuestionRepositoryMockAddOptionsExpectation{}
	}

	if mmAddOptions.defaultExpectation.params != nil {
		mmAddOptions.mock.t.Fatalf("QuestionRepositoryMock.AddOptions mock is already set by Expect")
	}

	if mmAddOptions.defaultExpectation.paramPtrs == nil {
		mmAddOptions.defaultExpectation.paramPtrs = &QuestionRepositoryMockAddOptionsParamPtrs{}
	}
	mmAddOptions.defaultExpectation.paramPtrs.options = &options
	mmAddOptions.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmAddOptions
}

// Inspect accepts an inspector function that has same arguments as the QuestionRepository.AddOptions
func (mmAddOptions *mQuestionRepositoryMockAddOptions) Inspect(f func(ctx context.Context, questionID int64, options []*model.NewQuestionOption)) *mQuestionRepositoryMockAddOptions {
	if mmAddOptions.mock.inspectFuncAddOptions != nil {
		mmAddOptions.mock.t.Fatalf("Inspect function is already set for QuestionRepositoryMock.AddOptions")
	}

	mmAddOptions.mock.inspectFuncAddOptions = f

	return mmAddOptions
}

// Return sets up results that will be returned by QuestionRepository.AddOptions
func (mmAddOptions *mQuestionRepositoryMockAddOptions) Return(err error) *QuestionRepositoryMock {
	if mmAddOptions.mock.funcAddOptions != nil {
		mmAddOptions.mock.t.Fatalf("QuestionRepositoryMock.AddOptions mock is already set by Set")
	}

	if mmAddOptions.defaultExpectation == nil {
		mmAddOptions.defaultExpectation = &QuestionRepositoryMockAddOptionsExpectation{mock: mmAddOptions.mock}
	}
	mmAddOptions.defaultExpectation.results = &QuestionRepositoryMockAddOptionsResults{err}
	mmAddOptions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddOptions.mock
}

// Set uses given function f to mock the QuestionRepository.AddOptions method
func (mmAddOptions *mQuestionRepositoryMockAddOptions) Set(f func(ctx context.Context, questionID int64, options []*model.NewQuestionOption) (err error)) *QuestionRepositoryMock {
	if mmAddOptions.defaultExpectation != nil {
		mmAddOptions.mock.t.Fatalf("Default expectation is already set for the QuestionRepository.AddOptions method")
	}

	if len(mmAddOptions.expectations) > 0 {
		mmAddOptions.mock.t.Fatalf("Some expectations are already set for the QuestionRepository.AddOptions method")
	}

	mmAddOptions.mock.funcAddOptions = f
	mmAddOptions.mock.funcAddOptionsOrigin = minimock.CallerInfo(1)
	return mmAddOptions.mock
}

// When sets expectation for the QuestionRepository.AddOptions which will trigger the result defined by the following
// Then helper
func (mmAddOptions *mQuestionRepositoryMockAddOptions) When(ctx context.Context, questionID int64, options []*model.NewQuestionOption) *QuestionRepositoryMockAddOptionsExpectation {
	if mmAddOptions.mock.funcAddOptions != nil {
		mmAddOptions.mock.t.Fatalf("QuestionRepositoryMock.AddOptions mock is already set by Set")
	}

	expectation := &QuestionRepositoryMockAddOptionsExpectation{
		mock:               mmAddOptions.mock,
		params:             &QuestionRepositoryMockAddOptionsParams{ctx, questionID, options},
		expectationOrigins: QuestionRepositoryMockAddOptionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddOptions.expectations = append(mmAddOptions.expectations, expectation)
	return expectation
}

// Then sets up QuestionRepository.AddOptions return parameters for the expectation previously defined by the When method
func (e *QuestionRepositoryMockAddOptionsExpectation) Then(err error) *QuestionRepositoryMock {
	e.results = &QuestionRepositoryMockAddOptionsResults{err}
	return e.mock
}

// Times sets number of times QuestionRepository.AddOptions should be invoked
func (mmAddOptions *mQuestionRepositoryMockAddOptions) Times(n uint64) *mQuestionRepositoryMockAddOptions {
	if n == 0 {
		mmAddOptions.mock.t.Fatalf("Times of QuestionRepositoryMock.AddOptions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOptions.expectedInvocations, n)
	mmAddOptions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddOptions
}

func (mmAddOptions *mQuestionRepositoryMockAddOptions) invocationsDone() bool {
	if len(mmAddOptions.expectations) == 0 && mmAddOptions.defaultExpectation == nil && mmAddOptions.mock.funcAddOptions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOptions.mock.afterAddOptionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOptions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOptions implements mm_repository.QuestionRepository
func (mmAddOptions *QuestionRepositoryMock) AddOptions(ctx context.Context, questionID int64, options []*model.NewQuestionOption) (err error) {
	mm_atomic.AddUint64(&mmAddOptions.beforeAddOptionsCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOptions.afterAddOptionsCounter, 1)

	mmAddOptions.t.Helper()

	if mmAddOptions.inspectFuncAddOptions != nil {
		mmAddOptions.inspectFuncAddOptions(ctx, questionID, options)
	}

	mm_params := QuestionRepositoryMockAddOptionsParams{ctx, questionID, options}

	// Record call args
	mmAddOptions.AddOptionsMock.mutex.Lock()
	mmAddOptions.AddOptionsMock.callArgs = append(mmAddOptions.AddOptionsMock.callArgs, &mm_params)
	mmAddOptions.AddOptionsMock.mutex.Unlock()

	for _, e := range mmAddOptions.AddOptionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddOptions.AddOptionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOptions.AddOptionsMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOptions.AddOptionsMock.defaultExpectation.params
		mm_want_ptrs := mmAddOptions.AddOptionsMock.defaultExpectation.paramPtrs

		mm_got := QuestionRepositoryMockAddOptionsParams{ctx, questionID, options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddOptions.t.Errorf("QuestionRepositoryMock.AddOptions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOptions.AddOptionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.questionID != nil && !minimock.Equal(*mm_want_ptrs.questionID, mm_got.questionID) {
				mmAddOptions.t.Errorf("QuestionRepositoryMock.AddOptions got unexpected parameter questionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOptions.AddOptionsMock.defaultExpectation.expectationOrigins.originQuestionID, *mm_want_ptrs.questionID, mm_got.questionID, minimock.Diff(*mm_want_ptrs.questionID, mm_got.questionID))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmAddOptions.t.Errorf("QuestionRepositoryMock.AddOptions got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOptions.AddOptionsMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOptions.t.Errorf("QuestionRepositoryMock.AddOptions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddOptions.AddOptionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddOptions.AddOptionsMock.defaultExpectation.results
		if mm_results == nil {
			mmAddOptions.t.Fatal("No results are set for the QuestionRepositoryMock.AddOptions")
		}
		return (*mm_results).err
	}
	if mmAddOptions.funcAddOptions != nil {
		return mmAddOptions.funcAddOptions(ctx, questionID, options)
	}
	mmAddOptions.t.Fatalf("Unexpected call to QuestionRepositoryMock.AddOptions. %v %v %v", ctx, questionID, options)
	return
}

// AddOptionsAfterCounter returns a count of finished QuestionRepositoryMock.AddOptions invocations
func (mmAddOptions *QuestionRepositoryMock) AddOptionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOptions.afterAddOptionsCounter)
}

// AddOptionsBeforeCounter returns a count of QuestionRepositoryMock.AddOptions invocations
func (mmAddOptions *QuestionRepositoryMock) AddOptionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOptions.beforeAddOptionsCounter)
}

// Calls returns a list of arguments used in each call to QuestionRepositoryMock.AddOptions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOptions *mQuestionRepositoryMockAddOptions) Calls() []*QuestionRepositoryMockAddOptionsParams {
	mmAddOptions.mutex.RLock()

	argCopy := make([]*QuestionRepositoryMockAddOptionsParams, len(mmAddOptions.callArgs))
	copy(argCopy, mmAddOptions.callArgs)

	mmAddOptions.mutex.RUnlock()

	return argCopy
}

// MinimockAddOptionsDone returns true if the count of the AddOptions invocations corresponds
// the number of defined expectations
func (m *QuestionRepositoryMock) MinimockAddOptionsDone() bool {
	if m.AddOptionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOptionsMock.invocationsDone()
}

// MinimockAddOptionsInspect logs each unmet expectation
func (m *QuestionRepositoryMock) MinimockAddOptionsInspect() {
	for _, e := range m.AddOptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionRepositoryMock.AddOptions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddOptionsCounter := mm_atomic.LoadUint64(&m.afterAddOptionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOptionsMock.defaultExpectation != nil && afterAddOptionsCounter < 1 {
		if m.AddOptionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionRepositoryMock.AddOptions at\n%s", m.AddOptionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionRepositoryMock.AddOptions at\n%s with params: %#v", m.AddOptionsMock.defaultExpectation.expectationOrigins.origin, *m.AddOptionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOptions != nil && afterAddOptionsCounter < 1 {
		m.t.Errorf("Expected call to QuestionRepositoryMock.AddOptions at\n%s", m.funcAddOptionsOrigin)
	}

	if !m.AddOptionsMock.invocationsDone() && afterAddOptionsCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionRepositoryMock.AddOptions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddOptionsMock.expectedInvocations), m.AddOptionsMock.expectedInvocationsOrigin, afterAddOptionsCounter)
	}
}

type mQuestionRepositoryMockCreate struct {
	optional           bool
	mock               *QuestionRepositoryMock
	defaultExpectation *QuestionRepositoryMockCreateExpectation
	expectations       []*QuestionRepositoryMockCreateExpectation

	callArgs []*QuestionRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionRepositoryMockCreateExpectation specifies expectation struct of the QuestionRepository.Create
type QuestionRepositoryMockCreateExpectation struct {
	mock               *QuestionRepositoryMock
	params             *QuestionRepositoryMockCreateParams
	paramPtrs          *QuestionRepositoryMockCreateParamPtrs
	expectationOrigins QuestionRepositoryMockCreateExpectationOrigins
	results            *QuestionRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// QuestionRepositoryMockCreateParams contains parameters of the QuestionRepository.Create
type QuestionRepositoryMockCreateParams struct {
	ctx      context.Context
	question *model.NewQuestion
}

// QuestionRepositoryMockCreateParamPtrs contains pointers to parameters of the QuestionRepository.Create
type QuestionRepositoryMockCreateParamPtrs struct {
	ctx      *context.Context
	question **model.NewQuestion
}

// QuestionRepositoryMockCreateResults contains results of the QuestionRepository.Create
type QuestionRepositoryMockCreateResults struct {
	i1  int64
	err error
}

// QuestionRepositoryMockCreateOrigins contains origins of expectations of the QuestionRepository.Create
type QuestionRepositoryMockCreateExpectationOrigins struct {
	origin         string
	originCtx      string
	originQuestion string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mQuestionRepositoryMockCreate) Optional() *mQuestionRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for QuestionRepository.Create
func (mmCreate *mQuestionRepositoryMockCreate) Expect(ctx context.Context, question *model.NewQuestion) *mQuestionRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("QuestionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &QuestionRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("QuestionRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &QuestionRepositoryMockCreateParams{ctx, question}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for QuestionRepository.Create
func (mmCreate *mQuestionRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mQuestionRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("QuestionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &QuestionRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("QuestionRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &QuestionRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectQuestionParam2 sets up expected param question for QuestionRepository.Create
func (mmCreate *mQuestionRepositoryMockCreate) ExpectQuestionParam2(question *model.NewQuestion) *mQuestionRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("QuestionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &QuestionRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("QuestionRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &QuestionRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.question = &question
	mmCreate.defaultExpectation.expectationOrigins.originQuestion = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the QuestionRepository.Create
func (mmCreate *mQuestionRepositoryMockCreate) Inspect(f func(ctx context.Context, question *model.NewQuestion)) *mQuestionRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for QuestionRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by QuestionRepository.Create
func (mmCreate *mQuestionRepositoryMockCreate) Return(i1 int64, err error) *QuestionRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("QuestionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &QuestionRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &QuestionRepositoryMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the QuestionRepository.Create method
func (mmCreate *mQuestionRepositoryMockCreate) Set(f func(ctx context.Context, question *model.NewQuestion) (i1 int64, err error)) *QuestionRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the QuestionRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the QuestionRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the QuestionRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mQuestionRepositoryMockCreate) When(ctx context.Context, question *model.NewQuestion) *QuestionRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("QuestionRepositoryMock.Create mock is already set by Set")
	}

	expectation := &QuestionRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &QuestionRepositoryMockCreateParams{ctx, question},
		expectationOrigins: QuestionRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up QuestionRepository.Create return parameters for the expectation previously defined by the When method
func (e *QuestionRepositoryMockCreateExpectation) Then(i1 int64, err error) *QuestionRepositoryMock {
	e.results = &QuestionRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times QuestionRepository.Create should be invoked
func (mmCreate *mQuestionRepositoryMockCreate) Times(n uint64) *mQuestionRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of QuestionRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mQuestionRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_repository.QuestionRepository
func (mmCreate *QuestionRepositoryMock) Create(ctx context.Context, question *model.NewQuestion) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, question)
	}

	mm_params := QuestionRepositoryMockCreateParams{ctx, question}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := QuestionRepositoryMockCreateParams{ctx, question}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("QuestionRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.question != nil && !minimock.Equal(*mm_want_ptrs.question, mm_got.question) {
				mmCreate.t.Errorf("QuestionRepositoryMock.Create got unexpected parameter question, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originQuestion, *mm_want_ptrs.question, mm_got.question, minimock.Diff(*mm_want_ptrs.question, mm_got.question))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("QuestionRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the QuestionRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, question)
	}
	mmCreate.t.Fatalf("Unexpected call to QuestionRepositoryMock.Create. %v %v", ctx, question)
	return
}

// CreateAfterCounter returns a count of finished QuestionRepositoryMock.Create invocations
func (mmCreate *QuestionRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of QuestionRepositoryMock.Create invocations
func (mmCreate *QuestionRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to QuestionRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mQuestionRepositoryMockCreate) Calls() []*QuestionRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*QuestionRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *QuestionRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *QuestionRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to QuestionRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mQuestionRepositoryMockDelete struct {
	optional           bool
	mock               *QuestionRepositoryMock
	defaultExpectation *QuestionRepositoryMockDeleteExpectation
	expectations       []*QuestionRepositoryMockDeleteExpectation

	callArgs []*QuestionRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionRepositoryMockDeleteExpectation specifies expectation struct of the QuestionRepository.Delete
type QuestionRepositoryMockDeleteExpectation struct {
	mock               *QuestionRepositoryMock
	params             *QuestionRepositoryMockDeleteParams
	paramPtrs          *QuestionRepositoryMockDeleteParamPtrs
	expectationOrigins QuestionRepositoryMockDeleteExpectationOrigins
	results            *QuestionRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// QuestionRepositoryMockDeleteParams contains parameters of the QuestionRepository.Delete
type QuestionRepositoryMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// QuestionRepositoryMockDeleteParamPtrs contains pointers to parameters of the QuestionRepository.Delete
type QuestionRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// QuestionRepositoryMockDeleteResults contains results of the QuestionRepository.Delete
type QuestionRepositoryMockDeleteResults struct {
	err error
}

// QuestionRepositoryMockDeleteOrigins contains origins of expectations of the QuestionRepository.Delete
type QuestionRepositoryMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mQuestionRepositoryMockDelete) Optional() *mQuestionRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for QuestionRepository.Delete
func (mmDelete *mQuestionRepositoryMockDelete) Expect(ctx context.Context, id int64) *mQuestionRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("QuestionRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &QuestionRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("QuestionRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &QuestionRepositoryMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for QuestionRepository.Delete
func (mmDelete *mQuestionRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mQuestionRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("QuestionRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &QuestionRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("QuestionRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &QuestionRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for QuestionRepository.Delete
func (mmDelete *mQuestionRepositoryMockDelete) ExpectIdParam2(id int64) *mQuestionRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("QuestionRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &QuestionRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("QuestionRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &QuestionRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the QuestionRepository.Delete
func (mmDelete *mQuestionRepositoryMockDelete) Inspect(f func(ctx context.Context, id int64)) *mQuestionRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for QuestionRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by QuestionRepository.Delete
func (mmDelete *mQuestionRepositoryMockDelete) Return(err error) *QuestionRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("QuestionRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &QuestionRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &QuestionRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the QuestionRepository.Delete method
func (mmDelete *mQuestionRepositoryMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *QuestionRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the QuestionRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the QuestionRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the QuestionRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mQuestionRepositoryMockDelete) When(ctx context.Context, id int64) *QuestionRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("QuestionRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &QuestionRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &QuestionRepositoryMockDeleteParams{ctx, id},
		expectationOrigins: QuestionRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up QuestionRepository.Delete return parameters for the expectation previously defined by the When method
func (e *QuestionRepositoryMockDeleteExpectation) Then(err error) *QuestionRepositoryMock {
	e.results = &QuestionRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times QuestionRepository.Delete should be invoked
func (mmDelete *mQuestionRepositoryMockDelete) Times(n uint64) *mQuestionRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of QuestionRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mQuestionRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_repository.QuestionRepository
func (mmDelete *QuestionRepositoryMock) Delete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := QuestionRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := QuestionRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("QuestionRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("QuestionRepositoryMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("QuestionRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the QuestionRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to QuestionRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished QuestionRepositoryMock.Delete invocations
func (mmDelete *QuestionRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of QuestionRepositoryMock.Delete invocations
func (mmDelete *QuestionRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to QuestionRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mQuestionRepositoryMockDelete) Calls() []*QuestionRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*QuestionRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *QuestionRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *QuestionRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to QuestionRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mQuestionRepositoryMockDeleteOptions struct {
	optional           bool
	mock               *QuestionRepositoryMock
	defaultExpectation *QuestionRepositoryMockDeleteOptionsExpectation
	expectations       []*QuestionRepositoryMockDeleteOptionsExpectation

	callArgs []*QuestionRepositoryMockDeleteOptionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionRepositoryMockDeleteOptionsExpectation specifies expectation struct of the QuestionRepository.DeleteOptions
type QuestionRepositoryMockDeleteOptionsExpectation struct {
	mock               *QuestionRepositoryMock
	params             *QuestionRepositoryMockDeleteOptionsParams
	paramPtrs          *QuestionRepositoryMockDeleteOptionsParamPtrs
	expectationOrigins QuestionRepositoryMockDeleteOptionsExpectationOrigins
	results            *QuestionRepositoryMockDeleteOptionsResults
	returnOrigin       string
	Counter            uint64
}

// QuestionRepositoryMockDeleteOptionsParams contains parameters of the QuestionRepository.DeleteOptions
type QuestionRepositoryMockDeleteOptionsParams struct {
	ctx context.Context
	ids []int64
}

// QuestionRepositoryMockDeleteOptionsParamPtrs contains pointers to parameters of the QuestionRepository.DeleteOptions
type QuestionRepositoryMockDeleteOptionsParamPtrs struct {
	ctx *context.Context
	ids *[]int64
}

// QuestionRepositoryMockDeleteOptionsResults contains results of the QuestionRepository.DeleteOptions
type QuestionRepositoryMockDeleteOptionsResults struct {
	err error
}

// QuestionRepositoryMockDeleteOptionsOrigins contains origins of expectations of the QuestionRepository.DeleteOptions
type QuestionRepositoryMockDeleteOptionsExpectationOrigins struct {
	origin    string
	originCtx string
	originIds string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteOptions *mQuestionRepositoryMockDeleteOptions) Optional() *mQuestionRepositoryMockDeleteOptions {
	mmDeleteOptions.optional = true
	return mmDeleteOptions
}

// Expect sets up expected params for QuestionRepository.DeleteOptions
func (mmDeleteOptions *mQuestionRepositoryMockDeleteOptions) Expect(ctx context.Context, ids []int64) *mQuestionRepositoryMockDeleteOptions {
	if mmDeleteOptions.mock.funcDeleteOptions != nil {
		mmDeleteOptions.mock.t.Fatalf("QuestionRepositoryMock.DeleteOptions mock is already set by Set")
	}

	if mmDeleteOptions.defaultExpectation == nil {
		mmDeleteOptions.defaultExpectation = &QuestionRepositoryMockDeleteOptionsExpectation{}
	}

	if mmDeleteOptions.defaultExpectation.paramPtrs != nil {
		mmDeleteOptions.mock.t.Fatalf("QuestionRepositoryMock.DeleteOptions mock is already set by ExpectParams functions")
	}

	mmDeleteOptions.defaultExpectation.params = &QuestionRepositoryMockDeleteOptionsParams{ctx, ids}
	mmDeleteOptions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteOptions.expectations {
		if minimock.Equal(e.params, mmDeleteOptions.defaultExpectation.params) {
			mmDeleteOptions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteOptions.defaultExpectation.params)
		}
	}

	return mmDeleteOptions
}

// ExpectCtxParam1 sets up expected param ctx for QuestionRepository.DeleteOptions
func (mmDeleteOptions *mQuestionRepositoryMockDeleteOptions) ExpectCtxParam1(ctx context.Context) *mQuestionRepositoryMockDeleteOptions {
	if mmDeleteOptions.mock.funcDeleteOptions != nil {
		mmDeleteOptions.mock.t.Fatalf("QuestionRepositoryMock.DeleteOptions mock is already set by Set")
	}

	if mmDeleteOptions.defaultExpectation == nil {
		mmDeleteOptions.defaultExpectation = &QuestionRepositoryMockDeleteOptionsExpectation{}
	}

	if mmDeleteOptions.defaultExpectation.params != nil {
		mmDeleteOptions.mock.t.Fatalf("QuestionRepositoryMock.DeleteOptions mock is already set by Expect")
	}

	if mmDeleteOptions.defaultExpectation.paramPtrs == nil {
		mmDeleteOptions.defaultExpectation.paramPtrs = &QuestionRepositoryMockDeleteOptionsParamPtrs{}
	}
	mmDeleteOptions.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteOptions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteOptions
}

// ExpectIdsParam2 sets up expected param ids for QuestionRepository.DeleteOptions
func (mmDeleteOptions *mQuestionRepositoryMockDeleteOptions) ExpectIdsParam2(ids []int64) *mQuestionRepositoryMockDeleteOptions {
	if mmDeleteOptions.mock.funcDeleteOptions != nil {
		mmDeleteOptions.mock.t.Fatalf("QuestionRepositoryMock.DeleteOptions mock is already set by Set")
	}

	if mmDeleteOptions.defaultExpectation == nil {
		mmDeleteOptions.defaultExpectation = &QuestionRepositoryMockDeleteOptionsExpectation{}
	}

	if mmDeleteOptions.defaultExpectation.params != nil {
		mmDeleteOptions.mock.t.Fatalf("QuestionRepositoryMock.DeleteOptions mock is already set by Expect")
	}

	if mmDeleteOptions.defaultExpectation.paramPtrs == nil {
		mmDeleteOptions.defaultExpectation.paramPtrs = &QuestionRepositoryMockDeleteOptionsParamPtrs{}
	}
	mmDeleteOptions.defaultExpectation.paramPtrs.ids = &ids
	mmDeleteOptions.defaultExpectation.expectationOrigins.originIds = minimock.CallerInfo(1)

	return mmDeleteOptions
}

// Inspect accepts an inspector function that has same arguments as the QuestionRepository.DeleteOptions
func (mmDeleteOptions *mQuestionRepositoryMockDeleteOptions) Inspect(f func(ctx context.Context, ids []int64)) *mQuestionRepositoryMockDeleteOptions {
	if mmDeleteOptions.mock.inspectFuncDeleteOptions != nil {
		mmDeleteOptions.mock.t.Fatalf("Inspect function is already set for QuestionRepositoryMock.DeleteOptions")
	}

	mmDeleteOptions.mock.inspectFuncDeleteOptions = f

	return mmDeleteOptions
}

// Return sets up results that will be returned by QuestionRepository.DeleteOptions
func (mmDeleteOptions *mQuestionRepositoryMockDeleteOptions) Return(err error) *QuestionRepositoryMock {
	if mmDeleteOptions.mock.funcDeleteOptions != nil {
		mmDeleteOptions.mock.t.Fatalf("QuestionRepositoryMock.DeleteOptions mock is already set by Set")
	}

	if mmDeleteOptions.defaultExpectation == nil {
		mmDeleteOptions.defaultExpectation = &QuestionRepositoryMockDeleteOptionsExpectation{mock: mmDeleteOptions.mock}
	}
	mmDeleteOptions.defaultExpectation.results = &QuestionRepositoryMockDeleteOptionsResults{err}
	mmDeleteOptions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteOptions.mock
}

// Set uses given function f to mock the QuestionRepository.DeleteOptions method
func (mmDeleteOptions *mQuestionRepositoryMockDeleteOptions) Set(f func(ctx context.Context, ids []int64) (err error)) *QuestionRepositoryMock {
	if mmDeleteOptions.defaultExpectation != nil {
		mmDeleteOptions.mock.t.Fatalf("Default expectation is already set for the QuestionRepository.DeleteOptions method")
	}

	if len(mmDeleteOptions.expectations) > 0 {
		mmDeleteOptions.mock.t.Fatalf("Some expectations are already set for the QuestionRepository.DeleteOptions method")
	}

	mmDeleteOptions.mock.funcDeleteOptions = f
	mmDeleteOptions.mock.funcDeleteOptionsOrigin = minimock.CallerInfo(1)
	return mmDeleteOptions.mock
}

// When sets expectation for the QuestionRepository.DeleteOptions which will trigger the result defined by the following
// Then helper
func (mmDeleteOptions *mQuestionRepositoryMockDeleteOptions) When(ctx context.Context, ids []int64) *QuestionRepositoryMockDeleteOptionsExpectation {
	if mmDeleteOptions.mock.funcDeleteOptions != nil {
		mmDeleteOptions.mock.t.Fatalf("QuestionRepositoryMock.DeleteOptions mock is already set by Set")
	}

	expectation := &QuestionRepositoryMockDeleteOptionsExpectation{
		mock:               mmDeleteOptions.mock,
		params:             &QuestionRepositoryMockDeleteOptionsParams{ctx, ids},
		expectationOrigins: QuestionRepositoryMockDeleteOptionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteOptions.expectations = append(mmDeleteOptions.expectations, expectation)
	return expectation
}

// Then sets up QuestionRepository.DeleteOptions return parameters for the expectation previously defined by the When method
func (e *QuestionRepositoryMockDeleteOptionsExpectation) Then(err error) *QuestionRepositoryMock {
	e.results = &QuestionRepositoryMockDeleteOptionsResults{err}
	return e.mock
}

// Times sets number of times QuestionRepository.DeleteOptions should be invoked
func (mmDeleteOptions *mQuestionRepositoryMockDeleteOptions) Times(n uint64) *mQuestionRepositoryMockDeleteOptions {
	if n == 0 {
		mmDeleteOptions.mock.t.Fatalf("Times of QuestionRepositoryMock.DeleteOptions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteOptions.expectedInvocations, n)
	mmDeleteOptions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteOptions
}

func (mmDeleteOptions *mQuestionRepositoryMockDeleteOptions) invocationsDone() bool {
	if len(mmDeleteOptions.expectations) == 0 && mmDeleteOptions.defaultExpectation == nil && mmDeleteOptions.mock.funcDeleteOptions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteOptions.mock.afterDeleteOptionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteOptions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteOptions implements mm_repository.QuestionRepository
func (mmDeleteOptions *QuestionRepositoryMock) DeleteOptions(ctx context.Context, ids []int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteOptions.beforeDeleteOptionsCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteOptions.afterDeleteOptionsCounter, 1)

	mmDeleteOptions.t.Helper()

	if mmDeleteOptions.inspectFuncDeleteOptions != nil {
		mmDeleteOptions.inspectFuncDeleteOptions(ctx, ids)
	}

	mm_params := QuestionRepositoryMockDeleteOptionsParams{ctx, ids}

	// Record call args
	mmDeleteOptions.DeleteOptionsMock.mutex.Lock()
	mmDeleteOptions.DeleteOptionsMock.callArgs = append(mmDeleteOptions.DeleteOptionsMock.callArgs, &mm_params)
	mmDeleteOptions.DeleteOptionsMock.mutex.Unlock()

	for _, e := range mmDeleteOptions.DeleteOptionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteOptions.DeleteOptionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteOptions.DeleteOptionsMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteOptions.DeleteOptionsMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteOptions.DeleteOptionsMock.defaultExpectation.paramPtrs

		mm_got := QuestionRepositoryMockDeleteOptionsParams{ctx, ids}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteOptions.t.Errorf("QuestionRepositoryMock.DeleteOptions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteOptions.DeleteOptionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ids != nil && !minimock.Equal(*mm_want_ptrs.ids, mm_got.ids) {
				mmDeleteOptions.t.Errorf("QuestionRepositoryMock.DeleteOptions got unexpected parameter ids, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteOptions.DeleteOptionsMock.defaultExpectation.expectationOrigins.originIds, *mm_want_ptrs.ids, mm_got.ids, minimock.Diff(*mm_want_ptrs.ids, mm_got.ids))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteOptions.t.Errorf("QuestionRepositoryMock.DeleteOptions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteOptions.DeleteOptionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteOptions.DeleteOptionsMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteOptions.t.Fatal("No results are set for the QuestionRepositoryMock.DeleteOptions")
		}
		return (*mm_results).err
	}
	if mmDeleteOptions.funcDeleteOptions != nil {
		return mmDeleteOptions.funcDeleteOptions(ctx, ids)
	}
	mmDeleteOptions.t.Fatalf("Unexpected call to QuestionRepositoryMock.DeleteOptions. %v %v", ctx, ids)
	return
}

// DeleteOptionsAfterCounter returns a count of finished QuestionRepositoryMock.DeleteOptions invocations
func (mmDeleteOptions *QuestionRepositoryMock) DeleteOptionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOptions.afterDeleteOptionsCounter)
}

// DeleteOptionsBeforeCounter returns a count of QuestionRepositoryMock.DeleteOptions invocations
func (mmDeleteOptions *QuestionRepositoryMock) DeleteOptionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOptions.beforeDeleteOptionsCounter)
}

// Calls returns a list of arguments used in each call to QuestionRepositoryMock.DeleteOptions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteOptions *mQuestionRepositoryMockDeleteOptions) Calls() []*QuestionRepositoryMockDeleteOptionsParams {
	mmDeleteOptions.mutex.RLock()

	argCopy := make([]*QuestionRepositoryMockDeleteOptionsParams, len(mmDeleteOptions.callArgs))
	copy(argCopy, mmDeleteOptions.callArgs)

	mmDeleteOptions.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteOptionsDone returns true if the count of the DeleteOptions invocations corresponds
// the number of defined expectations
func (m *QuestionRepositoryMock) MinimockDeleteOptionsDone() bool {
	if m.DeleteOptionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteOptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteOptionsMock.invocationsDone()
}

// MinimockDeleteOptionsInspect logs each unmet expectation
func (m *QuestionRepositoryMock) MinimockDeleteOptionsInspect() {
	for _, e := range m.DeleteOptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionRepositoryMock.DeleteOptions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteOptionsCounter := mm_atomic.LoadUint64(&m.afterDeleteOptionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOptionsMock.defaultExpectation != nil && afterDeleteOptionsCounter < 1 {
		if m.DeleteOptionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionRepositoryMock.DeleteOptions at\n%s", m.DeleteOptionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionRepositoryMock.DeleteOptions at\n%s with params: %#v", m.DeleteOptionsMock.defaultExpectation.expectationOrigins.origin, *m.DeleteOptionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOptions != nil && afterDeleteOptionsCounter < 1 {
		m.t.Errorf("Expected call to QuestionRepositoryMock.DeleteOptions at\n%s", m.funcDeleteOptionsOrigin)
	}

	if !m.DeleteOptionsMock.invocationsDone() && afterDeleteOptionsCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionRepositoryMock.DeleteOptions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteOptionsMock.expectedInvocations), m.DeleteOptionsMock.expectedInvocationsOrigin, afterDeleteOptionsCounter)
	}
}

type mQuestionRepositoryMockGet struct {
	optional           bool
	mock               *QuestionRepositoryMock
	defaultExpectation *QuestionRepositoryMockGetExpectation
	expectations       []*QuestionRepositoryMockGetExpectation

	callArgs []*QuestionRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionRepositoryMockGetExpectation specifies expectation struct of the QuestionRepository.Get
type QuestionRepositoryMockGetExpectation struct {
	mock               *QuestionRepositoryMock
	params             *QuestionRepositoryMockGetParams
	paramPtrs          *QuestionRepositoryMockGetParamPtrs
	expectationOrigins QuestionRepositoryMockGetExpectationOrigins
	results            *QuestionRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// QuestionRepositoryMockGetParams contains parameters of the QuestionRepository.Get
type QuestionRepositoryMockGetParams struct {
	ctx context.Context
	id  int64
}

// QuestionRepositoryMockGetParamPtrs contains pointers to parameters of the QuestionRepository.Get
type QuestionRepositoryMockGetParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// QuestionRepositoryMockGetResults contains results of the QuestionRepository.Get
type QuestionRepositoryMockGetResults struct {
	qp1 *model.Question
	err error
}

// QuestionRepositoryMockGetOrigins contains origins of expectations of the QuestionRepository.Get
type QuestionRepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mQuestionRepositoryMockGet) Optional() *mQuestionRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for QuestionRepository.Get
func (mmGet *mQuestionRepositoryMockGet) Expect(ctx context.Context, id int64) *mQuestionRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("QuestionRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &QuestionRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("QuestionRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &QuestionRepositoryMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for QuestionRepository.Get
func (mmGet *mQuestionRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mQuestionRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("QuestionRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &QuestionRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("QuestionRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &QuestionRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for QuestionRepository.Get
func (mmGet *mQuestionRepositoryMockGet) ExpectIdParam2(id int64) *mQuestionRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("QuestionRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &QuestionRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("QuestionRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &QuestionRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the QuestionRepository.Get
func (mmGet *mQuestionRepositoryMockGet) Inspect(f func(ctx context.Context, id int64)) *mQuestionRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for QuestionRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by QuestionRepository.Get
func (mmGet *mQuestionRepositoryMockGet) Return(qp1 *model.Question, err error) *QuestionRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("QuestionRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &QuestionRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &QuestionRepositoryMockGetResults{qp1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the QuestionRepository.Get method
func (mmGet *mQuestionRepositoryMockGet) Set(f func(ctx context.Context, id int64) (qp1 *model.Question, err error)) *QuestionRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the QuestionRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the QuestionRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the QuestionRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mQuestionRepositoryMockGet) When(ctx context.Context, id int64) *QuestionRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("QuestionRepositoryMock.Get mock is already set by Set")
	}

	expectation := &QuestionRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &QuestionRepositoryMockGetParams{ctx, id},
		expectationOrigins: QuestionRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up QuestionRepository.Get return parameters for the expectation previously defined by the When method
func (e *QuestionRepositoryMockGetExpectation) Then(qp1 *model.Question, err error) *QuestionRepositoryMock {
	e.results = &QuestionRepositoryMockGetResults{qp1, err}
	return e.mock
}

// Times sets number of times QuestionRepository.Get should be invoked
func (mmGet *mQuestionRepositoryMockGet) Times(n uint64) *mQuestionRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of QuestionRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mQuestionRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.QuestionRepository
func (mmGet *QuestionRepositoryMock) Get(ctx context.Context, id int64) (qp1 *model.Question, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := QuestionRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.qp1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := QuestionRepositoryMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("QuestionRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("QuestionRepositoryMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("QuestionRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the QuestionRepositoryMock.Get")
		}
		return (*mm_results).qp1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to QuestionRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished QuestionRepositoryMock.Get invocations
func (mmGet *QuestionRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of QuestionRepositoryMock.Get invocations
func (mmGet *QuestionRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to QuestionRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mQuestionRepositoryMockGet) Calls() []*QuestionRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*QuestionRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *QuestionRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *QuestionRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to QuestionRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mQuestionRepositoryMockUpdate struct {
	optional           bool
	mock               *QuestionRepositoryMock
	defaultExpectation *QuestionRepositoryMockUpdateExpectation
	expectations       []*QuestionRepositoryMockUpdateExpectation

	callArgs []*QuestionRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionRepositoryMockUpdateExpectation specifies expectation struct of the QuestionRepository.Update
type QuestionRepositoryMockUpdateExpectation struct {
	mock               *QuestionRepositoryMock
	params             *QuestionRepositoryMockUpdateParams
	paramPtrs          *QuestionRepositoryMockUpdateParamPtrs
	expectationOrigins QuestionRepositoryMockUpdateExpectationOrigins
	results            *QuestionRepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// QuestionRepositoryMockUpdateParams contains parameters of the QuestionRepository.Update
type QuestionRepositoryMockUpdateParams struct {
	ctx             context.Context
	id              int64
	updatedQuestion *model.UpdatedQuestion
}

// QuestionRepositoryMockUpdateParamPtrs contains pointers to parameters of the QuestionRepository.Update
type QuestionRepositoryMockUpdateParamPtrs struct {
	ctx             *context.Context
	id              *int64
	updatedQuestion **model.UpdatedQuestion
}

// QuestionRepositoryMockUpdateResults contains results of the QuestionRepository.Update
type QuestionRepositoryMockUpdateResults struct {
	err error
}

// QuestionRepositoryMockUpdateOrigins contains origins of expectations of the QuestionRepository.Update
type QuestionRepositoryMockUpdateExpectationOrigins struct {
	origin                string
	originCtx             string
	originId              string
	originUpdatedQuestion string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mQuestionRepositoryMockUpdate) Optional() *mQuestionRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for QuestionRepository.Update
func (mmUpdate *mQuestionRepositoryMockUpdate) Expect(ctx context.Context, id int64, updatedQuestion *model.UpdatedQuestion) *mQuestionRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("QuestionRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &QuestionRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("QuestionRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &QuestionRepositoryMockUpdateParams{ctx, id, updatedQuestion}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for QuestionRepository.Update
func (mmUpdate *mQuestionRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mQuestionRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("QuestionRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &QuestionRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("QuestionRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &QuestionRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectIdParam2 sets up expected param id for QuestionRepository.Update
func (mmUpdate *mQuestionRepositoryMockUpdate) ExpectIdParam2(id int64) *mQuestionRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("QuestionRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &QuestionRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("QuestionRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &QuestionRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.id = &id
	mmUpdate.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectUpdatedQuestionParam3 sets up expected param updatedQuestion for QuestionRepository.Update
func (mmUpdate *mQuestionRepositoryMockUpdate) ExpectUpdatedQuestionParam3(updatedQuestion *model.UpdatedQuestion) *mQuestionRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("QuestionRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &QuestionRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("QuestionRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &QuestionRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.updatedQuestion = &updatedQuestion
	mmUpdate.defaultExpectation.expectationOrigins.originUpdatedQuestion = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the QuestionRepository.Update
func (mmUpdate *mQuestionRepositoryMockUpdate) Inspect(f func(ctx context.Context, id int64, updatedQuestion *model.UpdatedQuestion)) *mQuestionRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for QuestionRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by QuestionRepository.Update
func (mmUpdate *mQuestionRepositoryMockUpdate) Return(err error) *QuestionRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("QuestionRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &QuestionRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &QuestionRepositoryMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the QuestionRepository.Update method
func (mmUpdate *mQuestionRepositoryMockUpdate) Set(f func(ctx context.Context, id int64, updatedQuestion *model.UpdatedQuestion) (err error)) *QuestionRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the QuestionRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the QuestionRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the QuestionRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mQuestionRepositoryMockUpdate) When(ctx context.Context, id int64, updatedQuestion *model.UpdatedQuestion) *QuestionRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("QuestionRepositoryMock.Update mock is already set by Set")
	}

	expectation := &QuestionRepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &QuestionRepositoryMockUpdateParams{ctx, id, updatedQuestion},
		expectationOrigins: QuestionRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up QuestionRepository.Update return parameters for the expectation previously defined by the When method
func (e *QuestionRepositoryMockUpdateExpectation) Then(err error) *QuestionRepositoryMock {
	e.results = &QuestionRepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times QuestionRepository.Update should be invoked
func (mmUpdate *mQuestionRepositoryMockUpdate) Times(n uint64) *mQuestionRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of QuestionRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mQuestionRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_repository.QuestionRepository
func (mmUpdate *QuestionRepositoryMock) Update(ctx context.Context, id int64, updatedQuestion *model.UpdatedQuestion) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, id, updatedQuestion)
	}

	mm_params := QuestionRepositoryMockUpdateParams{ctx, id, updatedQuestion}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := QuestionRepositoryMockUpdateParams{ctx, id, updatedQuestion}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("QuestionRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdate.t.Errorf("QuestionRepositoryMock.Update got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.updatedQuestion != nil && !minimock.Equal(*mm_want_ptrs.updatedQuestion, mm_got.updatedQuestion) {
				mmUpdate.t.Errorf("QuestionRepositoryMock.Update got unexpected parameter updatedQuestion, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originUpdatedQuestion, *mm_want_ptrs.updatedQuestion, mm_got.updatedQuestion, minimock.Diff(*mm_want_ptrs.updatedQuestion, mm_got.updatedQuestion))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("QuestionRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the QuestionRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, id, updatedQuestion)
	}
	mmUpdate.t.Fatalf("Unexpected call to QuestionRepositoryMock.Update. %v %v %v", ctx, id, updatedQuestion)
	return
}

// UpdateAfterCounter returns a count of finished QuestionRepositoryMock.Update invocations
func (mmUpdate *QuestionRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of QuestionRepositoryMock.Update invocations
func (mmUpdate *QuestionRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to QuestionRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mQuestionRepositoryMockUpdate) Calls() []*QuestionRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*QuestionRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *QuestionRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *QuestionRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to QuestionRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionRepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *QuestionRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddOptionsInspect()

			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockDeleteOptionsInspect()

			m.MinimockGetInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *QuestionRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *QuestionRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddOptionsDone() &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockDeleteOptionsDone() &&
		m.MinimockGetDone() &&
		m.MinimockUpdateDone()
}
