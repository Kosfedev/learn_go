// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Kosfedev/learn_go/internal/repository.SubcategoryRepository -o subcategory_repository_minimock.go -n SubcategoryRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Kosfedev/learn_go/internal/model"
	"github.com/gojuno/minimock/v3"
)

// SubcategoryRepositoryMock implements mm_repository.SubcategoryRepository
type SubcategoryRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, subcategory *model.NewSubcategory) (i1 int, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, subcategory *model.NewSubcategory)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mSubcategoryRepositoryMockCreate

	funcDelete          func(ctx context.Context, id int) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id int)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mSubcategoryRepositoryMockDelete

	funcGet          func(ctx context.Context, id int) (sp1 *model.Subcategory, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id int)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mSubcategoryRepositoryMockGet

	funcUpdate          func(ctx context.Context, id int, updatedSubcategory *model.UpdatedSubcategory) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, id int, updatedSubcategory *model.UpdatedSubcategory)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mSubcategoryRepositoryMockUpdate
}

// NewSubcategoryRepositoryMock returns a mock for mm_repository.SubcategoryRepository
func NewSubcategoryRepositoryMock(t minimock.Tester) *SubcategoryRepositoryMock {
	m := &SubcategoryRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mSubcategoryRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*SubcategoryRepositoryMockCreateParams{}

	m.DeleteMock = mSubcategoryRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*SubcategoryRepositoryMockDeleteParams{}

	m.GetMock = mSubcategoryRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*SubcategoryRepositoryMockGetParams{}

	m.UpdateMock = mSubcategoryRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*SubcategoryRepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mSubcategoryRepositoryMockCreate struct {
	optional           bool
	mock               *SubcategoryRepositoryMock
	defaultExpectation *SubcategoryRepositoryMockCreateExpectation
	expectations       []*SubcategoryRepositoryMockCreateExpectation

	callArgs []*SubcategoryRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SubcategoryRepositoryMockCreateExpectation specifies expectation struct of the SubcategoryRepository.Create
type SubcategoryRepositoryMockCreateExpectation struct {
	mock               *SubcategoryRepositoryMock
	params             *SubcategoryRepositoryMockCreateParams
	paramPtrs          *SubcategoryRepositoryMockCreateParamPtrs
	expectationOrigins SubcategoryRepositoryMockCreateExpectationOrigins
	results            *SubcategoryRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// SubcategoryRepositoryMockCreateParams contains parameters of the SubcategoryRepository.Create
type SubcategoryRepositoryMockCreateParams struct {
	ctx         context.Context
	subcategory *model.NewSubcategory
}

// SubcategoryRepositoryMockCreateParamPtrs contains pointers to parameters of the SubcategoryRepository.Create
type SubcategoryRepositoryMockCreateParamPtrs struct {
	ctx         *context.Context
	subcategory **model.NewSubcategory
}

// SubcategoryRepositoryMockCreateResults contains results of the SubcategoryRepository.Create
type SubcategoryRepositoryMockCreateResults struct {
	i1  int
	err error
}

// SubcategoryRepositoryMockCreateOrigins contains origins of expectations of the SubcategoryRepository.Create
type SubcategoryRepositoryMockCreateExpectationOrigins struct {
	origin            string
	originCtx         string
	originSubcategory string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mSubcategoryRepositoryMockCreate) Optional() *mSubcategoryRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for SubcategoryRepository.Create
func (mmCreate *mSubcategoryRepositoryMockCreate) Expect(ctx context.Context, subcategory *model.NewSubcategory) *mSubcategoryRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SubcategoryRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &SubcategoryRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("SubcategoryRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &SubcategoryRepositoryMockCreateParams{ctx, subcategory}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for SubcategoryRepository.Create
func (mmCreate *mSubcategoryRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mSubcategoryRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SubcategoryRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &SubcategoryRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("SubcategoryRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &SubcategoryRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectSubcategoryParam2 sets up expected param subcategory for SubcategoryRepository.Create
func (mmCreate *mSubcategoryRepositoryMockCreate) ExpectSubcategoryParam2(subcategory *model.NewSubcategory) *mSubcategoryRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SubcategoryRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &SubcategoryRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("SubcategoryRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &SubcategoryRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.subcategory = &subcategory
	mmCreate.defaultExpectation.expectationOrigins.originSubcategory = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the SubcategoryRepository.Create
func (mmCreate *mSubcategoryRepositoryMockCreate) Inspect(f func(ctx context.Context, subcategory *model.NewSubcategory)) *mSubcategoryRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for SubcategoryRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by SubcategoryRepository.Create
func (mmCreate *mSubcategoryRepositoryMockCreate) Return(i1 int, err error) *SubcategoryRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SubcategoryRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &SubcategoryRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &SubcategoryRepositoryMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the SubcategoryRepository.Create method
func (mmCreate *mSubcategoryRepositoryMockCreate) Set(f func(ctx context.Context, subcategory *model.NewSubcategory) (i1 int, err error)) *SubcategoryRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the SubcategoryRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the SubcategoryRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the SubcategoryRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mSubcategoryRepositoryMockCreate) When(ctx context.Context, subcategory *model.NewSubcategory) *SubcategoryRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SubcategoryRepositoryMock.Create mock is already set by Set")
	}

	expectation := &SubcategoryRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &SubcategoryRepositoryMockCreateParams{ctx, subcategory},
		expectationOrigins: SubcategoryRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up SubcategoryRepository.Create return parameters for the expectation previously defined by the When method
func (e *SubcategoryRepositoryMockCreateExpectation) Then(i1 int, err error) *SubcategoryRepositoryMock {
	e.results = &SubcategoryRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times SubcategoryRepository.Create should be invoked
func (mmCreate *mSubcategoryRepositoryMockCreate) Times(n uint64) *mSubcategoryRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of SubcategoryRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mSubcategoryRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_repository.SubcategoryRepository
func (mmCreate *SubcategoryRepositoryMock) Create(ctx context.Context, subcategory *model.NewSubcategory) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, subcategory)
	}

	mm_params := SubcategoryRepositoryMockCreateParams{ctx, subcategory}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := SubcategoryRepositoryMockCreateParams{ctx, subcategory}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("SubcategoryRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.subcategory != nil && !minimock.Equal(*mm_want_ptrs.subcategory, mm_got.subcategory) {
				mmCreate.t.Errorf("SubcategoryRepositoryMock.Create got unexpected parameter subcategory, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originSubcategory, *mm_want_ptrs.subcategory, mm_got.subcategory, minimock.Diff(*mm_want_ptrs.subcategory, mm_got.subcategory))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("SubcategoryRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the SubcategoryRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, subcategory)
	}
	mmCreate.t.Fatalf("Unexpected call to SubcategoryRepositoryMock.Create. %v %v", ctx, subcategory)
	return
}

// CreateAfterCounter returns a count of finished SubcategoryRepositoryMock.Create invocations
func (mmCreate *SubcategoryRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of SubcategoryRepositoryMock.Create invocations
func (mmCreate *SubcategoryRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to SubcategoryRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mSubcategoryRepositoryMockCreate) Calls() []*SubcategoryRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*SubcategoryRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *SubcategoryRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *SubcategoryRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubcategoryRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SubcategoryRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SubcategoryRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to SubcategoryRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to SubcategoryRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mSubcategoryRepositoryMockDelete struct {
	optional           bool
	mock               *SubcategoryRepositoryMock
	defaultExpectation *SubcategoryRepositoryMockDeleteExpectation
	expectations       []*SubcategoryRepositoryMockDeleteExpectation

	callArgs []*SubcategoryRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SubcategoryRepositoryMockDeleteExpectation specifies expectation struct of the SubcategoryRepository.Delete
type SubcategoryRepositoryMockDeleteExpectation struct {
	mock               *SubcategoryRepositoryMock
	params             *SubcategoryRepositoryMockDeleteParams
	paramPtrs          *SubcategoryRepositoryMockDeleteParamPtrs
	expectationOrigins SubcategoryRepositoryMockDeleteExpectationOrigins
	results            *SubcategoryRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// SubcategoryRepositoryMockDeleteParams contains parameters of the SubcategoryRepository.Delete
type SubcategoryRepositoryMockDeleteParams struct {
	ctx context.Context
	id  int
}

// SubcategoryRepositoryMockDeleteParamPtrs contains pointers to parameters of the SubcategoryRepository.Delete
type SubcategoryRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int
}

// SubcategoryRepositoryMockDeleteResults contains results of the SubcategoryRepository.Delete
type SubcategoryRepositoryMockDeleteResults struct {
	err error
}

// SubcategoryRepositoryMockDeleteOrigins contains origins of expectations of the SubcategoryRepository.Delete
type SubcategoryRepositoryMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mSubcategoryRepositoryMockDelete) Optional() *mSubcategoryRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for SubcategoryRepository.Delete
func (mmDelete *mSubcategoryRepositoryMockDelete) Expect(ctx context.Context, id int) *mSubcategoryRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("SubcategoryRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &SubcategoryRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("SubcategoryRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &SubcategoryRepositoryMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for SubcategoryRepository.Delete
func (mmDelete *mSubcategoryRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mSubcategoryRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("SubcategoryRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &SubcategoryRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("SubcategoryRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &SubcategoryRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for SubcategoryRepository.Delete
func (mmDelete *mSubcategoryRepositoryMockDelete) ExpectIdParam2(id int) *mSubcategoryRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("SubcategoryRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &SubcategoryRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("SubcategoryRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &SubcategoryRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the SubcategoryRepository.Delete
func (mmDelete *mSubcategoryRepositoryMockDelete) Inspect(f func(ctx context.Context, id int)) *mSubcategoryRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for SubcategoryRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by SubcategoryRepository.Delete
func (mmDelete *mSubcategoryRepositoryMockDelete) Return(err error) *SubcategoryRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("SubcategoryRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &SubcategoryRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &SubcategoryRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the SubcategoryRepository.Delete method
func (mmDelete *mSubcategoryRepositoryMockDelete) Set(f func(ctx context.Context, id int) (err error)) *SubcategoryRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the SubcategoryRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the SubcategoryRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the SubcategoryRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mSubcategoryRepositoryMockDelete) When(ctx context.Context, id int) *SubcategoryRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("SubcategoryRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &SubcategoryRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &SubcategoryRepositoryMockDeleteParams{ctx, id},
		expectationOrigins: SubcategoryRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up SubcategoryRepository.Delete return parameters for the expectation previously defined by the When method
func (e *SubcategoryRepositoryMockDeleteExpectation) Then(err error) *SubcategoryRepositoryMock {
	e.results = &SubcategoryRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times SubcategoryRepository.Delete should be invoked
func (mmDelete *mSubcategoryRepositoryMockDelete) Times(n uint64) *mSubcategoryRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of SubcategoryRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mSubcategoryRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_repository.SubcategoryRepository
func (mmDelete *SubcategoryRepositoryMock) Delete(ctx context.Context, id int) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := SubcategoryRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := SubcategoryRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("SubcategoryRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("SubcategoryRepositoryMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("SubcategoryRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the SubcategoryRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to SubcategoryRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished SubcategoryRepositoryMock.Delete invocations
func (mmDelete *SubcategoryRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of SubcategoryRepositoryMock.Delete invocations
func (mmDelete *SubcategoryRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to SubcategoryRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mSubcategoryRepositoryMockDelete) Calls() []*SubcategoryRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*SubcategoryRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *SubcategoryRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *SubcategoryRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubcategoryRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SubcategoryRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SubcategoryRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to SubcategoryRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to SubcategoryRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mSubcategoryRepositoryMockGet struct {
	optional           bool
	mock               *SubcategoryRepositoryMock
	defaultExpectation *SubcategoryRepositoryMockGetExpectation
	expectations       []*SubcategoryRepositoryMockGetExpectation

	callArgs []*SubcategoryRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SubcategoryRepositoryMockGetExpectation specifies expectation struct of the SubcategoryRepository.Get
type SubcategoryRepositoryMockGetExpectation struct {
	mock               *SubcategoryRepositoryMock
	params             *SubcategoryRepositoryMockGetParams
	paramPtrs          *SubcategoryRepositoryMockGetParamPtrs
	expectationOrigins SubcategoryRepositoryMockGetExpectationOrigins
	results            *SubcategoryRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// SubcategoryRepositoryMockGetParams contains parameters of the SubcategoryRepository.Get
type SubcategoryRepositoryMockGetParams struct {
	ctx context.Context
	id  int
}

// SubcategoryRepositoryMockGetParamPtrs contains pointers to parameters of the SubcategoryRepository.Get
type SubcategoryRepositoryMockGetParamPtrs struct {
	ctx *context.Context
	id  *int
}

// SubcategoryRepositoryMockGetResults contains results of the SubcategoryRepository.Get
type SubcategoryRepositoryMockGetResults struct {
	sp1 *model.Subcategory
	err error
}

// SubcategoryRepositoryMockGetOrigins contains origins of expectations of the SubcategoryRepository.Get
type SubcategoryRepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mSubcategoryRepositoryMockGet) Optional() *mSubcategoryRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for SubcategoryRepository.Get
func (mmGet *mSubcategoryRepositoryMockGet) Expect(ctx context.Context, id int) *mSubcategoryRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("SubcategoryRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &SubcategoryRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("SubcategoryRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &SubcategoryRepositoryMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for SubcategoryRepository.Get
func (mmGet *mSubcategoryRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mSubcategoryRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("SubcategoryRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &SubcategoryRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("SubcategoryRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &SubcategoryRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for SubcategoryRepository.Get
func (mmGet *mSubcategoryRepositoryMockGet) ExpectIdParam2(id int) *mSubcategoryRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("SubcategoryRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &SubcategoryRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("SubcategoryRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &SubcategoryRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the SubcategoryRepository.Get
func (mmGet *mSubcategoryRepositoryMockGet) Inspect(f func(ctx context.Context, id int)) *mSubcategoryRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for SubcategoryRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by SubcategoryRepository.Get
func (mmGet *mSubcategoryRepositoryMockGet) Return(sp1 *model.Subcategory, err error) *SubcategoryRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("SubcategoryRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &SubcategoryRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &SubcategoryRepositoryMockGetResults{sp1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the SubcategoryRepository.Get method
func (mmGet *mSubcategoryRepositoryMockGet) Set(f func(ctx context.Context, id int) (sp1 *model.Subcategory, err error)) *SubcategoryRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the SubcategoryRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the SubcategoryRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the SubcategoryRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mSubcategoryRepositoryMockGet) When(ctx context.Context, id int) *SubcategoryRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("SubcategoryRepositoryMock.Get mock is already set by Set")
	}

	expectation := &SubcategoryRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &SubcategoryRepositoryMockGetParams{ctx, id},
		expectationOrigins: SubcategoryRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up SubcategoryRepository.Get return parameters for the expectation previously defined by the When method
func (e *SubcategoryRepositoryMockGetExpectation) Then(sp1 *model.Subcategory, err error) *SubcategoryRepositoryMock {
	e.results = &SubcategoryRepositoryMockGetResults{sp1, err}
	return e.mock
}

// Times sets number of times SubcategoryRepository.Get should be invoked
func (mmGet *mSubcategoryRepositoryMockGet) Times(n uint64) *mSubcategoryRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of SubcategoryRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mSubcategoryRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.SubcategoryRepository
func (mmGet *SubcategoryRepositoryMock) Get(ctx context.Context, id int) (sp1 *model.Subcategory, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := SubcategoryRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := SubcategoryRepositoryMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("SubcategoryRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("SubcategoryRepositoryMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("SubcategoryRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the SubcategoryRepositoryMock.Get")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to SubcategoryRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished SubcategoryRepositoryMock.Get invocations
func (mmGet *SubcategoryRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of SubcategoryRepositoryMock.Get invocations
func (mmGet *SubcategoryRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to SubcategoryRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mSubcategoryRepositoryMockGet) Calls() []*SubcategoryRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*SubcategoryRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *SubcategoryRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *SubcategoryRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubcategoryRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SubcategoryRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SubcategoryRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to SubcategoryRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to SubcategoryRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mSubcategoryRepositoryMockUpdate struct {
	optional           bool
	mock               *SubcategoryRepositoryMock
	defaultExpectation *SubcategoryRepositoryMockUpdateExpectation
	expectations       []*SubcategoryRepositoryMockUpdateExpectation

	callArgs []*SubcategoryRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SubcategoryRepositoryMockUpdateExpectation specifies expectation struct of the SubcategoryRepository.Update
type SubcategoryRepositoryMockUpdateExpectation struct {
	mock               *SubcategoryRepositoryMock
	params             *SubcategoryRepositoryMockUpdateParams
	paramPtrs          *SubcategoryRepositoryMockUpdateParamPtrs
	expectationOrigins SubcategoryRepositoryMockUpdateExpectationOrigins
	results            *SubcategoryRepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// SubcategoryRepositoryMockUpdateParams contains parameters of the SubcategoryRepository.Update
type SubcategoryRepositoryMockUpdateParams struct {
	ctx                context.Context
	id                 int
	updatedSubcategory *model.UpdatedSubcategory
}

// SubcategoryRepositoryMockUpdateParamPtrs contains pointers to parameters of the SubcategoryRepository.Update
type SubcategoryRepositoryMockUpdateParamPtrs struct {
	ctx                *context.Context
	id                 *int
	updatedSubcategory **model.UpdatedSubcategory
}

// SubcategoryRepositoryMockUpdateResults contains results of the SubcategoryRepository.Update
type SubcategoryRepositoryMockUpdateResults struct {
	err error
}

// SubcategoryRepositoryMockUpdateOrigins contains origins of expectations of the SubcategoryRepository.Update
type SubcategoryRepositoryMockUpdateExpectationOrigins struct {
	origin                   string
	originCtx                string
	originId                 string
	originUpdatedSubcategory string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mSubcategoryRepositoryMockUpdate) Optional() *mSubcategoryRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for SubcategoryRepository.Update
func (mmUpdate *mSubcategoryRepositoryMockUpdate) Expect(ctx context.Context, id int, updatedSubcategory *model.UpdatedSubcategory) *mSubcategoryRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("SubcategoryRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &SubcategoryRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("SubcategoryRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &SubcategoryRepositoryMockUpdateParams{ctx, id, updatedSubcategory}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for SubcategoryRepository.Update
func (mmUpdate *mSubcategoryRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mSubcategoryRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("SubcategoryRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &SubcategoryRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("SubcategoryRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &SubcategoryRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectIdParam2 sets up expected param id for SubcategoryRepository.Update
func (mmUpdate *mSubcategoryRepositoryMockUpdate) ExpectIdParam2(id int) *mSubcategoryRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("SubcategoryRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &SubcategoryRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("SubcategoryRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &SubcategoryRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.id = &id
	mmUpdate.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectUpdatedSubcategoryParam3 sets up expected param updatedSubcategory for SubcategoryRepository.Update
func (mmUpdate *mSubcategoryRepositoryMockUpdate) ExpectUpdatedSubcategoryParam3(updatedSubcategory *model.UpdatedSubcategory) *mSubcategoryRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("SubcategoryRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &SubcategoryRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("SubcategoryRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &SubcategoryRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.updatedSubcategory = &updatedSubcategory
	mmUpdate.defaultExpectation.expectationOrigins.originUpdatedSubcategory = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the SubcategoryRepository.Update
func (mmUpdate *mSubcategoryRepositoryMockUpdate) Inspect(f func(ctx context.Context, id int, updatedSubcategory *model.UpdatedSubcategory)) *mSubcategoryRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for SubcategoryRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by SubcategoryRepository.Update
func (mmUpdate *mSubcategoryRepositoryMockUpdate) Return(err error) *SubcategoryRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("SubcategoryRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &SubcategoryRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &SubcategoryRepositoryMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the SubcategoryRepository.Update method
func (mmUpdate *mSubcategoryRepositoryMockUpdate) Set(f func(ctx context.Context, id int, updatedSubcategory *model.UpdatedSubcategory) (err error)) *SubcategoryRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the SubcategoryRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the SubcategoryRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the SubcategoryRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mSubcategoryRepositoryMockUpdate) When(ctx context.Context, id int, updatedSubcategory *model.UpdatedSubcategory) *SubcategoryRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("SubcategoryRepositoryMock.Update mock is already set by Set")
	}

	expectation := &SubcategoryRepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &SubcategoryRepositoryMockUpdateParams{ctx, id, updatedSubcategory},
		expectationOrigins: SubcategoryRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up SubcategoryRepository.Update return parameters for the expectation previously defined by the When method
func (e *SubcategoryRepositoryMockUpdateExpectation) Then(err error) *SubcategoryRepositoryMock {
	e.results = &SubcategoryRepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times SubcategoryRepository.Update should be invoked
func (mmUpdate *mSubcategoryRepositoryMockUpdate) Times(n uint64) *mSubcategoryRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of SubcategoryRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mSubcategoryRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_repository.SubcategoryRepository
func (mmUpdate *SubcategoryRepositoryMock) Update(ctx context.Context, id int, updatedSubcategory *model.UpdatedSubcategory) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, id, updatedSubcategory)
	}

	mm_params := SubcategoryRepositoryMockUpdateParams{ctx, id, updatedSubcategory}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := SubcategoryRepositoryMockUpdateParams{ctx, id, updatedSubcategory}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("SubcategoryRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdate.t.Errorf("SubcategoryRepositoryMock.Update got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.updatedSubcategory != nil && !minimock.Equal(*mm_want_ptrs.updatedSubcategory, mm_got.updatedSubcategory) {
				mmUpdate.t.Errorf("SubcategoryRepositoryMock.Update got unexpected parameter updatedSubcategory, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originUpdatedSubcategory, *mm_want_ptrs.updatedSubcategory, mm_got.updatedSubcategory, minimock.Diff(*mm_want_ptrs.updatedSubcategory, mm_got.updatedSubcategory))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("SubcategoryRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the SubcategoryRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, id, updatedSubcategory)
	}
	mmUpdate.t.Fatalf("Unexpected call to SubcategoryRepositoryMock.Update. %v %v %v", ctx, id, updatedSubcategory)
	return
}

// UpdateAfterCounter returns a count of finished SubcategoryRepositoryMock.Update invocations
func (mmUpdate *SubcategoryRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of SubcategoryRepositoryMock.Update invocations
func (mmUpdate *SubcategoryRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to SubcategoryRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mSubcategoryRepositoryMockUpdate) Calls() []*SubcategoryRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*SubcategoryRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *SubcategoryRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *SubcategoryRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubcategoryRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SubcategoryRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SubcategoryRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to SubcategoryRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to SubcategoryRepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SubcategoryRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SubcategoryRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SubcategoryRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockUpdateDone()
}
