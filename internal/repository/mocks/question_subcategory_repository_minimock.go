// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Kosfedev/learn_go/internal/repository.QuestionSubcategoryRepository -o question_subcategory_repository_minimock.go -n QuestionSubcategoryRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// QuestionSubcategoryRepositoryMock implements mm_repository.QuestionSubcategoryRepository
type QuestionSubcategoryRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddSubcategoriesToQuestion          func(ctx context.Context, questionID int, subcategoryIDs []int) (err error)
	funcAddSubcategoriesToQuestionOrigin    string
	inspectFuncAddSubcategoriesToQuestion   func(ctx context.Context, questionID int, subcategoryIDs []int)
	afterAddSubcategoriesToQuestionCounter  uint64
	beforeAddSubcategoriesToQuestionCounter uint64
	AddSubcategoriesToQuestionMock          mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion

	funcListSubcategoriesByQuestionID          func(ctx context.Context, questionID int) (ia1 []int, err error)
	funcListSubcategoriesByQuestionIDOrigin    string
	inspectFuncListSubcategoriesByQuestionID   func(ctx context.Context, questionID int)
	afterListSubcategoriesByQuestionIDCounter  uint64
	beforeListSubcategoriesByQuestionIDCounter uint64
	ListSubcategoriesByQuestionIDMock          mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID

	funcRemoveSubcategoriesFromQuestion          func(ctx context.Context, questionID int, subcategoryIDs []int) (err error)
	funcRemoveSubcategoriesFromQuestionOrigin    string
	inspectFuncRemoveSubcategoriesFromQuestion   func(ctx context.Context, questionID int, subcategoryIDs []int)
	afterRemoveSubcategoriesFromQuestionCounter  uint64
	beforeRemoveSubcategoriesFromQuestionCounter uint64
	RemoveSubcategoriesFromQuestionMock          mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion
}

// NewQuestionSubcategoryRepositoryMock returns a mock for mm_repository.QuestionSubcategoryRepository
func NewQuestionSubcategoryRepositoryMock(t minimock.Tester) *QuestionSubcategoryRepositoryMock {
	m := &QuestionSubcategoryRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddSubcategoriesToQuestionMock = mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion{mock: m}
	m.AddSubcategoriesToQuestionMock.callArgs = []*QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams{}

	m.ListSubcategoriesByQuestionIDMock = mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID{mock: m}
	m.ListSubcategoriesByQuestionIDMock.callArgs = []*QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDParams{}

	m.RemoveSubcategoriesFromQuestionMock = mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion{mock: m}
	m.RemoveSubcategoriesFromQuestionMock.callArgs = []*QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion struct {
	optional           bool
	mock               *QuestionSubcategoryRepositoryMock
	defaultExpectation *QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation
	expectations       []*QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation

	callArgs []*QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation specifies expectation struct of the QuestionSubcategoryRepository.AddSubcategoriesToQuestion
type QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation struct {
	mock               *QuestionSubcategoryRepositoryMock
	params             *QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams
	paramPtrs          *QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParamPtrs
	expectationOrigins QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectationOrigins
	results            *QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams contains parameters of the QuestionSubcategoryRepository.AddSubcategoriesToQuestion
type QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams struct {
	ctx            context.Context
	questionID     int
	subcategoryIDs []int
}

// QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParamPtrs contains pointers to parameters of the QuestionSubcategoryRepository.AddSubcategoriesToQuestion
type QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParamPtrs struct {
	ctx            *context.Context
	questionID     *int
	subcategoryIDs *[]int
}

// QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionResults contains results of the QuestionSubcategoryRepository.AddSubcategoriesToQuestion
type QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionResults struct {
	err error
}

// QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionOrigins contains origins of expectations of the QuestionSubcategoryRepository.AddSubcategoriesToQuestion
type QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectationOrigins struct {
	origin               string
	originCtx            string
	originQuestionID     string
	originSubcategoryIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Optional() *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	mmAddSubcategoriesToQuestion.optional = true
	return mmAddSubcategoriesToQuestion
}

// Expect sets up expected params for QuestionSubcategoryRepository.AddSubcategoriesToQuestion
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Expect(ctx context.Context, questionID int, subcategoryIDs []int) *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	if mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Set")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation{}
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by ExpectParams functions")
	}

	mmAddSubcategoriesToQuestion.defaultExpectation.params = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams{ctx, questionID, subcategoryIDs}
	mmAddSubcategoriesToQuestion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddSubcategoriesToQuestion.expectations {
		if minimock.Equal(e.params, mmAddSubcategoriesToQuestion.defaultExpectation.params) {
			mmAddSubcategoriesToQuestion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddSubcategoriesToQuestion.defaultExpectation.params)
		}
	}

	return mmAddSubcategoriesToQuestion
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSubcategoryRepository.AddSubcategoriesToQuestion
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) ExpectCtxParam1(ctx context.Context) *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	if mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Set")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation{}
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.params != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Expect")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParamPtrs{}
	}
	mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddSubcategoriesToQuestion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddSubcategoriesToQuestion
}

// ExpectQuestionIDParam2 sets up expected param questionID for QuestionSubcategoryRepository.AddSubcategoriesToQuestion
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) ExpectQuestionIDParam2(questionID int) *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	if mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Set")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation{}
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.params != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Expect")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParamPtrs{}
	}
	mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs.questionID = &questionID
	mmAddSubcategoriesToQuestion.defaultExpectation.expectationOrigins.originQuestionID = minimock.CallerInfo(1)

	return mmAddSubcategoriesToQuestion
}

// ExpectSubcategoryIDsParam3 sets up expected param subcategoryIDs for QuestionSubcategoryRepository.AddSubcategoriesToQuestion
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) ExpectSubcategoryIDsParam3(subcategoryIDs []int) *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	if mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Set")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation{}
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.params != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Expect")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParamPtrs{}
	}
	mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs.subcategoryIDs = &subcategoryIDs
	mmAddSubcategoriesToQuestion.defaultExpectation.expectationOrigins.originSubcategoryIDs = minimock.CallerInfo(1)

	return mmAddSubcategoriesToQuestion
}

// Inspect accepts an inspector function that has same arguments as the QuestionSubcategoryRepository.AddSubcategoriesToQuestion
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Inspect(f func(ctx context.Context, questionID int, subcategoryIDs []int)) *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	if mmAddSubcategoriesToQuestion.mock.inspectFuncAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("Inspect function is already set for QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion")
	}

	mmAddSubcategoriesToQuestion.mock.inspectFuncAddSubcategoriesToQuestion = f

	return mmAddSubcategoriesToQuestion
}

// Return sets up results that will be returned by QuestionSubcategoryRepository.AddSubcategoriesToQuestion
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Return(err error) *QuestionSubcategoryRepositoryMock {
	if mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Set")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation{mock: mmAddSubcategoriesToQuestion.mock}
	}
	mmAddSubcategoriesToQuestion.defaultExpectation.results = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionResults{err}
	mmAddSubcategoriesToQuestion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddSubcategoriesToQuestion.mock
}

// Set uses given function f to mock the QuestionSubcategoryRepository.AddSubcategoriesToQuestion method
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Set(f func(ctx context.Context, questionID int, subcategoryIDs []int) (err error)) *QuestionSubcategoryRepositoryMock {
	if mmAddSubcategoriesToQuestion.defaultExpectation != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("Default expectation is already set for the QuestionSubcategoryRepository.AddSubcategoriesToQuestion method")
	}

	if len(mmAddSubcategoriesToQuestion.expectations) > 0 {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("Some expectations are already set for the QuestionSubcategoryRepository.AddSubcategoriesToQuestion method")
	}

	mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion = f
	mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestionOrigin = minimock.CallerInfo(1)
	return mmAddSubcategoriesToQuestion.mock
}

// When sets expectation for the QuestionSubcategoryRepository.AddSubcategoriesToQuestion which will trigger the result defined by the following
// Then helper
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) When(ctx context.Context, questionID int, subcategoryIDs []int) *QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation {
	if mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Set")
	}

	expectation := &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation{
		mock:               mmAddSubcategoriesToQuestion.mock,
		params:             &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams{ctx, questionID, subcategoryIDs},
		expectationOrigins: QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddSubcategoriesToQuestion.expectations = append(mmAddSubcategoriesToQuestion.expectations, expectation)
	return expectation
}

// Then sets up QuestionSubcategoryRepository.AddSubcategoriesToQuestion return parameters for the expectation previously defined by the When method
func (e *QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation) Then(err error) *QuestionSubcategoryRepositoryMock {
	e.results = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionResults{err}
	return e.mock
}

// Times sets number of times QuestionSubcategoryRepository.AddSubcategoriesToQuestion should be invoked
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Times(n uint64) *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	if n == 0 {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("Times of QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddSubcategoriesToQuestion.expectedInvocations, n)
	mmAddSubcategoriesToQuestion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddSubcategoriesToQuestion
}

func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) invocationsDone() bool {
	if len(mmAddSubcategoriesToQuestion.expectations) == 0 && mmAddSubcategoriesToQuestion.defaultExpectation == nil && mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddSubcategoriesToQuestion.mock.afterAddSubcategoriesToQuestionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddSubcategoriesToQuestion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddSubcategoriesToQuestion implements mm_repository.QuestionSubcategoryRepository
func (mmAddSubcategoriesToQuestion *QuestionSubcategoryRepositoryMock) AddSubcategoriesToQuestion(ctx context.Context, questionID int, subcategoryIDs []int) (err error) {
	mm_atomic.AddUint64(&mmAddSubcategoriesToQuestion.beforeAddSubcategoriesToQuestionCounter, 1)
	defer mm_atomic.AddUint64(&mmAddSubcategoriesToQuestion.afterAddSubcategoriesToQuestionCounter, 1)

	mmAddSubcategoriesToQuestion.t.Helper()

	if mmAddSubcategoriesToQuestion.inspectFuncAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.inspectFuncAddSubcategoriesToQuestion(ctx, questionID, subcategoryIDs)
	}

	mm_params := QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams{ctx, questionID, subcategoryIDs}

	// Record call args
	mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.mutex.Lock()
	mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.callArgs = append(mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.callArgs, &mm_params)
	mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.mutex.Unlock()

	for _, e := range mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.Counter, 1)
		mm_want := mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.params
		mm_want_ptrs := mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.paramPtrs

		mm_got := QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams{ctx, questionID, subcategoryIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddSubcategoriesToQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.questionID != nil && !minimock.Equal(*mm_want_ptrs.questionID, mm_got.questionID) {
				mmAddSubcategoriesToQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion got unexpected parameter questionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.expectationOrigins.originQuestionID, *mm_want_ptrs.questionID, mm_got.questionID, minimock.Diff(*mm_want_ptrs.questionID, mm_got.questionID))
			}

			if mm_want_ptrs.subcategoryIDs != nil && !minimock.Equal(*mm_want_ptrs.subcategoryIDs, mm_got.subcategoryIDs) {
				mmAddSubcategoriesToQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion got unexpected parameter subcategoryIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.expectationOrigins.originSubcategoryIDs, *mm_want_ptrs.subcategoryIDs, mm_got.subcategoryIDs, minimock.Diff(*mm_want_ptrs.subcategoryIDs, mm_got.subcategoryIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddSubcategoriesToQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.results
		if mm_results == nil {
			mmAddSubcategoriesToQuestion.t.Fatal("No results are set for the QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion")
		}
		return (*mm_results).err
	}
	if mmAddSubcategoriesToQuestion.funcAddSubcategoriesToQuestion != nil {
		return mmAddSubcategoriesToQuestion.funcAddSubcategoriesToQuestion(ctx, questionID, subcategoryIDs)
	}
	mmAddSubcategoriesToQuestion.t.Fatalf("Unexpected call to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion. %v %v %v", ctx, questionID, subcategoryIDs)
	return
}

// AddSubcategoriesToQuestionAfterCounter returns a count of finished QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion invocations
func (mmAddSubcategoriesToQuestion *QuestionSubcategoryRepositoryMock) AddSubcategoriesToQuestionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSubcategoriesToQuestion.afterAddSubcategoriesToQuestionCounter)
}

// AddSubcategoriesToQuestionBeforeCounter returns a count of QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion invocations
func (mmAddSubcategoriesToQuestion *QuestionSubcategoryRepositoryMock) AddSubcategoriesToQuestionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSubcategoriesToQuestion.beforeAddSubcategoriesToQuestionCounter)
}

// Calls returns a list of arguments used in each call to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Calls() []*QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams {
	mmAddSubcategoriesToQuestion.mutex.RLock()

	argCopy := make([]*QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams, len(mmAddSubcategoriesToQuestion.callArgs))
	copy(argCopy, mmAddSubcategoriesToQuestion.callArgs)

	mmAddSubcategoriesToQuestion.mutex.RUnlock()

	return argCopy
}

// MinimockAddSubcategoriesToQuestionDone returns true if the count of the AddSubcategoriesToQuestion invocations corresponds
// the number of defined expectations
func (m *QuestionSubcategoryRepositoryMock) MinimockAddSubcategoriesToQuestionDone() bool {
	if m.AddSubcategoriesToQuestionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddSubcategoriesToQuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddSubcategoriesToQuestionMock.invocationsDone()
}

// MinimockAddSubcategoriesToQuestionInspect logs each unmet expectation
func (m *QuestionSubcategoryRepositoryMock) MinimockAddSubcategoriesToQuestionInspect() {
	for _, e := range m.AddSubcategoriesToQuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddSubcategoriesToQuestionCounter := mm_atomic.LoadUint64(&m.afterAddSubcategoriesToQuestionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddSubcategoriesToQuestionMock.defaultExpectation != nil && afterAddSubcategoriesToQuestionCounter < 1 {
		if m.AddSubcategoriesToQuestionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion at\n%s", m.AddSubcategoriesToQuestionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion at\n%s with params: %#v", m.AddSubcategoriesToQuestionMock.defaultExpectation.expectationOrigins.origin, *m.AddSubcategoriesToQuestionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddSubcategoriesToQuestion != nil && afterAddSubcategoriesToQuestionCounter < 1 {
		m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion at\n%s", m.funcAddSubcategoriesToQuestionOrigin)
	}

	if !m.AddSubcategoriesToQuestionMock.invocationsDone() && afterAddSubcategoriesToQuestionCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddSubcategoriesToQuestionMock.expectedInvocations), m.AddSubcategoriesToQuestionMock.expectedInvocationsOrigin, afterAddSubcategoriesToQuestionCounter)
	}
}

type mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID struct {
	optional           bool
	mock               *QuestionSubcategoryRepositoryMock
	defaultExpectation *QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDExpectation
	expectations       []*QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDExpectation

	callArgs []*QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDExpectation specifies expectation struct of the QuestionSubcategoryRepository.ListSubcategoriesByQuestionID
type QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDExpectation struct {
	mock               *QuestionSubcategoryRepositoryMock
	params             *QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDParams
	paramPtrs          *QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDParamPtrs
	expectationOrigins QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDExpectationOrigins
	results            *QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDParams contains parameters of the QuestionSubcategoryRepository.ListSubcategoriesByQuestionID
type QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDParams struct {
	ctx        context.Context
	questionID int
}

// QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDParamPtrs contains pointers to parameters of the QuestionSubcategoryRepository.ListSubcategoriesByQuestionID
type QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDParamPtrs struct {
	ctx        *context.Context
	questionID *int
}

// QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDResults contains results of the QuestionSubcategoryRepository.ListSubcategoriesByQuestionID
type QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDResults struct {
	ia1 []int
	err error
}

// QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDOrigins contains origins of expectations of the QuestionSubcategoryRepository.ListSubcategoriesByQuestionID
type QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDExpectationOrigins struct {
	origin           string
	originCtx        string
	originQuestionID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListSubcategoriesByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID) Optional() *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID {
	mmListSubcategoriesByQuestionID.optional = true
	return mmListSubcategoriesByQuestionID
}

// Expect sets up expected params for QuestionSubcategoryRepository.ListSubcategoriesByQuestionID
func (mmListSubcategoriesByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID) Expect(ctx context.Context, questionID int) *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID {
	if mmListSubcategoriesByQuestionID.mock.funcListSubcategoriesByQuestionID != nil {
		mmListSubcategoriesByQuestionID.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID mock is already set by Set")
	}

	if mmListSubcategoriesByQuestionID.defaultExpectation == nil {
		mmListSubcategoriesByQuestionID.defaultExpectation = &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDExpectation{}
	}

	if mmListSubcategoriesByQuestionID.defaultExpectation.paramPtrs != nil {
		mmListSubcategoriesByQuestionID.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID mock is already set by ExpectParams functions")
	}

	mmListSubcategoriesByQuestionID.defaultExpectation.params = &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDParams{ctx, questionID}
	mmListSubcategoriesByQuestionID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListSubcategoriesByQuestionID.expectations {
		if minimock.Equal(e.params, mmListSubcategoriesByQuestionID.defaultExpectation.params) {
			mmListSubcategoriesByQuestionID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListSubcategoriesByQuestionID.defaultExpectation.params)
		}
	}

	return mmListSubcategoriesByQuestionID
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSubcategoryRepository.ListSubcategoriesByQuestionID
func (mmListSubcategoriesByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID) ExpectCtxParam1(ctx context.Context) *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID {
	if mmListSubcategoriesByQuestionID.mock.funcListSubcategoriesByQuestionID != nil {
		mmListSubcategoriesByQuestionID.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID mock is already set by Set")
	}

	if mmListSubcategoriesByQuestionID.defaultExpectation == nil {
		mmListSubcategoriesByQuestionID.defaultExpectation = &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDExpectation{}
	}

	if mmListSubcategoriesByQuestionID.defaultExpectation.params != nil {
		mmListSubcategoriesByQuestionID.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID mock is already set by Expect")
	}

	if mmListSubcategoriesByQuestionID.defaultExpectation.paramPtrs == nil {
		mmListSubcategoriesByQuestionID.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDParamPtrs{}
	}
	mmListSubcategoriesByQuestionID.defaultExpectation.paramPtrs.ctx = &ctx
	mmListSubcategoriesByQuestionID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListSubcategoriesByQuestionID
}

// ExpectQuestionIDParam2 sets up expected param questionID for QuestionSubcategoryRepository.ListSubcategoriesByQuestionID
func (mmListSubcategoriesByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID) ExpectQuestionIDParam2(questionID int) *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID {
	if mmListSubcategoriesByQuestionID.mock.funcListSubcategoriesByQuestionID != nil {
		mmListSubcategoriesByQuestionID.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID mock is already set by Set")
	}

	if mmListSubcategoriesByQuestionID.defaultExpectation == nil {
		mmListSubcategoriesByQuestionID.defaultExpectation = &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDExpectation{}
	}

	if mmListSubcategoriesByQuestionID.defaultExpectation.params != nil {
		mmListSubcategoriesByQuestionID.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID mock is already set by Expect")
	}

	if mmListSubcategoriesByQuestionID.defaultExpectation.paramPtrs == nil {
		mmListSubcategoriesByQuestionID.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDParamPtrs{}
	}
	mmListSubcategoriesByQuestionID.defaultExpectation.paramPtrs.questionID = &questionID
	mmListSubcategoriesByQuestionID.defaultExpectation.expectationOrigins.originQuestionID = minimock.CallerInfo(1)

	return mmListSubcategoriesByQuestionID
}

// Inspect accepts an inspector function that has same arguments as the QuestionSubcategoryRepository.ListSubcategoriesByQuestionID
func (mmListSubcategoriesByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID) Inspect(f func(ctx context.Context, questionID int)) *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID {
	if mmListSubcategoriesByQuestionID.mock.inspectFuncListSubcategoriesByQuestionID != nil {
		mmListSubcategoriesByQuestionID.mock.t.Fatalf("Inspect function is already set for QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID")
	}

	mmListSubcategoriesByQuestionID.mock.inspectFuncListSubcategoriesByQuestionID = f

	return mmListSubcategoriesByQuestionID
}

// Return sets up results that will be returned by QuestionSubcategoryRepository.ListSubcategoriesByQuestionID
func (mmListSubcategoriesByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID) Return(ia1 []int, err error) *QuestionSubcategoryRepositoryMock {
	if mmListSubcategoriesByQuestionID.mock.funcListSubcategoriesByQuestionID != nil {
		mmListSubcategoriesByQuestionID.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID mock is already set by Set")
	}

	if mmListSubcategoriesByQuestionID.defaultExpectation == nil {
		mmListSubcategoriesByQuestionID.defaultExpectation = &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDExpectation{mock: mmListSubcategoriesByQuestionID.mock}
	}
	mmListSubcategoriesByQuestionID.defaultExpectation.results = &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDResults{ia1, err}
	mmListSubcategoriesByQuestionID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListSubcategoriesByQuestionID.mock
}

// Set uses given function f to mock the QuestionSubcategoryRepository.ListSubcategoriesByQuestionID method
func (mmListSubcategoriesByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID) Set(f func(ctx context.Context, questionID int) (ia1 []int, err error)) *QuestionSubcategoryRepositoryMock {
	if mmListSubcategoriesByQuestionID.defaultExpectation != nil {
		mmListSubcategoriesByQuestionID.mock.t.Fatalf("Default expectation is already set for the QuestionSubcategoryRepository.ListSubcategoriesByQuestionID method")
	}

	if len(mmListSubcategoriesByQuestionID.expectations) > 0 {
		mmListSubcategoriesByQuestionID.mock.t.Fatalf("Some expectations are already set for the QuestionSubcategoryRepository.ListSubcategoriesByQuestionID method")
	}

	mmListSubcategoriesByQuestionID.mock.funcListSubcategoriesByQuestionID = f
	mmListSubcategoriesByQuestionID.mock.funcListSubcategoriesByQuestionIDOrigin = minimock.CallerInfo(1)
	return mmListSubcategoriesByQuestionID.mock
}

// When sets expectation for the QuestionSubcategoryRepository.ListSubcategoriesByQuestionID which will trigger the result defined by the following
// Then helper
func (mmListSubcategoriesByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID) When(ctx context.Context, questionID int) *QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDExpectation {
	if mmListSubcategoriesByQuestionID.mock.funcListSubcategoriesByQuestionID != nil {
		mmListSubcategoriesByQuestionID.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID mock is already set by Set")
	}

	expectation := &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDExpectation{
		mock:               mmListSubcategoriesByQuestionID.mock,
		params:             &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDParams{ctx, questionID},
		expectationOrigins: QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListSubcategoriesByQuestionID.expectations = append(mmListSubcategoriesByQuestionID.expectations, expectation)
	return expectation
}

// Then sets up QuestionSubcategoryRepository.ListSubcategoriesByQuestionID return parameters for the expectation previously defined by the When method
func (e *QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDExpectation) Then(ia1 []int, err error) *QuestionSubcategoryRepositoryMock {
	e.results = &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDResults{ia1, err}
	return e.mock
}

// Times sets number of times QuestionSubcategoryRepository.ListSubcategoriesByQuestionID should be invoked
func (mmListSubcategoriesByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID) Times(n uint64) *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID {
	if n == 0 {
		mmListSubcategoriesByQuestionID.mock.t.Fatalf("Times of QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListSubcategoriesByQuestionID.expectedInvocations, n)
	mmListSubcategoriesByQuestionID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListSubcategoriesByQuestionID
}

func (mmListSubcategoriesByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID) invocationsDone() bool {
	if len(mmListSubcategoriesByQuestionID.expectations) == 0 && mmListSubcategoriesByQuestionID.defaultExpectation == nil && mmListSubcategoriesByQuestionID.mock.funcListSubcategoriesByQuestionID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListSubcategoriesByQuestionID.mock.afterListSubcategoriesByQuestionIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListSubcategoriesByQuestionID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListSubcategoriesByQuestionID implements mm_repository.QuestionSubcategoryRepository
func (mmListSubcategoriesByQuestionID *QuestionSubcategoryRepositoryMock) ListSubcategoriesByQuestionID(ctx context.Context, questionID int) (ia1 []int, err error) {
	mm_atomic.AddUint64(&mmListSubcategoriesByQuestionID.beforeListSubcategoriesByQuestionIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListSubcategoriesByQuestionID.afterListSubcategoriesByQuestionIDCounter, 1)

	mmListSubcategoriesByQuestionID.t.Helper()

	if mmListSubcategoriesByQuestionID.inspectFuncListSubcategoriesByQuestionID != nil {
		mmListSubcategoriesByQuestionID.inspectFuncListSubcategoriesByQuestionID(ctx, questionID)
	}

	mm_params := QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDParams{ctx, questionID}

	// Record call args
	mmListSubcategoriesByQuestionID.ListSubcategoriesByQuestionIDMock.mutex.Lock()
	mmListSubcategoriesByQuestionID.ListSubcategoriesByQuestionIDMock.callArgs = append(mmListSubcategoriesByQuestionID.ListSubcategoriesByQuestionIDMock.callArgs, &mm_params)
	mmListSubcategoriesByQuestionID.ListSubcategoriesByQuestionIDMock.mutex.Unlock()

	for _, e := range mmListSubcategoriesByQuestionID.ListSubcategoriesByQuestionIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmListSubcategoriesByQuestionID.ListSubcategoriesByQuestionIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListSubcategoriesByQuestionID.ListSubcategoriesByQuestionIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListSubcategoriesByQuestionID.ListSubcategoriesByQuestionIDMock.defaultExpectation.params
		mm_want_ptrs := mmListSubcategoriesByQuestionID.ListSubcategoriesByQuestionIDMock.defaultExpectation.paramPtrs

		mm_got := QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDParams{ctx, questionID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListSubcategoriesByQuestionID.t.Errorf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSubcategoriesByQuestionID.ListSubcategoriesByQuestionIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.questionID != nil && !minimock.Equal(*mm_want_ptrs.questionID, mm_got.questionID) {
				mmListSubcategoriesByQuestionID.t.Errorf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID got unexpected parameter questionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSubcategoriesByQuestionID.ListSubcategoriesByQuestionIDMock.defaultExpectation.expectationOrigins.originQuestionID, *mm_want_ptrs.questionID, mm_got.questionID, minimock.Diff(*mm_want_ptrs.questionID, mm_got.questionID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListSubcategoriesByQuestionID.t.Errorf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListSubcategoriesByQuestionID.ListSubcategoriesByQuestionIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListSubcategoriesByQuestionID.ListSubcategoriesByQuestionIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListSubcategoriesByQuestionID.t.Fatal("No results are set for the QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmListSubcategoriesByQuestionID.funcListSubcategoriesByQuestionID != nil {
		return mmListSubcategoriesByQuestionID.funcListSubcategoriesByQuestionID(ctx, questionID)
	}
	mmListSubcategoriesByQuestionID.t.Fatalf("Unexpected call to QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID. %v %v", ctx, questionID)
	return
}

// ListSubcategoriesByQuestionIDAfterCounter returns a count of finished QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID invocations
func (mmListSubcategoriesByQuestionID *QuestionSubcategoryRepositoryMock) ListSubcategoriesByQuestionIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSubcategoriesByQuestionID.afterListSubcategoriesByQuestionIDCounter)
}

// ListSubcategoriesByQuestionIDBeforeCounter returns a count of QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID invocations
func (mmListSubcategoriesByQuestionID *QuestionSubcategoryRepositoryMock) ListSubcategoriesByQuestionIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSubcategoriesByQuestionID.beforeListSubcategoriesByQuestionIDCounter)
}

// Calls returns a list of arguments used in each call to QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListSubcategoriesByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionID) Calls() []*QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDParams {
	mmListSubcategoriesByQuestionID.mutex.RLock()

	argCopy := make([]*QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIDParams, len(mmListSubcategoriesByQuestionID.callArgs))
	copy(argCopy, mmListSubcategoriesByQuestionID.callArgs)

	mmListSubcategoriesByQuestionID.mutex.RUnlock()

	return argCopy
}

// MinimockListSubcategoriesByQuestionIDDone returns true if the count of the ListSubcategoriesByQuestionID invocations corresponds
// the number of defined expectations
func (m *QuestionSubcategoryRepositoryMock) MinimockListSubcategoriesByQuestionIDDone() bool {
	if m.ListSubcategoriesByQuestionIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListSubcategoriesByQuestionIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListSubcategoriesByQuestionIDMock.invocationsDone()
}

// MinimockListSubcategoriesByQuestionIDInspect logs each unmet expectation
func (m *QuestionSubcategoryRepositoryMock) MinimockListSubcategoriesByQuestionIDInspect() {
	for _, e := range m.ListSubcategoriesByQuestionIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListSubcategoriesByQuestionIDCounter := mm_atomic.LoadUint64(&m.afterListSubcategoriesByQuestionIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListSubcategoriesByQuestionIDMock.defaultExpectation != nil && afterListSubcategoriesByQuestionIDCounter < 1 {
		if m.ListSubcategoriesByQuestionIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID at\n%s", m.ListSubcategoriesByQuestionIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID at\n%s with params: %#v", m.ListSubcategoriesByQuestionIDMock.defaultExpectation.expectationOrigins.origin, *m.ListSubcategoriesByQuestionIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSubcategoriesByQuestionID != nil && afterListSubcategoriesByQuestionIDCounter < 1 {
		m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID at\n%s", m.funcListSubcategoriesByQuestionIDOrigin)
	}

	if !m.ListSubcategoriesByQuestionIDMock.invocationsDone() && afterListSubcategoriesByQuestionIDCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListSubcategoriesByQuestionIDMock.expectedInvocations), m.ListSubcategoriesByQuestionIDMock.expectedInvocationsOrigin, afterListSubcategoriesByQuestionIDCounter)
	}
}

type mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion struct {
	optional           bool
	mock               *QuestionSubcategoryRepositoryMock
	defaultExpectation *QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation
	expectations       []*QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation

	callArgs []*QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation specifies expectation struct of the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
type QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation struct {
	mock               *QuestionSubcategoryRepositoryMock
	params             *QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams
	paramPtrs          *QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParamPtrs
	expectationOrigins QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectationOrigins
	results            *QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams contains parameters of the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
type QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams struct {
	ctx            context.Context
	questionID     int
	subcategoryIDs []int
}

// QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParamPtrs contains pointers to parameters of the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
type QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParamPtrs struct {
	ctx            *context.Context
	questionID     *int
	subcategoryIDs *[]int
}

// QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionResults contains results of the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
type QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionResults struct {
	err error
}

// QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionOrigins contains origins of expectations of the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
type QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectationOrigins struct {
	origin               string
	originCtx            string
	originQuestionID     string
	originSubcategoryIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Optional() *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	mmRemoveSubcategoriesFromQuestion.optional = true
	return mmRemoveSubcategoriesFromQuestion
}

// Expect sets up expected params for QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Expect(ctx context.Context, questionID int, subcategoryIDs []int) *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	if mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Set")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation{}
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by ExpectParams functions")
	}

	mmRemoveSubcategoriesFromQuestion.defaultExpectation.params = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams{ctx, questionID, subcategoryIDs}
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveSubcategoriesFromQuestion.expectations {
		if minimock.Equal(e.params, mmRemoveSubcategoriesFromQuestion.defaultExpectation.params) {
			mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveSubcategoriesFromQuestion.defaultExpectation.params)
		}
	}

	return mmRemoveSubcategoriesFromQuestion
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) ExpectCtxParam1(ctx context.Context) *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	if mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Set")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation{}
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.params != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Expect")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParamPtrs{}
	}
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveSubcategoriesFromQuestion
}

// ExpectQuestionIDParam2 sets up expected param questionID for QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) ExpectQuestionIDParam2(questionID int) *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	if mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Set")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation{}
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.params != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Expect")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParamPtrs{}
	}
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs.questionID = &questionID
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.expectationOrigins.originQuestionID = minimock.CallerInfo(1)

	return mmRemoveSubcategoriesFromQuestion
}

// ExpectSubcategoryIDsParam3 sets up expected param subcategoryIDs for QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) ExpectSubcategoryIDsParam3(subcategoryIDs []int) *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	if mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Set")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation{}
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.params != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Expect")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParamPtrs{}
	}
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs.subcategoryIDs = &subcategoryIDs
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.expectationOrigins.originSubcategoryIDs = minimock.CallerInfo(1)

	return mmRemoveSubcategoriesFromQuestion
}

// Inspect accepts an inspector function that has same arguments as the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Inspect(f func(ctx context.Context, questionID int, subcategoryIDs []int)) *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	if mmRemoveSubcategoriesFromQuestion.mock.inspectFuncRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("Inspect function is already set for QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion")
	}

	mmRemoveSubcategoriesFromQuestion.mock.inspectFuncRemoveSubcategoriesFromQuestion = f

	return mmRemoveSubcategoriesFromQuestion
}

// Return sets up results that will be returned by QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Return(err error) *QuestionSubcategoryRepositoryMock {
	if mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Set")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation{mock: mmRemoveSubcategoriesFromQuestion.mock}
	}
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.results = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionResults{err}
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveSubcategoriesFromQuestion.mock
}

// Set uses given function f to mock the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion method
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Set(f func(ctx context.Context, questionID int, subcategoryIDs []int) (err error)) *QuestionSubcategoryRepositoryMock {
	if mmRemoveSubcategoriesFromQuestion.defaultExpectation != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("Default expectation is already set for the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion method")
	}

	if len(mmRemoveSubcategoriesFromQuestion.expectations) > 0 {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("Some expectations are already set for the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion method")
	}

	mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion = f
	mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestionOrigin = minimock.CallerInfo(1)
	return mmRemoveSubcategoriesFromQuestion.mock
}

// When sets expectation for the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion which will trigger the result defined by the following
// Then helper
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) When(ctx context.Context, questionID int, subcategoryIDs []int) *QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation {
	if mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Set")
	}

	expectation := &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation{
		mock:               mmRemoveSubcategoriesFromQuestion.mock,
		params:             &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams{ctx, questionID, subcategoryIDs},
		expectationOrigins: QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveSubcategoriesFromQuestion.expectations = append(mmRemoveSubcategoriesFromQuestion.expectations, expectation)
	return expectation
}

// Then sets up QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion return parameters for the expectation previously defined by the When method
func (e *QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation) Then(err error) *QuestionSubcategoryRepositoryMock {
	e.results = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionResults{err}
	return e.mock
}

// Times sets number of times QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion should be invoked
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Times(n uint64) *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	if n == 0 {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("Times of QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveSubcategoriesFromQuestion.expectedInvocations, n)
	mmRemoveSubcategoriesFromQuestion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveSubcategoriesFromQuestion
}

func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) invocationsDone() bool {
	if len(mmRemoveSubcategoriesFromQuestion.expectations) == 0 && mmRemoveSubcategoriesFromQuestion.defaultExpectation == nil && mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveSubcategoriesFromQuestion.mock.afterRemoveSubcategoriesFromQuestionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveSubcategoriesFromQuestion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveSubcategoriesFromQuestion implements mm_repository.QuestionSubcategoryRepository
func (mmRemoveSubcategoriesFromQuestion *QuestionSubcategoryRepositoryMock) RemoveSubcategoriesFromQuestion(ctx context.Context, questionID int, subcategoryIDs []int) (err error) {
	mm_atomic.AddUint64(&mmRemoveSubcategoriesFromQuestion.beforeRemoveSubcategoriesFromQuestionCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveSubcategoriesFromQuestion.afterRemoveSubcategoriesFromQuestionCounter, 1)

	mmRemoveSubcategoriesFromQuestion.t.Helper()

	if mmRemoveSubcategoriesFromQuestion.inspectFuncRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.inspectFuncRemoveSubcategoriesFromQuestion(ctx, questionID, subcategoryIDs)
	}

	mm_params := QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams{ctx, questionID, subcategoryIDs}

	// Record call args
	mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.mutex.Lock()
	mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.callArgs = append(mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.callArgs, &mm_params)
	mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.mutex.Unlock()

	for _, e := range mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.paramPtrs

		mm_got := QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams{ctx, questionID, subcategoryIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveSubcategoriesFromQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.questionID != nil && !minimock.Equal(*mm_want_ptrs.questionID, mm_got.questionID) {
				mmRemoveSubcategoriesFromQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion got unexpected parameter questionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.expectationOrigins.originQuestionID, *mm_want_ptrs.questionID, mm_got.questionID, minimock.Diff(*mm_want_ptrs.questionID, mm_got.questionID))
			}

			if mm_want_ptrs.subcategoryIDs != nil && !minimock.Equal(*mm_want_ptrs.subcategoryIDs, mm_got.subcategoryIDs) {
				mmRemoveSubcategoriesFromQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion got unexpected parameter subcategoryIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.expectationOrigins.originSubcategoryIDs, *mm_want_ptrs.subcategoryIDs, mm_got.subcategoryIDs, minimock.Diff(*mm_want_ptrs.subcategoryIDs, mm_got.subcategoryIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveSubcategoriesFromQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveSubcategoriesFromQuestion.t.Fatal("No results are set for the QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion")
		}
		return (*mm_results).err
	}
	if mmRemoveSubcategoriesFromQuestion.funcRemoveSubcategoriesFromQuestion != nil {
		return mmRemoveSubcategoriesFromQuestion.funcRemoveSubcategoriesFromQuestion(ctx, questionID, subcategoryIDs)
	}
	mmRemoveSubcategoriesFromQuestion.t.Fatalf("Unexpected call to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion. %v %v %v", ctx, questionID, subcategoryIDs)
	return
}

// RemoveSubcategoriesFromQuestionAfterCounter returns a count of finished QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion invocations
func (mmRemoveSubcategoriesFromQuestion *QuestionSubcategoryRepositoryMock) RemoveSubcategoriesFromQuestionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveSubcategoriesFromQuestion.afterRemoveSubcategoriesFromQuestionCounter)
}

// RemoveSubcategoriesFromQuestionBeforeCounter returns a count of QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion invocations
func (mmRemoveSubcategoriesFromQuestion *QuestionSubcategoryRepositoryMock) RemoveSubcategoriesFromQuestionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveSubcategoriesFromQuestion.beforeRemoveSubcategoriesFromQuestionCounter)
}

// Calls returns a list of arguments used in each call to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Calls() []*QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams {
	mmRemoveSubcategoriesFromQuestion.mutex.RLock()

	argCopy := make([]*QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams, len(mmRemoveSubcategoriesFromQuestion.callArgs))
	copy(argCopy, mmRemoveSubcategoriesFromQuestion.callArgs)

	mmRemoveSubcategoriesFromQuestion.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveSubcategoriesFromQuestionDone returns true if the count of the RemoveSubcategoriesFromQuestion invocations corresponds
// the number of defined expectations
func (m *QuestionSubcategoryRepositoryMock) MinimockRemoveSubcategoriesFromQuestionDone() bool {
	if m.RemoveSubcategoriesFromQuestionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveSubcategoriesFromQuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveSubcategoriesFromQuestionMock.invocationsDone()
}

// MinimockRemoveSubcategoriesFromQuestionInspect logs each unmet expectation
func (m *QuestionSubcategoryRepositoryMock) MinimockRemoveSubcategoriesFromQuestionInspect() {
	for _, e := range m.RemoveSubcategoriesFromQuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveSubcategoriesFromQuestionCounter := mm_atomic.LoadUint64(&m.afterRemoveSubcategoriesFromQuestionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveSubcategoriesFromQuestionMock.defaultExpectation != nil && afterRemoveSubcategoriesFromQuestionCounter < 1 {
		if m.RemoveSubcategoriesFromQuestionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion at\n%s", m.RemoveSubcategoriesFromQuestionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion at\n%s with params: %#v", m.RemoveSubcategoriesFromQuestionMock.defaultExpectation.expectationOrigins.origin, *m.RemoveSubcategoriesFromQuestionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveSubcategoriesFromQuestion != nil && afterRemoveSubcategoriesFromQuestionCounter < 1 {
		m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion at\n%s", m.funcRemoveSubcategoriesFromQuestionOrigin)
	}

	if !m.RemoveSubcategoriesFromQuestionMock.invocationsDone() && afterRemoveSubcategoriesFromQuestionCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveSubcategoriesFromQuestionMock.expectedInvocations), m.RemoveSubcategoriesFromQuestionMock.expectedInvocationsOrigin, afterRemoveSubcategoriesFromQuestionCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *QuestionSubcategoryRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddSubcategoriesToQuestionInspect()

			m.MinimockListSubcategoriesByQuestionIDInspect()

			m.MinimockRemoveSubcategoriesFromQuestionInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *QuestionSubcategoryRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *QuestionSubcategoryRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddSubcategoriesToQuestionDone() &&
		m.MinimockListSubcategoriesByQuestionIDDone() &&
		m.MinimockRemoveSubcategoriesFromQuestionDone()
}
