// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Kosfedev/learn_go/internal/repository.QuestionSubcategoryRepository -o question_subcategory_repository_minimock.go -n QuestionSubcategoryRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// QuestionSubcategoryRepositoryMock implements mm_repository.QuestionSubcategoryRepository
type QuestionSubcategoryRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddSubcategoriesToQuestion          func(ctx context.Context, questionId int, subcategoryIds []int) (err error)
	funcAddSubcategoriesToQuestionOrigin    string
	inspectFuncAddSubcategoriesToQuestion   func(ctx context.Context, questionId int, subcategoryIds []int)
	afterAddSubcategoriesToQuestionCounter  uint64
	beforeAddSubcategoriesToQuestionCounter uint64
	AddSubcategoriesToQuestionMock          mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion

	funcListSubcategoriesByQuestionId          func(ctx context.Context, questionId int) (ia1 []int, err error)
	funcListSubcategoriesByQuestionIdOrigin    string
	inspectFuncListSubcategoriesByQuestionId   func(ctx context.Context, questionId int)
	afterListSubcategoriesByQuestionIdCounter  uint64
	beforeListSubcategoriesByQuestionIdCounter uint64
	ListSubcategoriesByQuestionIdMock          mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId

	funcRemoveSubcategoriesFromQuestion          func(ctx context.Context, questionId int, subcategoryIds []int) (err error)
	funcRemoveSubcategoriesFromQuestionOrigin    string
	inspectFuncRemoveSubcategoriesFromQuestion   func(ctx context.Context, questionId int, subcategoryIds []int)
	afterRemoveSubcategoriesFromQuestionCounter  uint64
	beforeRemoveSubcategoriesFromQuestionCounter uint64
	RemoveSubcategoriesFromQuestionMock          mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion
}

// NewQuestionSubcategoryRepositoryMock returns a mock for mm_repository.QuestionSubcategoryRepository
func NewQuestionSubcategoryRepositoryMock(t minimock.Tester) *QuestionSubcategoryRepositoryMock {
	m := &QuestionSubcategoryRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddSubcategoriesToQuestionMock = mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion{mock: m}
	m.AddSubcategoriesToQuestionMock.callArgs = []*QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams{}

	m.ListSubcategoriesByQuestionIdMock = mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId{mock: m}
	m.ListSubcategoriesByQuestionIdMock.callArgs = []*QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdParams{}

	m.RemoveSubcategoriesFromQuestionMock = mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion{mock: m}
	m.RemoveSubcategoriesFromQuestionMock.callArgs = []*QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion struct {
	optional           bool
	mock               *QuestionSubcategoryRepositoryMock
	defaultExpectation *QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation
	expectations       []*QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation

	callArgs []*QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation specifies expectation struct of the QuestionSubcategoryRepository.AddSubcategoriesToQuestion
type QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation struct {
	mock               *QuestionSubcategoryRepositoryMock
	params             *QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams
	paramPtrs          *QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParamPtrs
	expectationOrigins QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectationOrigins
	results            *QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams contains parameters of the QuestionSubcategoryRepository.AddSubcategoriesToQuestion
type QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams struct {
	ctx            context.Context
	questionId     int
	subcategoryIds []int
}

// QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParamPtrs contains pointers to parameters of the QuestionSubcategoryRepository.AddSubcategoriesToQuestion
type QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParamPtrs struct {
	ctx            *context.Context
	questionId     *int
	subcategoryIds *[]int
}

// QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionResults contains results of the QuestionSubcategoryRepository.AddSubcategoriesToQuestion
type QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionResults struct {
	err error
}

// QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionOrigins contains origins of expectations of the QuestionSubcategoryRepository.AddSubcategoriesToQuestion
type QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectationOrigins struct {
	origin               string
	originCtx            string
	originQuestionId     string
	originSubcategoryIds string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Optional() *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	mmAddSubcategoriesToQuestion.optional = true
	return mmAddSubcategoriesToQuestion
}

// Expect sets up expected params for QuestionSubcategoryRepository.AddSubcategoriesToQuestion
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Expect(ctx context.Context, questionId int, subcategoryIds []int) *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	if mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Set")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation{}
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by ExpectParams functions")
	}

	mmAddSubcategoriesToQuestion.defaultExpectation.params = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams{ctx, questionId, subcategoryIds}
	mmAddSubcategoriesToQuestion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddSubcategoriesToQuestion.expectations {
		if minimock.Equal(e.params, mmAddSubcategoriesToQuestion.defaultExpectation.params) {
			mmAddSubcategoriesToQuestion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddSubcategoriesToQuestion.defaultExpectation.params)
		}
	}

	return mmAddSubcategoriesToQuestion
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSubcategoryRepository.AddSubcategoriesToQuestion
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) ExpectCtxParam1(ctx context.Context) *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	if mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Set")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation{}
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.params != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Expect")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParamPtrs{}
	}
	mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddSubcategoriesToQuestion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddSubcategoriesToQuestion
}

// ExpectQuestionIdParam2 sets up expected param questionId for QuestionSubcategoryRepository.AddSubcategoriesToQuestion
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) ExpectQuestionIdParam2(questionId int) *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	if mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Set")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation{}
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.params != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Expect")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParamPtrs{}
	}
	mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs.questionId = &questionId
	mmAddSubcategoriesToQuestion.defaultExpectation.expectationOrigins.originQuestionId = minimock.CallerInfo(1)

	return mmAddSubcategoriesToQuestion
}

// ExpectSubcategoryIdsParam3 sets up expected param subcategoryIds for QuestionSubcategoryRepository.AddSubcategoriesToQuestion
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) ExpectSubcategoryIdsParam3(subcategoryIds []int) *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	if mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Set")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation{}
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.params != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Expect")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParamPtrs{}
	}
	mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs.subcategoryIds = &subcategoryIds
	mmAddSubcategoriesToQuestion.defaultExpectation.expectationOrigins.originSubcategoryIds = minimock.CallerInfo(1)

	return mmAddSubcategoriesToQuestion
}

// Inspect accepts an inspector function that has same arguments as the QuestionSubcategoryRepository.AddSubcategoriesToQuestion
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Inspect(f func(ctx context.Context, questionId int, subcategoryIds []int)) *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	if mmAddSubcategoriesToQuestion.mock.inspectFuncAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("Inspect function is already set for QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion")
	}

	mmAddSubcategoriesToQuestion.mock.inspectFuncAddSubcategoriesToQuestion = f

	return mmAddSubcategoriesToQuestion
}

// Return sets up results that will be returned by QuestionSubcategoryRepository.AddSubcategoriesToQuestion
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Return(err error) *QuestionSubcategoryRepositoryMock {
	if mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Set")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation{mock: mmAddSubcategoriesToQuestion.mock}
	}
	mmAddSubcategoriesToQuestion.defaultExpectation.results = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionResults{err}
	mmAddSubcategoriesToQuestion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddSubcategoriesToQuestion.mock
}

// Set uses given function f to mock the QuestionSubcategoryRepository.AddSubcategoriesToQuestion method
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Set(f func(ctx context.Context, questionId int, subcategoryIds []int) (err error)) *QuestionSubcategoryRepositoryMock {
	if mmAddSubcategoriesToQuestion.defaultExpectation != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("Default expectation is already set for the QuestionSubcategoryRepository.AddSubcategoriesToQuestion method")
	}

	if len(mmAddSubcategoriesToQuestion.expectations) > 0 {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("Some expectations are already set for the QuestionSubcategoryRepository.AddSubcategoriesToQuestion method")
	}

	mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion = f
	mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestionOrigin = minimock.CallerInfo(1)
	return mmAddSubcategoriesToQuestion.mock
}

// When sets expectation for the QuestionSubcategoryRepository.AddSubcategoriesToQuestion which will trigger the result defined by the following
// Then helper
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) When(ctx context.Context, questionId int, subcategoryIds []int) *QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation {
	if mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Set")
	}

	expectation := &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation{
		mock:               mmAddSubcategoriesToQuestion.mock,
		params:             &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams{ctx, questionId, subcategoryIds},
		expectationOrigins: QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddSubcategoriesToQuestion.expectations = append(mmAddSubcategoriesToQuestion.expectations, expectation)
	return expectation
}

// Then sets up QuestionSubcategoryRepository.AddSubcategoriesToQuestion return parameters for the expectation previously defined by the When method
func (e *QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation) Then(err error) *QuestionSubcategoryRepositoryMock {
	e.results = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionResults{err}
	return e.mock
}

// Times sets number of times QuestionSubcategoryRepository.AddSubcategoriesToQuestion should be invoked
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Times(n uint64) *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	if n == 0 {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("Times of QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddSubcategoriesToQuestion.expectedInvocations, n)
	mmAddSubcategoriesToQuestion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddSubcategoriesToQuestion
}

func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) invocationsDone() bool {
	if len(mmAddSubcategoriesToQuestion.expectations) == 0 && mmAddSubcategoriesToQuestion.defaultExpectation == nil && mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddSubcategoriesToQuestion.mock.afterAddSubcategoriesToQuestionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddSubcategoriesToQuestion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddSubcategoriesToQuestion implements mm_repository.QuestionSubcategoryRepository
func (mmAddSubcategoriesToQuestion *QuestionSubcategoryRepositoryMock) AddSubcategoriesToQuestion(ctx context.Context, questionId int, subcategoryIds []int) (err error) {
	mm_atomic.AddUint64(&mmAddSubcategoriesToQuestion.beforeAddSubcategoriesToQuestionCounter, 1)
	defer mm_atomic.AddUint64(&mmAddSubcategoriesToQuestion.afterAddSubcategoriesToQuestionCounter, 1)

	mmAddSubcategoriesToQuestion.t.Helper()

	if mmAddSubcategoriesToQuestion.inspectFuncAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.inspectFuncAddSubcategoriesToQuestion(ctx, questionId, subcategoryIds)
	}

	mm_params := QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams{ctx, questionId, subcategoryIds}

	// Record call args
	mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.mutex.Lock()
	mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.callArgs = append(mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.callArgs, &mm_params)
	mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.mutex.Unlock()

	for _, e := range mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.Counter, 1)
		mm_want := mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.params
		mm_want_ptrs := mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.paramPtrs

		mm_got := QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams{ctx, questionId, subcategoryIds}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddSubcategoriesToQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.questionId != nil && !minimock.Equal(*mm_want_ptrs.questionId, mm_got.questionId) {
				mmAddSubcategoriesToQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion got unexpected parameter questionId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.expectationOrigins.originQuestionId, *mm_want_ptrs.questionId, mm_got.questionId, minimock.Diff(*mm_want_ptrs.questionId, mm_got.questionId))
			}

			if mm_want_ptrs.subcategoryIds != nil && !minimock.Equal(*mm_want_ptrs.subcategoryIds, mm_got.subcategoryIds) {
				mmAddSubcategoriesToQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion got unexpected parameter subcategoryIds, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.expectationOrigins.originSubcategoryIds, *mm_want_ptrs.subcategoryIds, mm_got.subcategoryIds, minimock.Diff(*mm_want_ptrs.subcategoryIds, mm_got.subcategoryIds))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddSubcategoriesToQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.results
		if mm_results == nil {
			mmAddSubcategoriesToQuestion.t.Fatal("No results are set for the QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion")
		}
		return (*mm_results).err
	}
	if mmAddSubcategoriesToQuestion.funcAddSubcategoriesToQuestion != nil {
		return mmAddSubcategoriesToQuestion.funcAddSubcategoriesToQuestion(ctx, questionId, subcategoryIds)
	}
	mmAddSubcategoriesToQuestion.t.Fatalf("Unexpected call to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion. %v %v %v", ctx, questionId, subcategoryIds)
	return
}

// AddSubcategoriesToQuestionAfterCounter returns a count of finished QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion invocations
func (mmAddSubcategoriesToQuestion *QuestionSubcategoryRepositoryMock) AddSubcategoriesToQuestionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSubcategoriesToQuestion.afterAddSubcategoriesToQuestionCounter)
}

// AddSubcategoriesToQuestionBeforeCounter returns a count of QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion invocations
func (mmAddSubcategoriesToQuestion *QuestionSubcategoryRepositoryMock) AddSubcategoriesToQuestionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSubcategoriesToQuestion.beforeAddSubcategoriesToQuestionCounter)
}

// Calls returns a list of arguments used in each call to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Calls() []*QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams {
	mmAddSubcategoriesToQuestion.mutex.RLock()

	argCopy := make([]*QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams, len(mmAddSubcategoriesToQuestion.callArgs))
	copy(argCopy, mmAddSubcategoriesToQuestion.callArgs)

	mmAddSubcategoriesToQuestion.mutex.RUnlock()

	return argCopy
}

// MinimockAddSubcategoriesToQuestionDone returns true if the count of the AddSubcategoriesToQuestion invocations corresponds
// the number of defined expectations
func (m *QuestionSubcategoryRepositoryMock) MinimockAddSubcategoriesToQuestionDone() bool {
	if m.AddSubcategoriesToQuestionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddSubcategoriesToQuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddSubcategoriesToQuestionMock.invocationsDone()
}

// MinimockAddSubcategoriesToQuestionInspect logs each unmet expectation
func (m *QuestionSubcategoryRepositoryMock) MinimockAddSubcategoriesToQuestionInspect() {
	for _, e := range m.AddSubcategoriesToQuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddSubcategoriesToQuestionCounter := mm_atomic.LoadUint64(&m.afterAddSubcategoriesToQuestionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddSubcategoriesToQuestionMock.defaultExpectation != nil && afterAddSubcategoriesToQuestionCounter < 1 {
		if m.AddSubcategoriesToQuestionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion at\n%s", m.AddSubcategoriesToQuestionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion at\n%s with params: %#v", m.AddSubcategoriesToQuestionMock.defaultExpectation.expectationOrigins.origin, *m.AddSubcategoriesToQuestionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddSubcategoriesToQuestion != nil && afterAddSubcategoriesToQuestionCounter < 1 {
		m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion at\n%s", m.funcAddSubcategoriesToQuestionOrigin)
	}

	if !m.AddSubcategoriesToQuestionMock.invocationsDone() && afterAddSubcategoriesToQuestionCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddSubcategoriesToQuestionMock.expectedInvocations), m.AddSubcategoriesToQuestionMock.expectedInvocationsOrigin, afterAddSubcategoriesToQuestionCounter)
	}
}

type mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId struct {
	optional           bool
	mock               *QuestionSubcategoryRepositoryMock
	defaultExpectation *QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdExpectation
	expectations       []*QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdExpectation

	callArgs []*QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdExpectation specifies expectation struct of the QuestionSubcategoryRepository.ListSubcategoriesByQuestionId
type QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdExpectation struct {
	mock               *QuestionSubcategoryRepositoryMock
	params             *QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdParams
	paramPtrs          *QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdParamPtrs
	expectationOrigins QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdExpectationOrigins
	results            *QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdParams contains parameters of the QuestionSubcategoryRepository.ListSubcategoriesByQuestionId
type QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdParams struct {
	ctx        context.Context
	questionId int
}

// QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdParamPtrs contains pointers to parameters of the QuestionSubcategoryRepository.ListSubcategoriesByQuestionId
type QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdParamPtrs struct {
	ctx        *context.Context
	questionId *int
}

// QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdResults contains results of the QuestionSubcategoryRepository.ListSubcategoriesByQuestionId
type QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdResults struct {
	ia1 []int
	err error
}

// QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdOrigins contains origins of expectations of the QuestionSubcategoryRepository.ListSubcategoriesByQuestionId
type QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdExpectationOrigins struct {
	origin           string
	originCtx        string
	originQuestionId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListSubcategoriesByQuestionId *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId) Optional() *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId {
	mmListSubcategoriesByQuestionId.optional = true
	return mmListSubcategoriesByQuestionId
}

// Expect sets up expected params for QuestionSubcategoryRepository.ListSubcategoriesByQuestionId
func (mmListSubcategoriesByQuestionId *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId) Expect(ctx context.Context, questionId int) *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId {
	if mmListSubcategoriesByQuestionId.mock.funcListSubcategoriesByQuestionId != nil {
		mmListSubcategoriesByQuestionId.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId mock is already set by Set")
	}

	if mmListSubcategoriesByQuestionId.defaultExpectation == nil {
		mmListSubcategoriesByQuestionId.defaultExpectation = &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdExpectation{}
	}

	if mmListSubcategoriesByQuestionId.defaultExpectation.paramPtrs != nil {
		mmListSubcategoriesByQuestionId.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId mock is already set by ExpectParams functions")
	}

	mmListSubcategoriesByQuestionId.defaultExpectation.params = &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdParams{ctx, questionId}
	mmListSubcategoriesByQuestionId.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListSubcategoriesByQuestionId.expectations {
		if minimock.Equal(e.params, mmListSubcategoriesByQuestionId.defaultExpectation.params) {
			mmListSubcategoriesByQuestionId.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListSubcategoriesByQuestionId.defaultExpectation.params)
		}
	}

	return mmListSubcategoriesByQuestionId
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSubcategoryRepository.ListSubcategoriesByQuestionId
func (mmListSubcategoriesByQuestionId *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId) ExpectCtxParam1(ctx context.Context) *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId {
	if mmListSubcategoriesByQuestionId.mock.funcListSubcategoriesByQuestionId != nil {
		mmListSubcategoriesByQuestionId.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId mock is already set by Set")
	}

	if mmListSubcategoriesByQuestionId.defaultExpectation == nil {
		mmListSubcategoriesByQuestionId.defaultExpectation = &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdExpectation{}
	}

	if mmListSubcategoriesByQuestionId.defaultExpectation.params != nil {
		mmListSubcategoriesByQuestionId.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId mock is already set by Expect")
	}

	if mmListSubcategoriesByQuestionId.defaultExpectation.paramPtrs == nil {
		mmListSubcategoriesByQuestionId.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdParamPtrs{}
	}
	mmListSubcategoriesByQuestionId.defaultExpectation.paramPtrs.ctx = &ctx
	mmListSubcategoriesByQuestionId.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListSubcategoriesByQuestionId
}

// ExpectQuestionIdParam2 sets up expected param questionId for QuestionSubcategoryRepository.ListSubcategoriesByQuestionId
func (mmListSubcategoriesByQuestionId *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId) ExpectQuestionIdParam2(questionId int) *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId {
	if mmListSubcategoriesByQuestionId.mock.funcListSubcategoriesByQuestionId != nil {
		mmListSubcategoriesByQuestionId.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId mock is already set by Set")
	}

	if mmListSubcategoriesByQuestionId.defaultExpectation == nil {
		mmListSubcategoriesByQuestionId.defaultExpectation = &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdExpectation{}
	}

	if mmListSubcategoriesByQuestionId.defaultExpectation.params != nil {
		mmListSubcategoriesByQuestionId.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId mock is already set by Expect")
	}

	if mmListSubcategoriesByQuestionId.defaultExpectation.paramPtrs == nil {
		mmListSubcategoriesByQuestionId.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdParamPtrs{}
	}
	mmListSubcategoriesByQuestionId.defaultExpectation.paramPtrs.questionId = &questionId
	mmListSubcategoriesByQuestionId.defaultExpectation.expectationOrigins.originQuestionId = minimock.CallerInfo(1)

	return mmListSubcategoriesByQuestionId
}

// Inspect accepts an inspector function that has same arguments as the QuestionSubcategoryRepository.ListSubcategoriesByQuestionId
func (mmListSubcategoriesByQuestionId *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId) Inspect(f func(ctx context.Context, questionId int)) *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId {
	if mmListSubcategoriesByQuestionId.mock.inspectFuncListSubcategoriesByQuestionId != nil {
		mmListSubcategoriesByQuestionId.mock.t.Fatalf("Inspect function is already set for QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId")
	}

	mmListSubcategoriesByQuestionId.mock.inspectFuncListSubcategoriesByQuestionId = f

	return mmListSubcategoriesByQuestionId
}

// Return sets up results that will be returned by QuestionSubcategoryRepository.ListSubcategoriesByQuestionId
func (mmListSubcategoriesByQuestionId *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId) Return(ia1 []int, err error) *QuestionSubcategoryRepositoryMock {
	if mmListSubcategoriesByQuestionId.mock.funcListSubcategoriesByQuestionId != nil {
		mmListSubcategoriesByQuestionId.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId mock is already set by Set")
	}

	if mmListSubcategoriesByQuestionId.defaultExpectation == nil {
		mmListSubcategoriesByQuestionId.defaultExpectation = &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdExpectation{mock: mmListSubcategoriesByQuestionId.mock}
	}
	mmListSubcategoriesByQuestionId.defaultExpectation.results = &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdResults{ia1, err}
	mmListSubcategoriesByQuestionId.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListSubcategoriesByQuestionId.mock
}

// Set uses given function f to mock the QuestionSubcategoryRepository.ListSubcategoriesByQuestionId method
func (mmListSubcategoriesByQuestionId *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId) Set(f func(ctx context.Context, questionId int) (ia1 []int, err error)) *QuestionSubcategoryRepositoryMock {
	if mmListSubcategoriesByQuestionId.defaultExpectation != nil {
		mmListSubcategoriesByQuestionId.mock.t.Fatalf("Default expectation is already set for the QuestionSubcategoryRepository.ListSubcategoriesByQuestionId method")
	}

	if len(mmListSubcategoriesByQuestionId.expectations) > 0 {
		mmListSubcategoriesByQuestionId.mock.t.Fatalf("Some expectations are already set for the QuestionSubcategoryRepository.ListSubcategoriesByQuestionId method")
	}

	mmListSubcategoriesByQuestionId.mock.funcListSubcategoriesByQuestionId = f
	mmListSubcategoriesByQuestionId.mock.funcListSubcategoriesByQuestionIdOrigin = minimock.CallerInfo(1)
	return mmListSubcategoriesByQuestionId.mock
}

// When sets expectation for the QuestionSubcategoryRepository.ListSubcategoriesByQuestionId which will trigger the result defined by the following
// Then helper
func (mmListSubcategoriesByQuestionId *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId) When(ctx context.Context, questionId int) *QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdExpectation {
	if mmListSubcategoriesByQuestionId.mock.funcListSubcategoriesByQuestionId != nil {
		mmListSubcategoriesByQuestionId.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId mock is already set by Set")
	}

	expectation := &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdExpectation{
		mock:               mmListSubcategoriesByQuestionId.mock,
		params:             &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdParams{ctx, questionId},
		expectationOrigins: QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListSubcategoriesByQuestionId.expectations = append(mmListSubcategoriesByQuestionId.expectations, expectation)
	return expectation
}

// Then sets up QuestionSubcategoryRepository.ListSubcategoriesByQuestionId return parameters for the expectation previously defined by the When method
func (e *QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdExpectation) Then(ia1 []int, err error) *QuestionSubcategoryRepositoryMock {
	e.results = &QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdResults{ia1, err}
	return e.mock
}

// Times sets number of times QuestionSubcategoryRepository.ListSubcategoriesByQuestionId should be invoked
func (mmListSubcategoriesByQuestionId *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId) Times(n uint64) *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId {
	if n == 0 {
		mmListSubcategoriesByQuestionId.mock.t.Fatalf("Times of QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListSubcategoriesByQuestionId.expectedInvocations, n)
	mmListSubcategoriesByQuestionId.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListSubcategoriesByQuestionId
}

func (mmListSubcategoriesByQuestionId *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId) invocationsDone() bool {
	if len(mmListSubcategoriesByQuestionId.expectations) == 0 && mmListSubcategoriesByQuestionId.defaultExpectation == nil && mmListSubcategoriesByQuestionId.mock.funcListSubcategoriesByQuestionId == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListSubcategoriesByQuestionId.mock.afterListSubcategoriesByQuestionIdCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListSubcategoriesByQuestionId.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListSubcategoriesByQuestionId implements mm_repository.QuestionSubcategoryRepository
func (mmListSubcategoriesByQuestionId *QuestionSubcategoryRepositoryMock) ListSubcategoriesByQuestionId(ctx context.Context, questionId int) (ia1 []int, err error) {
	mm_atomic.AddUint64(&mmListSubcategoriesByQuestionId.beforeListSubcategoriesByQuestionIdCounter, 1)
	defer mm_atomic.AddUint64(&mmListSubcategoriesByQuestionId.afterListSubcategoriesByQuestionIdCounter, 1)

	mmListSubcategoriesByQuestionId.t.Helper()

	if mmListSubcategoriesByQuestionId.inspectFuncListSubcategoriesByQuestionId != nil {
		mmListSubcategoriesByQuestionId.inspectFuncListSubcategoriesByQuestionId(ctx, questionId)
	}

	mm_params := QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdParams{ctx, questionId}

	// Record call args
	mmListSubcategoriesByQuestionId.ListSubcategoriesByQuestionIdMock.mutex.Lock()
	mmListSubcategoriesByQuestionId.ListSubcategoriesByQuestionIdMock.callArgs = append(mmListSubcategoriesByQuestionId.ListSubcategoriesByQuestionIdMock.callArgs, &mm_params)
	mmListSubcategoriesByQuestionId.ListSubcategoriesByQuestionIdMock.mutex.Unlock()

	for _, e := range mmListSubcategoriesByQuestionId.ListSubcategoriesByQuestionIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmListSubcategoriesByQuestionId.ListSubcategoriesByQuestionIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListSubcategoriesByQuestionId.ListSubcategoriesByQuestionIdMock.defaultExpectation.Counter, 1)
		mm_want := mmListSubcategoriesByQuestionId.ListSubcategoriesByQuestionIdMock.defaultExpectation.params
		mm_want_ptrs := mmListSubcategoriesByQuestionId.ListSubcategoriesByQuestionIdMock.defaultExpectation.paramPtrs

		mm_got := QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdParams{ctx, questionId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListSubcategoriesByQuestionId.t.Errorf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSubcategoriesByQuestionId.ListSubcategoriesByQuestionIdMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.questionId != nil && !minimock.Equal(*mm_want_ptrs.questionId, mm_got.questionId) {
				mmListSubcategoriesByQuestionId.t.Errorf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId got unexpected parameter questionId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSubcategoriesByQuestionId.ListSubcategoriesByQuestionIdMock.defaultExpectation.expectationOrigins.originQuestionId, *mm_want_ptrs.questionId, mm_got.questionId, minimock.Diff(*mm_want_ptrs.questionId, mm_got.questionId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListSubcategoriesByQuestionId.t.Errorf("QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListSubcategoriesByQuestionId.ListSubcategoriesByQuestionIdMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListSubcategoriesByQuestionId.ListSubcategoriesByQuestionIdMock.defaultExpectation.results
		if mm_results == nil {
			mmListSubcategoriesByQuestionId.t.Fatal("No results are set for the QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmListSubcategoriesByQuestionId.funcListSubcategoriesByQuestionId != nil {
		return mmListSubcategoriesByQuestionId.funcListSubcategoriesByQuestionId(ctx, questionId)
	}
	mmListSubcategoriesByQuestionId.t.Fatalf("Unexpected call to QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId. %v %v", ctx, questionId)
	return
}

// ListSubcategoriesByQuestionIdAfterCounter returns a count of finished QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId invocations
func (mmListSubcategoriesByQuestionId *QuestionSubcategoryRepositoryMock) ListSubcategoriesByQuestionIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSubcategoriesByQuestionId.afterListSubcategoriesByQuestionIdCounter)
}

// ListSubcategoriesByQuestionIdBeforeCounter returns a count of QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId invocations
func (mmListSubcategoriesByQuestionId *QuestionSubcategoryRepositoryMock) ListSubcategoriesByQuestionIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSubcategoriesByQuestionId.beforeListSubcategoriesByQuestionIdCounter)
}

// Calls returns a list of arguments used in each call to QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListSubcategoriesByQuestionId *mQuestionSubcategoryRepositoryMockListSubcategoriesByQuestionId) Calls() []*QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdParams {
	mmListSubcategoriesByQuestionId.mutex.RLock()

	argCopy := make([]*QuestionSubcategoryRepositoryMockListSubcategoriesByQuestionIdParams, len(mmListSubcategoriesByQuestionId.callArgs))
	copy(argCopy, mmListSubcategoriesByQuestionId.callArgs)

	mmListSubcategoriesByQuestionId.mutex.RUnlock()

	return argCopy
}

// MinimockListSubcategoriesByQuestionIdDone returns true if the count of the ListSubcategoriesByQuestionId invocations corresponds
// the number of defined expectations
func (m *QuestionSubcategoryRepositoryMock) MinimockListSubcategoriesByQuestionIdDone() bool {
	if m.ListSubcategoriesByQuestionIdMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListSubcategoriesByQuestionIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListSubcategoriesByQuestionIdMock.invocationsDone()
}

// MinimockListSubcategoriesByQuestionIdInspect logs each unmet expectation
func (m *QuestionSubcategoryRepositoryMock) MinimockListSubcategoriesByQuestionIdInspect() {
	for _, e := range m.ListSubcategoriesByQuestionIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListSubcategoriesByQuestionIdCounter := mm_atomic.LoadUint64(&m.afterListSubcategoriesByQuestionIdCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListSubcategoriesByQuestionIdMock.defaultExpectation != nil && afterListSubcategoriesByQuestionIdCounter < 1 {
		if m.ListSubcategoriesByQuestionIdMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId at\n%s", m.ListSubcategoriesByQuestionIdMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId at\n%s with params: %#v", m.ListSubcategoriesByQuestionIdMock.defaultExpectation.expectationOrigins.origin, *m.ListSubcategoriesByQuestionIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSubcategoriesByQuestionId != nil && afterListSubcategoriesByQuestionIdCounter < 1 {
		m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId at\n%s", m.funcListSubcategoriesByQuestionIdOrigin)
	}

	if !m.ListSubcategoriesByQuestionIdMock.invocationsDone() && afterListSubcategoriesByQuestionIdCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSubcategoryRepositoryMock.ListSubcategoriesByQuestionId at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListSubcategoriesByQuestionIdMock.expectedInvocations), m.ListSubcategoriesByQuestionIdMock.expectedInvocationsOrigin, afterListSubcategoriesByQuestionIdCounter)
	}
}

type mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion struct {
	optional           bool
	mock               *QuestionSubcategoryRepositoryMock
	defaultExpectation *QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation
	expectations       []*QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation

	callArgs []*QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation specifies expectation struct of the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
type QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation struct {
	mock               *QuestionSubcategoryRepositoryMock
	params             *QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams
	paramPtrs          *QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParamPtrs
	expectationOrigins QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectationOrigins
	results            *QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams contains parameters of the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
type QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams struct {
	ctx            context.Context
	questionId     int
	subcategoryIds []int
}

// QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParamPtrs contains pointers to parameters of the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
type QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParamPtrs struct {
	ctx            *context.Context
	questionId     *int
	subcategoryIds *[]int
}

// QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionResults contains results of the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
type QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionResults struct {
	err error
}

// QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionOrigins contains origins of expectations of the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
type QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectationOrigins struct {
	origin               string
	originCtx            string
	originQuestionId     string
	originSubcategoryIds string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Optional() *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	mmRemoveSubcategoriesFromQuestion.optional = true
	return mmRemoveSubcategoriesFromQuestion
}

// Expect sets up expected params for QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Expect(ctx context.Context, questionId int, subcategoryIds []int) *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	if mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Set")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation{}
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by ExpectParams functions")
	}

	mmRemoveSubcategoriesFromQuestion.defaultExpectation.params = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams{ctx, questionId, subcategoryIds}
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveSubcategoriesFromQuestion.expectations {
		if minimock.Equal(e.params, mmRemoveSubcategoriesFromQuestion.defaultExpectation.params) {
			mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveSubcategoriesFromQuestion.defaultExpectation.params)
		}
	}

	return mmRemoveSubcategoriesFromQuestion
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) ExpectCtxParam1(ctx context.Context) *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	if mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Set")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation{}
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.params != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Expect")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParamPtrs{}
	}
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveSubcategoriesFromQuestion
}

// ExpectQuestionIdParam2 sets up expected param questionId for QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) ExpectQuestionIdParam2(questionId int) *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	if mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Set")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation{}
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.params != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Expect")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParamPtrs{}
	}
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs.questionId = &questionId
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.expectationOrigins.originQuestionId = minimock.CallerInfo(1)

	return mmRemoveSubcategoriesFromQuestion
}

// ExpectSubcategoryIdsParam3 sets up expected param subcategoryIds for QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) ExpectSubcategoryIdsParam3(subcategoryIds []int) *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	if mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Set")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation{}
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.params != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Expect")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParamPtrs{}
	}
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs.subcategoryIds = &subcategoryIds
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.expectationOrigins.originSubcategoryIds = minimock.CallerInfo(1)

	return mmRemoveSubcategoriesFromQuestion
}

// Inspect accepts an inspector function that has same arguments as the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Inspect(f func(ctx context.Context, questionId int, subcategoryIds []int)) *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	if mmRemoveSubcategoriesFromQuestion.mock.inspectFuncRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("Inspect function is already set for QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion")
	}

	mmRemoveSubcategoriesFromQuestion.mock.inspectFuncRemoveSubcategoriesFromQuestion = f

	return mmRemoveSubcategoriesFromQuestion
}

// Return sets up results that will be returned by QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Return(err error) *QuestionSubcategoryRepositoryMock {
	if mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Set")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation{mock: mmRemoveSubcategoriesFromQuestion.mock}
	}
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.results = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionResults{err}
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveSubcategoriesFromQuestion.mock
}

// Set uses given function f to mock the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion method
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Set(f func(ctx context.Context, questionId int, subcategoryIds []int) (err error)) *QuestionSubcategoryRepositoryMock {
	if mmRemoveSubcategoriesFromQuestion.defaultExpectation != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("Default expectation is already set for the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion method")
	}

	if len(mmRemoveSubcategoriesFromQuestion.expectations) > 0 {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("Some expectations are already set for the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion method")
	}

	mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion = f
	mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestionOrigin = minimock.CallerInfo(1)
	return mmRemoveSubcategoriesFromQuestion.mock
}

// When sets expectation for the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion which will trigger the result defined by the following
// Then helper
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) When(ctx context.Context, questionId int, subcategoryIds []int) *QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation {
	if mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Set")
	}

	expectation := &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation{
		mock:               mmRemoveSubcategoriesFromQuestion.mock,
		params:             &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams{ctx, questionId, subcategoryIds},
		expectationOrigins: QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveSubcategoriesFromQuestion.expectations = append(mmRemoveSubcategoriesFromQuestion.expectations, expectation)
	return expectation
}

// Then sets up QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion return parameters for the expectation previously defined by the When method
func (e *QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation) Then(err error) *QuestionSubcategoryRepositoryMock {
	e.results = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionResults{err}
	return e.mock
}

// Times sets number of times QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion should be invoked
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Times(n uint64) *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	if n == 0 {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("Times of QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveSubcategoriesFromQuestion.expectedInvocations, n)
	mmRemoveSubcategoriesFromQuestion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveSubcategoriesFromQuestion
}

func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) invocationsDone() bool {
	if len(mmRemoveSubcategoriesFromQuestion.expectations) == 0 && mmRemoveSubcategoriesFromQuestion.defaultExpectation == nil && mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveSubcategoriesFromQuestion.mock.afterRemoveSubcategoriesFromQuestionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveSubcategoriesFromQuestion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveSubcategoriesFromQuestion implements mm_repository.QuestionSubcategoryRepository
func (mmRemoveSubcategoriesFromQuestion *QuestionSubcategoryRepositoryMock) RemoveSubcategoriesFromQuestion(ctx context.Context, questionId int, subcategoryIds []int) (err error) {
	mm_atomic.AddUint64(&mmRemoveSubcategoriesFromQuestion.beforeRemoveSubcategoriesFromQuestionCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveSubcategoriesFromQuestion.afterRemoveSubcategoriesFromQuestionCounter, 1)

	mmRemoveSubcategoriesFromQuestion.t.Helper()

	if mmRemoveSubcategoriesFromQuestion.inspectFuncRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.inspectFuncRemoveSubcategoriesFromQuestion(ctx, questionId, subcategoryIds)
	}

	mm_params := QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams{ctx, questionId, subcategoryIds}

	// Record call args
	mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.mutex.Lock()
	mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.callArgs = append(mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.callArgs, &mm_params)
	mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.mutex.Unlock()

	for _, e := range mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.paramPtrs

		mm_got := QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams{ctx, questionId, subcategoryIds}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveSubcategoriesFromQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.questionId != nil && !minimock.Equal(*mm_want_ptrs.questionId, mm_got.questionId) {
				mmRemoveSubcategoriesFromQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion got unexpected parameter questionId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.expectationOrigins.originQuestionId, *mm_want_ptrs.questionId, mm_got.questionId, minimock.Diff(*mm_want_ptrs.questionId, mm_got.questionId))
			}

			if mm_want_ptrs.subcategoryIds != nil && !minimock.Equal(*mm_want_ptrs.subcategoryIds, mm_got.subcategoryIds) {
				mmRemoveSubcategoriesFromQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion got unexpected parameter subcategoryIds, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.expectationOrigins.originSubcategoryIds, *mm_want_ptrs.subcategoryIds, mm_got.subcategoryIds, minimock.Diff(*mm_want_ptrs.subcategoryIds, mm_got.subcategoryIds))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveSubcategoriesFromQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveSubcategoriesFromQuestion.t.Fatal("No results are set for the QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion")
		}
		return (*mm_results).err
	}
	if mmRemoveSubcategoriesFromQuestion.funcRemoveSubcategoriesFromQuestion != nil {
		return mmRemoveSubcategoriesFromQuestion.funcRemoveSubcategoriesFromQuestion(ctx, questionId, subcategoryIds)
	}
	mmRemoveSubcategoriesFromQuestion.t.Fatalf("Unexpected call to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion. %v %v %v", ctx, questionId, subcategoryIds)
	return
}

// RemoveSubcategoriesFromQuestionAfterCounter returns a count of finished QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion invocations
func (mmRemoveSubcategoriesFromQuestion *QuestionSubcategoryRepositoryMock) RemoveSubcategoriesFromQuestionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveSubcategoriesFromQuestion.afterRemoveSubcategoriesFromQuestionCounter)
}

// RemoveSubcategoriesFromQuestionBeforeCounter returns a count of QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion invocations
func (mmRemoveSubcategoriesFromQuestion *QuestionSubcategoryRepositoryMock) RemoveSubcategoriesFromQuestionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveSubcategoriesFromQuestion.beforeRemoveSubcategoriesFromQuestionCounter)
}

// Calls returns a list of arguments used in each call to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Calls() []*QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams {
	mmRemoveSubcategoriesFromQuestion.mutex.RLock()

	argCopy := make([]*QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams, len(mmRemoveSubcategoriesFromQuestion.callArgs))
	copy(argCopy, mmRemoveSubcategoriesFromQuestion.callArgs)

	mmRemoveSubcategoriesFromQuestion.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveSubcategoriesFromQuestionDone returns true if the count of the RemoveSubcategoriesFromQuestion invocations corresponds
// the number of defined expectations
func (m *QuestionSubcategoryRepositoryMock) MinimockRemoveSubcategoriesFromQuestionDone() bool {
	if m.RemoveSubcategoriesFromQuestionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveSubcategoriesFromQuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveSubcategoriesFromQuestionMock.invocationsDone()
}

// MinimockRemoveSubcategoriesFromQuestionInspect logs each unmet expectation
func (m *QuestionSubcategoryRepositoryMock) MinimockRemoveSubcategoriesFromQuestionInspect() {
	for _, e := range m.RemoveSubcategoriesFromQuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveSubcategoriesFromQuestionCounter := mm_atomic.LoadUint64(&m.afterRemoveSubcategoriesFromQuestionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveSubcategoriesFromQuestionMock.defaultExpectation != nil && afterRemoveSubcategoriesFromQuestionCounter < 1 {
		if m.RemoveSubcategoriesFromQuestionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion at\n%s", m.RemoveSubcategoriesFromQuestionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion at\n%s with params: %#v", m.RemoveSubcategoriesFromQuestionMock.defaultExpectation.expectationOrigins.origin, *m.RemoveSubcategoriesFromQuestionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveSubcategoriesFromQuestion != nil && afterRemoveSubcategoriesFromQuestionCounter < 1 {
		m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion at\n%s", m.funcRemoveSubcategoriesFromQuestionOrigin)
	}

	if !m.RemoveSubcategoriesFromQuestionMock.invocationsDone() && afterRemoveSubcategoriesFromQuestionCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveSubcategoriesFromQuestionMock.expectedInvocations), m.RemoveSubcategoriesFromQuestionMock.expectedInvocationsOrigin, afterRemoveSubcategoriesFromQuestionCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *QuestionSubcategoryRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddSubcategoriesToQuestionInspect()

			m.MinimockListSubcategoriesByQuestionIdInspect()

			m.MinimockRemoveSubcategoriesFromQuestionInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *QuestionSubcategoryRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *QuestionSubcategoryRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddSubcategoriesToQuestionDone() &&
		m.MinimockListSubcategoriesByQuestionIdDone() &&
		m.MinimockRemoveSubcategoriesFromQuestionDone()
}
