// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Kosfedev/learn_go/internal/repository.QuestionSubcategoryRepository -o question_subcategory_repository_minimock.go -n QuestionSubcategoryRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// QuestionSubcategoryRepositoryMock implements mm_repository.QuestionSubcategoryRepository
type QuestionSubcategoryRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddSubcategoriesToQuestion          func(ctx context.Context, questionID int64, subcategoryIDs []int64) (err error)
	funcAddSubcategoriesToQuestionOrigin    string
	inspectFuncAddSubcategoriesToQuestion   func(ctx context.Context, questionID int64, subcategoryIDs []int64)
	afterAddSubcategoriesToQuestionCounter  uint64
	beforeAddSubcategoriesToQuestionCounter uint64
	AddSubcategoriesToQuestionMock          mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion

	funcListSubcategoryIDsByQuestionID          func(ctx context.Context, questionID int64) (ia1 []int64, err error)
	funcListSubcategoryIDsByQuestionIDOrigin    string
	inspectFuncListSubcategoryIDsByQuestionID   func(ctx context.Context, questionID int64)
	afterListSubcategoryIDsByQuestionIDCounter  uint64
	beforeListSubcategoryIDsByQuestionIDCounter uint64
	ListSubcategoryIDsByQuestionIDMock          mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID

	funcRemoveSubcategoriesFromQuestion          func(ctx context.Context, questionID int64, subcategoryIDs []int64) (err error)
	funcRemoveSubcategoriesFromQuestionOrigin    string
	inspectFuncRemoveSubcategoriesFromQuestion   func(ctx context.Context, questionID int64, subcategoryIDs []int64)
	afterRemoveSubcategoriesFromQuestionCounter  uint64
	beforeRemoveSubcategoriesFromQuestionCounter uint64
	RemoveSubcategoriesFromQuestionMock          mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion
}

// NewQuestionSubcategoryRepositoryMock returns a mock for mm_repository.QuestionSubcategoryRepository
func NewQuestionSubcategoryRepositoryMock(t minimock.Tester) *QuestionSubcategoryRepositoryMock {
	m := &QuestionSubcategoryRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddSubcategoriesToQuestionMock = mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion{mock: m}
	m.AddSubcategoriesToQuestionMock.callArgs = []*QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams{}

	m.ListSubcategoryIDsByQuestionIDMock = mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID{mock: m}
	m.ListSubcategoryIDsByQuestionIDMock.callArgs = []*QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDParams{}

	m.RemoveSubcategoriesFromQuestionMock = mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion{mock: m}
	m.RemoveSubcategoriesFromQuestionMock.callArgs = []*QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion struct {
	optional           bool
	mock               *QuestionSubcategoryRepositoryMock
	defaultExpectation *QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation
	expectations       []*QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation

	callArgs []*QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation specifies expectation struct of the QuestionSubcategoryRepository.AddSubcategoriesToQuestion
type QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation struct {
	mock               *QuestionSubcategoryRepositoryMock
	params             *QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams
	paramPtrs          *QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParamPtrs
	expectationOrigins QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectationOrigins
	results            *QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams contains parameters of the QuestionSubcategoryRepository.AddSubcategoriesToQuestion
type QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams struct {
	ctx            context.Context
	questionID     int64
	subcategoryIDs []int64
}

// QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParamPtrs contains pointers to parameters of the QuestionSubcategoryRepository.AddSubcategoriesToQuestion
type QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParamPtrs struct {
	ctx            *context.Context
	questionID     *int64
	subcategoryIDs *[]int64
}

// QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionResults contains results of the QuestionSubcategoryRepository.AddSubcategoriesToQuestion
type QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionResults struct {
	err error
}

// QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionOrigins contains origins of expectations of the QuestionSubcategoryRepository.AddSubcategoriesToQuestion
type QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectationOrigins struct {
	origin               string
	originCtx            string
	originQuestionID     string
	originSubcategoryIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Optional() *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	mmAddSubcategoriesToQuestion.optional = true
	return mmAddSubcategoriesToQuestion
}

// Expect sets up expected params for QuestionSubcategoryRepository.AddSubcategoriesToQuestion
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Expect(ctx context.Context, questionID int64, subcategoryIDs []int64) *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	if mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Set")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation{}
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by ExpectParams functions")
	}

	mmAddSubcategoriesToQuestion.defaultExpectation.params = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams{ctx, questionID, subcategoryIDs}
	mmAddSubcategoriesToQuestion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddSubcategoriesToQuestion.expectations {
		if minimock.Equal(e.params, mmAddSubcategoriesToQuestion.defaultExpectation.params) {
			mmAddSubcategoriesToQuestion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddSubcategoriesToQuestion.defaultExpectation.params)
		}
	}

	return mmAddSubcategoriesToQuestion
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSubcategoryRepository.AddSubcategoriesToQuestion
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) ExpectCtxParam1(ctx context.Context) *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	if mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Set")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation{}
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.params != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Expect")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParamPtrs{}
	}
	mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddSubcategoriesToQuestion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddSubcategoriesToQuestion
}

// ExpectQuestionIDParam2 sets up expected param questionID for QuestionSubcategoryRepository.AddSubcategoriesToQuestion
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) ExpectQuestionIDParam2(questionID int64) *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	if mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Set")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation{}
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.params != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Expect")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParamPtrs{}
	}
	mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs.questionID = &questionID
	mmAddSubcategoriesToQuestion.defaultExpectation.expectationOrigins.originQuestionID = minimock.CallerInfo(1)

	return mmAddSubcategoriesToQuestion
}

// ExpectSubcategoryIDsParam3 sets up expected param subcategoryIDs for QuestionSubcategoryRepository.AddSubcategoriesToQuestion
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) ExpectSubcategoryIDsParam3(subcategoryIDs []int64) *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	if mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Set")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation{}
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.params != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Expect")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParamPtrs{}
	}
	mmAddSubcategoriesToQuestion.defaultExpectation.paramPtrs.subcategoryIDs = &subcategoryIDs
	mmAddSubcategoriesToQuestion.defaultExpectation.expectationOrigins.originSubcategoryIDs = minimock.CallerInfo(1)

	return mmAddSubcategoriesToQuestion
}

// Inspect accepts an inspector function that has same arguments as the QuestionSubcategoryRepository.AddSubcategoriesToQuestion
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Inspect(f func(ctx context.Context, questionID int64, subcategoryIDs []int64)) *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	if mmAddSubcategoriesToQuestion.mock.inspectFuncAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("Inspect function is already set for QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion")
	}

	mmAddSubcategoriesToQuestion.mock.inspectFuncAddSubcategoriesToQuestion = f

	return mmAddSubcategoriesToQuestion
}

// Return sets up results that will be returned by QuestionSubcategoryRepository.AddSubcategoriesToQuestion
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Return(err error) *QuestionSubcategoryRepositoryMock {
	if mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Set")
	}

	if mmAddSubcategoriesToQuestion.defaultExpectation == nil {
		mmAddSubcategoriesToQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation{mock: mmAddSubcategoriesToQuestion.mock}
	}
	mmAddSubcategoriesToQuestion.defaultExpectation.results = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionResults{err}
	mmAddSubcategoriesToQuestion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddSubcategoriesToQuestion.mock
}

// Set uses given function f to mock the QuestionSubcategoryRepository.AddSubcategoriesToQuestion method
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Set(f func(ctx context.Context, questionID int64, subcategoryIDs []int64) (err error)) *QuestionSubcategoryRepositoryMock {
	if mmAddSubcategoriesToQuestion.defaultExpectation != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("Default expectation is already set for the QuestionSubcategoryRepository.AddSubcategoriesToQuestion method")
	}

	if len(mmAddSubcategoriesToQuestion.expectations) > 0 {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("Some expectations are already set for the QuestionSubcategoryRepository.AddSubcategoriesToQuestion method")
	}

	mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion = f
	mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestionOrigin = minimock.CallerInfo(1)
	return mmAddSubcategoriesToQuestion.mock
}

// When sets expectation for the QuestionSubcategoryRepository.AddSubcategoriesToQuestion which will trigger the result defined by the following
// Then helper
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) When(ctx context.Context, questionID int64, subcategoryIDs []int64) *QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation {
	if mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock is already set by Set")
	}

	expectation := &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation{
		mock:               mmAddSubcategoriesToQuestion.mock,
		params:             &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams{ctx, questionID, subcategoryIDs},
		expectationOrigins: QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddSubcategoriesToQuestion.expectations = append(mmAddSubcategoriesToQuestion.expectations, expectation)
	return expectation
}

// Then sets up QuestionSubcategoryRepository.AddSubcategoriesToQuestion return parameters for the expectation previously defined by the When method
func (e *QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionExpectation) Then(err error) *QuestionSubcategoryRepositoryMock {
	e.results = &QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionResults{err}
	return e.mock
}

// Times sets number of times QuestionSubcategoryRepository.AddSubcategoriesToQuestion should be invoked
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Times(n uint64) *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion {
	if n == 0 {
		mmAddSubcategoriesToQuestion.mock.t.Fatalf("Times of QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddSubcategoriesToQuestion.expectedInvocations, n)
	mmAddSubcategoriesToQuestion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddSubcategoriesToQuestion
}

func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) invocationsDone() bool {
	if len(mmAddSubcategoriesToQuestion.expectations) == 0 && mmAddSubcategoriesToQuestion.defaultExpectation == nil && mmAddSubcategoriesToQuestion.mock.funcAddSubcategoriesToQuestion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddSubcategoriesToQuestion.mock.afterAddSubcategoriesToQuestionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddSubcategoriesToQuestion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddSubcategoriesToQuestion implements mm_repository.QuestionSubcategoryRepository
func (mmAddSubcategoriesToQuestion *QuestionSubcategoryRepositoryMock) AddSubcategoriesToQuestion(ctx context.Context, questionID int64, subcategoryIDs []int64) (err error) {
	mm_atomic.AddUint64(&mmAddSubcategoriesToQuestion.beforeAddSubcategoriesToQuestionCounter, 1)
	defer mm_atomic.AddUint64(&mmAddSubcategoriesToQuestion.afterAddSubcategoriesToQuestionCounter, 1)

	mmAddSubcategoriesToQuestion.t.Helper()

	if mmAddSubcategoriesToQuestion.inspectFuncAddSubcategoriesToQuestion != nil {
		mmAddSubcategoriesToQuestion.inspectFuncAddSubcategoriesToQuestion(ctx, questionID, subcategoryIDs)
	}

	mm_params := QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams{ctx, questionID, subcategoryIDs}

	// Record call args
	mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.mutex.Lock()
	mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.callArgs = append(mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.callArgs, &mm_params)
	mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.mutex.Unlock()

	for _, e := range mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.Counter, 1)
		mm_want := mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.params
		mm_want_ptrs := mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.paramPtrs

		mm_got := QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams{ctx, questionID, subcategoryIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddSubcategoriesToQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.questionID != nil && !minimock.Equal(*mm_want_ptrs.questionID, mm_got.questionID) {
				mmAddSubcategoriesToQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion got unexpected parameter questionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.expectationOrigins.originQuestionID, *mm_want_ptrs.questionID, mm_got.questionID, minimock.Diff(*mm_want_ptrs.questionID, mm_got.questionID))
			}

			if mm_want_ptrs.subcategoryIDs != nil && !minimock.Equal(*mm_want_ptrs.subcategoryIDs, mm_got.subcategoryIDs) {
				mmAddSubcategoriesToQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion got unexpected parameter subcategoryIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.expectationOrigins.originSubcategoryIDs, *mm_want_ptrs.subcategoryIDs, mm_got.subcategoryIDs, minimock.Diff(*mm_want_ptrs.subcategoryIDs, mm_got.subcategoryIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddSubcategoriesToQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddSubcategoriesToQuestion.AddSubcategoriesToQuestionMock.defaultExpectation.results
		if mm_results == nil {
			mmAddSubcategoriesToQuestion.t.Fatal("No results are set for the QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion")
		}
		return (*mm_results).err
	}
	if mmAddSubcategoriesToQuestion.funcAddSubcategoriesToQuestion != nil {
		return mmAddSubcategoriesToQuestion.funcAddSubcategoriesToQuestion(ctx, questionID, subcategoryIDs)
	}
	mmAddSubcategoriesToQuestion.t.Fatalf("Unexpected call to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion. %v %v %v", ctx, questionID, subcategoryIDs)
	return
}

// AddSubcategoriesToQuestionAfterCounter returns a count of finished QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion invocations
func (mmAddSubcategoriesToQuestion *QuestionSubcategoryRepositoryMock) AddSubcategoriesToQuestionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSubcategoriesToQuestion.afterAddSubcategoriesToQuestionCounter)
}

// AddSubcategoriesToQuestionBeforeCounter returns a count of QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion invocations
func (mmAddSubcategoriesToQuestion *QuestionSubcategoryRepositoryMock) AddSubcategoriesToQuestionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSubcategoriesToQuestion.beforeAddSubcategoriesToQuestionCounter)
}

// Calls returns a list of arguments used in each call to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddSubcategoriesToQuestion *mQuestionSubcategoryRepositoryMockAddSubcategoriesToQuestion) Calls() []*QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams {
	mmAddSubcategoriesToQuestion.mutex.RLock()

	argCopy := make([]*QuestionSubcategoryRepositoryMockAddSubcategoriesToQuestionParams, len(mmAddSubcategoriesToQuestion.callArgs))
	copy(argCopy, mmAddSubcategoriesToQuestion.callArgs)

	mmAddSubcategoriesToQuestion.mutex.RUnlock()

	return argCopy
}

// MinimockAddSubcategoriesToQuestionDone returns true if the count of the AddSubcategoriesToQuestion invocations corresponds
// the number of defined expectations
func (m *QuestionSubcategoryRepositoryMock) MinimockAddSubcategoriesToQuestionDone() bool {
	if m.AddSubcategoriesToQuestionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddSubcategoriesToQuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddSubcategoriesToQuestionMock.invocationsDone()
}

// MinimockAddSubcategoriesToQuestionInspect logs each unmet expectation
func (m *QuestionSubcategoryRepositoryMock) MinimockAddSubcategoriesToQuestionInspect() {
	for _, e := range m.AddSubcategoriesToQuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddSubcategoriesToQuestionCounter := mm_atomic.LoadUint64(&m.afterAddSubcategoriesToQuestionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddSubcategoriesToQuestionMock.defaultExpectation != nil && afterAddSubcategoriesToQuestionCounter < 1 {
		if m.AddSubcategoriesToQuestionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion at\n%s", m.AddSubcategoriesToQuestionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion at\n%s with params: %#v", m.AddSubcategoriesToQuestionMock.defaultExpectation.expectationOrigins.origin, *m.AddSubcategoriesToQuestionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddSubcategoriesToQuestion != nil && afterAddSubcategoriesToQuestionCounter < 1 {
		m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion at\n%s", m.funcAddSubcategoriesToQuestionOrigin)
	}

	if !m.AddSubcategoriesToQuestionMock.invocationsDone() && afterAddSubcategoriesToQuestionCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSubcategoryRepositoryMock.AddSubcategoriesToQuestion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddSubcategoriesToQuestionMock.expectedInvocations), m.AddSubcategoriesToQuestionMock.expectedInvocationsOrigin, afterAddSubcategoriesToQuestionCounter)
	}
}

type mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID struct {
	optional           bool
	mock               *QuestionSubcategoryRepositoryMock
	defaultExpectation *QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDExpectation
	expectations       []*QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDExpectation

	callArgs []*QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDExpectation specifies expectation struct of the QuestionSubcategoryRepository.ListSubcategoryIDsByQuestionID
type QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDExpectation struct {
	mock               *QuestionSubcategoryRepositoryMock
	params             *QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDParams
	paramPtrs          *QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDParamPtrs
	expectationOrigins QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDExpectationOrigins
	results            *QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDParams contains parameters of the QuestionSubcategoryRepository.ListSubcategoryIDsByQuestionID
type QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDParams struct {
	ctx        context.Context
	questionID int64
}

// QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDParamPtrs contains pointers to parameters of the QuestionSubcategoryRepository.ListSubcategoryIDsByQuestionID
type QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDParamPtrs struct {
	ctx        *context.Context
	questionID *int64
}

// QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDResults contains results of the QuestionSubcategoryRepository.ListSubcategoryIDsByQuestionID
type QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDResults struct {
	ia1 []int64
	err error
}

// QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDOrigins contains origins of expectations of the QuestionSubcategoryRepository.ListSubcategoryIDsByQuestionID
type QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDExpectationOrigins struct {
	origin           string
	originCtx        string
	originQuestionID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListSubcategoryIDsByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID) Optional() *mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID {
	mmListSubcategoryIDsByQuestionID.optional = true
	return mmListSubcategoryIDsByQuestionID
}

// Expect sets up expected params for QuestionSubcategoryRepository.ListSubcategoryIDsByQuestionID
func (mmListSubcategoryIDsByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID) Expect(ctx context.Context, questionID int64) *mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID {
	if mmListSubcategoryIDsByQuestionID.mock.funcListSubcategoryIDsByQuestionID != nil {
		mmListSubcategoryIDsByQuestionID.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID mock is already set by Set")
	}

	if mmListSubcategoryIDsByQuestionID.defaultExpectation == nil {
		mmListSubcategoryIDsByQuestionID.defaultExpectation = &QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDExpectation{}
	}

	if mmListSubcategoryIDsByQuestionID.defaultExpectation.paramPtrs != nil {
		mmListSubcategoryIDsByQuestionID.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID mock is already set by ExpectParams functions")
	}

	mmListSubcategoryIDsByQuestionID.defaultExpectation.params = &QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDParams{ctx, questionID}
	mmListSubcategoryIDsByQuestionID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListSubcategoryIDsByQuestionID.expectations {
		if minimock.Equal(e.params, mmListSubcategoryIDsByQuestionID.defaultExpectation.params) {
			mmListSubcategoryIDsByQuestionID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListSubcategoryIDsByQuestionID.defaultExpectation.params)
		}
	}

	return mmListSubcategoryIDsByQuestionID
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSubcategoryRepository.ListSubcategoryIDsByQuestionID
func (mmListSubcategoryIDsByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID) ExpectCtxParam1(ctx context.Context) *mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID {
	if mmListSubcategoryIDsByQuestionID.mock.funcListSubcategoryIDsByQuestionID != nil {
		mmListSubcategoryIDsByQuestionID.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID mock is already set by Set")
	}

	if mmListSubcategoryIDsByQuestionID.defaultExpectation == nil {
		mmListSubcategoryIDsByQuestionID.defaultExpectation = &QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDExpectation{}
	}

	if mmListSubcategoryIDsByQuestionID.defaultExpectation.params != nil {
		mmListSubcategoryIDsByQuestionID.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID mock is already set by Expect")
	}

	if mmListSubcategoryIDsByQuestionID.defaultExpectation.paramPtrs == nil {
		mmListSubcategoryIDsByQuestionID.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDParamPtrs{}
	}
	mmListSubcategoryIDsByQuestionID.defaultExpectation.paramPtrs.ctx = &ctx
	mmListSubcategoryIDsByQuestionID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListSubcategoryIDsByQuestionID
}

// ExpectQuestionIDParam2 sets up expected param questionID for QuestionSubcategoryRepository.ListSubcategoryIDsByQuestionID
func (mmListSubcategoryIDsByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID) ExpectQuestionIDParam2(questionID int64) *mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID {
	if mmListSubcategoryIDsByQuestionID.mock.funcListSubcategoryIDsByQuestionID != nil {
		mmListSubcategoryIDsByQuestionID.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID mock is already set by Set")
	}

	if mmListSubcategoryIDsByQuestionID.defaultExpectation == nil {
		mmListSubcategoryIDsByQuestionID.defaultExpectation = &QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDExpectation{}
	}

	if mmListSubcategoryIDsByQuestionID.defaultExpectation.params != nil {
		mmListSubcategoryIDsByQuestionID.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID mock is already set by Expect")
	}

	if mmListSubcategoryIDsByQuestionID.defaultExpectation.paramPtrs == nil {
		mmListSubcategoryIDsByQuestionID.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDParamPtrs{}
	}
	mmListSubcategoryIDsByQuestionID.defaultExpectation.paramPtrs.questionID = &questionID
	mmListSubcategoryIDsByQuestionID.defaultExpectation.expectationOrigins.originQuestionID = minimock.CallerInfo(1)

	return mmListSubcategoryIDsByQuestionID
}

// Inspect accepts an inspector function that has same arguments as the QuestionSubcategoryRepository.ListSubcategoryIDsByQuestionID
func (mmListSubcategoryIDsByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID) Inspect(f func(ctx context.Context, questionID int64)) *mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID {
	if mmListSubcategoryIDsByQuestionID.mock.inspectFuncListSubcategoryIDsByQuestionID != nil {
		mmListSubcategoryIDsByQuestionID.mock.t.Fatalf("Inspect function is already set for QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID")
	}

	mmListSubcategoryIDsByQuestionID.mock.inspectFuncListSubcategoryIDsByQuestionID = f

	return mmListSubcategoryIDsByQuestionID
}

// Return sets up results that will be returned by QuestionSubcategoryRepository.ListSubcategoryIDsByQuestionID
func (mmListSubcategoryIDsByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID) Return(ia1 []int64, err error) *QuestionSubcategoryRepositoryMock {
	if mmListSubcategoryIDsByQuestionID.mock.funcListSubcategoryIDsByQuestionID != nil {
		mmListSubcategoryIDsByQuestionID.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID mock is already set by Set")
	}

	if mmListSubcategoryIDsByQuestionID.defaultExpectation == nil {
		mmListSubcategoryIDsByQuestionID.defaultExpectation = &QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDExpectation{mock: mmListSubcategoryIDsByQuestionID.mock}
	}
	mmListSubcategoryIDsByQuestionID.defaultExpectation.results = &QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDResults{ia1, err}
	mmListSubcategoryIDsByQuestionID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListSubcategoryIDsByQuestionID.mock
}

// Set uses given function f to mock the QuestionSubcategoryRepository.ListSubcategoryIDsByQuestionID method
func (mmListSubcategoryIDsByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID) Set(f func(ctx context.Context, questionID int64) (ia1 []int64, err error)) *QuestionSubcategoryRepositoryMock {
	if mmListSubcategoryIDsByQuestionID.defaultExpectation != nil {
		mmListSubcategoryIDsByQuestionID.mock.t.Fatalf("Default expectation is already set for the QuestionSubcategoryRepository.ListSubcategoryIDsByQuestionID method")
	}

	if len(mmListSubcategoryIDsByQuestionID.expectations) > 0 {
		mmListSubcategoryIDsByQuestionID.mock.t.Fatalf("Some expectations are already set for the QuestionSubcategoryRepository.ListSubcategoryIDsByQuestionID method")
	}

	mmListSubcategoryIDsByQuestionID.mock.funcListSubcategoryIDsByQuestionID = f
	mmListSubcategoryIDsByQuestionID.mock.funcListSubcategoryIDsByQuestionIDOrigin = minimock.CallerInfo(1)
	return mmListSubcategoryIDsByQuestionID.mock
}

// When sets expectation for the QuestionSubcategoryRepository.ListSubcategoryIDsByQuestionID which will trigger the result defined by the following
// Then helper
func (mmListSubcategoryIDsByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID) When(ctx context.Context, questionID int64) *QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDExpectation {
	if mmListSubcategoryIDsByQuestionID.mock.funcListSubcategoryIDsByQuestionID != nil {
		mmListSubcategoryIDsByQuestionID.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID mock is already set by Set")
	}

	expectation := &QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDExpectation{
		mock:               mmListSubcategoryIDsByQuestionID.mock,
		params:             &QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDParams{ctx, questionID},
		expectationOrigins: QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListSubcategoryIDsByQuestionID.expectations = append(mmListSubcategoryIDsByQuestionID.expectations, expectation)
	return expectation
}

// Then sets up QuestionSubcategoryRepository.ListSubcategoryIDsByQuestionID return parameters for the expectation previously defined by the When method
func (e *QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDExpectation) Then(ia1 []int64, err error) *QuestionSubcategoryRepositoryMock {
	e.results = &QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDResults{ia1, err}
	return e.mock
}

// Times sets number of times QuestionSubcategoryRepository.ListSubcategoryIDsByQuestionID should be invoked
func (mmListSubcategoryIDsByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID) Times(n uint64) *mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID {
	if n == 0 {
		mmListSubcategoryIDsByQuestionID.mock.t.Fatalf("Times of QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListSubcategoryIDsByQuestionID.expectedInvocations, n)
	mmListSubcategoryIDsByQuestionID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListSubcategoryIDsByQuestionID
}

func (mmListSubcategoryIDsByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID) invocationsDone() bool {
	if len(mmListSubcategoryIDsByQuestionID.expectations) == 0 && mmListSubcategoryIDsByQuestionID.defaultExpectation == nil && mmListSubcategoryIDsByQuestionID.mock.funcListSubcategoryIDsByQuestionID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListSubcategoryIDsByQuestionID.mock.afterListSubcategoryIDsByQuestionIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListSubcategoryIDsByQuestionID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListSubcategoryIDsByQuestionID implements mm_repository.QuestionSubcategoryRepository
func (mmListSubcategoryIDsByQuestionID *QuestionSubcategoryRepositoryMock) ListSubcategoryIDsByQuestionID(ctx context.Context, questionID int64) (ia1 []int64, err error) {
	mm_atomic.AddUint64(&mmListSubcategoryIDsByQuestionID.beforeListSubcategoryIDsByQuestionIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListSubcategoryIDsByQuestionID.afterListSubcategoryIDsByQuestionIDCounter, 1)

	mmListSubcategoryIDsByQuestionID.t.Helper()

	if mmListSubcategoryIDsByQuestionID.inspectFuncListSubcategoryIDsByQuestionID != nil {
		mmListSubcategoryIDsByQuestionID.inspectFuncListSubcategoryIDsByQuestionID(ctx, questionID)
	}

	mm_params := QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDParams{ctx, questionID}

	// Record call args
	mmListSubcategoryIDsByQuestionID.ListSubcategoryIDsByQuestionIDMock.mutex.Lock()
	mmListSubcategoryIDsByQuestionID.ListSubcategoryIDsByQuestionIDMock.callArgs = append(mmListSubcategoryIDsByQuestionID.ListSubcategoryIDsByQuestionIDMock.callArgs, &mm_params)
	mmListSubcategoryIDsByQuestionID.ListSubcategoryIDsByQuestionIDMock.mutex.Unlock()

	for _, e := range mmListSubcategoryIDsByQuestionID.ListSubcategoryIDsByQuestionIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmListSubcategoryIDsByQuestionID.ListSubcategoryIDsByQuestionIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListSubcategoryIDsByQuestionID.ListSubcategoryIDsByQuestionIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListSubcategoryIDsByQuestionID.ListSubcategoryIDsByQuestionIDMock.defaultExpectation.params
		mm_want_ptrs := mmListSubcategoryIDsByQuestionID.ListSubcategoryIDsByQuestionIDMock.defaultExpectation.paramPtrs

		mm_got := QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDParams{ctx, questionID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListSubcategoryIDsByQuestionID.t.Errorf("QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSubcategoryIDsByQuestionID.ListSubcategoryIDsByQuestionIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.questionID != nil && !minimock.Equal(*mm_want_ptrs.questionID, mm_got.questionID) {
				mmListSubcategoryIDsByQuestionID.t.Errorf("QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID got unexpected parameter questionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSubcategoryIDsByQuestionID.ListSubcategoryIDsByQuestionIDMock.defaultExpectation.expectationOrigins.originQuestionID, *mm_want_ptrs.questionID, mm_got.questionID, minimock.Diff(*mm_want_ptrs.questionID, mm_got.questionID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListSubcategoryIDsByQuestionID.t.Errorf("QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListSubcategoryIDsByQuestionID.ListSubcategoryIDsByQuestionIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListSubcategoryIDsByQuestionID.ListSubcategoryIDsByQuestionIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListSubcategoryIDsByQuestionID.t.Fatal("No results are set for the QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmListSubcategoryIDsByQuestionID.funcListSubcategoryIDsByQuestionID != nil {
		return mmListSubcategoryIDsByQuestionID.funcListSubcategoryIDsByQuestionID(ctx, questionID)
	}
	mmListSubcategoryIDsByQuestionID.t.Fatalf("Unexpected call to QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID. %v %v", ctx, questionID)
	return
}

// ListSubcategoryIDsByQuestionIDAfterCounter returns a count of finished QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID invocations
func (mmListSubcategoryIDsByQuestionID *QuestionSubcategoryRepositoryMock) ListSubcategoryIDsByQuestionIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSubcategoryIDsByQuestionID.afterListSubcategoryIDsByQuestionIDCounter)
}

// ListSubcategoryIDsByQuestionIDBeforeCounter returns a count of QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID invocations
func (mmListSubcategoryIDsByQuestionID *QuestionSubcategoryRepositoryMock) ListSubcategoryIDsByQuestionIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSubcategoryIDsByQuestionID.beforeListSubcategoryIDsByQuestionIDCounter)
}

// Calls returns a list of arguments used in each call to QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListSubcategoryIDsByQuestionID *mQuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionID) Calls() []*QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDParams {
	mmListSubcategoryIDsByQuestionID.mutex.RLock()

	argCopy := make([]*QuestionSubcategoryRepositoryMockListSubcategoryIDsByQuestionIDParams, len(mmListSubcategoryIDsByQuestionID.callArgs))
	copy(argCopy, mmListSubcategoryIDsByQuestionID.callArgs)

	mmListSubcategoryIDsByQuestionID.mutex.RUnlock()

	return argCopy
}

// MinimockListSubcategoryIDsByQuestionIDDone returns true if the count of the ListSubcategoryIDsByQuestionID invocations corresponds
// the number of defined expectations
func (m *QuestionSubcategoryRepositoryMock) MinimockListSubcategoryIDsByQuestionIDDone() bool {
	if m.ListSubcategoryIDsByQuestionIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListSubcategoryIDsByQuestionIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListSubcategoryIDsByQuestionIDMock.invocationsDone()
}

// MinimockListSubcategoryIDsByQuestionIDInspect logs each unmet expectation
func (m *QuestionSubcategoryRepositoryMock) MinimockListSubcategoryIDsByQuestionIDInspect() {
	for _, e := range m.ListSubcategoryIDsByQuestionIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListSubcategoryIDsByQuestionIDCounter := mm_atomic.LoadUint64(&m.afterListSubcategoryIDsByQuestionIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListSubcategoryIDsByQuestionIDMock.defaultExpectation != nil && afterListSubcategoryIDsByQuestionIDCounter < 1 {
		if m.ListSubcategoryIDsByQuestionIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID at\n%s", m.ListSubcategoryIDsByQuestionIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID at\n%s with params: %#v", m.ListSubcategoryIDsByQuestionIDMock.defaultExpectation.expectationOrigins.origin, *m.ListSubcategoryIDsByQuestionIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSubcategoryIDsByQuestionID != nil && afterListSubcategoryIDsByQuestionIDCounter < 1 {
		m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID at\n%s", m.funcListSubcategoryIDsByQuestionIDOrigin)
	}

	if !m.ListSubcategoryIDsByQuestionIDMock.invocationsDone() && afterListSubcategoryIDsByQuestionIDCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSubcategoryRepositoryMock.ListSubcategoryIDsByQuestionID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListSubcategoryIDsByQuestionIDMock.expectedInvocations), m.ListSubcategoryIDsByQuestionIDMock.expectedInvocationsOrigin, afterListSubcategoryIDsByQuestionIDCounter)
	}
}

type mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion struct {
	optional           bool
	mock               *QuestionSubcategoryRepositoryMock
	defaultExpectation *QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation
	expectations       []*QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation

	callArgs []*QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation specifies expectation struct of the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
type QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation struct {
	mock               *QuestionSubcategoryRepositoryMock
	params             *QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams
	paramPtrs          *QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParamPtrs
	expectationOrigins QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectationOrigins
	results            *QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams contains parameters of the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
type QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams struct {
	ctx            context.Context
	questionID     int64
	subcategoryIDs []int64
}

// QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParamPtrs contains pointers to parameters of the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
type QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParamPtrs struct {
	ctx            *context.Context
	questionID     *int64
	subcategoryIDs *[]int64
}

// QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionResults contains results of the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
type QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionResults struct {
	err error
}

// QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionOrigins contains origins of expectations of the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
type QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectationOrigins struct {
	origin               string
	originCtx            string
	originQuestionID     string
	originSubcategoryIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Optional() *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	mmRemoveSubcategoriesFromQuestion.optional = true
	return mmRemoveSubcategoriesFromQuestion
}

// Expect sets up expected params for QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Expect(ctx context.Context, questionID int64, subcategoryIDs []int64) *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	if mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Set")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation{}
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by ExpectParams functions")
	}

	mmRemoveSubcategoriesFromQuestion.defaultExpectation.params = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams{ctx, questionID, subcategoryIDs}
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveSubcategoriesFromQuestion.expectations {
		if minimock.Equal(e.params, mmRemoveSubcategoriesFromQuestion.defaultExpectation.params) {
			mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveSubcategoriesFromQuestion.defaultExpectation.params)
		}
	}

	return mmRemoveSubcategoriesFromQuestion
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) ExpectCtxParam1(ctx context.Context) *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	if mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Set")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation{}
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.params != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Expect")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParamPtrs{}
	}
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveSubcategoriesFromQuestion
}

// ExpectQuestionIDParam2 sets up expected param questionID for QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) ExpectQuestionIDParam2(questionID int64) *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	if mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Set")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation{}
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.params != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Expect")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParamPtrs{}
	}
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs.questionID = &questionID
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.expectationOrigins.originQuestionID = minimock.CallerInfo(1)

	return mmRemoveSubcategoriesFromQuestion
}

// ExpectSubcategoryIDsParam3 sets up expected param subcategoryIDs for QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) ExpectSubcategoryIDsParam3(subcategoryIDs []int64) *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	if mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Set")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation{}
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.params != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Expect")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParamPtrs{}
	}
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.paramPtrs.subcategoryIDs = &subcategoryIDs
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.expectationOrigins.originSubcategoryIDs = minimock.CallerInfo(1)

	return mmRemoveSubcategoriesFromQuestion
}

// Inspect accepts an inspector function that has same arguments as the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Inspect(f func(ctx context.Context, questionID int64, subcategoryIDs []int64)) *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	if mmRemoveSubcategoriesFromQuestion.mock.inspectFuncRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("Inspect function is already set for QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion")
	}

	mmRemoveSubcategoriesFromQuestion.mock.inspectFuncRemoveSubcategoriesFromQuestion = f

	return mmRemoveSubcategoriesFromQuestion
}

// Return sets up results that will be returned by QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Return(err error) *QuestionSubcategoryRepositoryMock {
	if mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Set")
	}

	if mmRemoveSubcategoriesFromQuestion.defaultExpectation == nil {
		mmRemoveSubcategoriesFromQuestion.defaultExpectation = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation{mock: mmRemoveSubcategoriesFromQuestion.mock}
	}
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.results = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionResults{err}
	mmRemoveSubcategoriesFromQuestion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveSubcategoriesFromQuestion.mock
}

// Set uses given function f to mock the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion method
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Set(f func(ctx context.Context, questionID int64, subcategoryIDs []int64) (err error)) *QuestionSubcategoryRepositoryMock {
	if mmRemoveSubcategoriesFromQuestion.defaultExpectation != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("Default expectation is already set for the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion method")
	}

	if len(mmRemoveSubcategoriesFromQuestion.expectations) > 0 {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("Some expectations are already set for the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion method")
	}

	mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion = f
	mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestionOrigin = minimock.CallerInfo(1)
	return mmRemoveSubcategoriesFromQuestion.mock
}

// When sets expectation for the QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion which will trigger the result defined by the following
// Then helper
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) When(ctx context.Context, questionID int64, subcategoryIDs []int64) *QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation {
	if mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock is already set by Set")
	}

	expectation := &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation{
		mock:               mmRemoveSubcategoriesFromQuestion.mock,
		params:             &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams{ctx, questionID, subcategoryIDs},
		expectationOrigins: QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveSubcategoriesFromQuestion.expectations = append(mmRemoveSubcategoriesFromQuestion.expectations, expectation)
	return expectation
}

// Then sets up QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion return parameters for the expectation previously defined by the When method
func (e *QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionExpectation) Then(err error) *QuestionSubcategoryRepositoryMock {
	e.results = &QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionResults{err}
	return e.mock
}

// Times sets number of times QuestionSubcategoryRepository.RemoveSubcategoriesFromQuestion should be invoked
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Times(n uint64) *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion {
	if n == 0 {
		mmRemoveSubcategoriesFromQuestion.mock.t.Fatalf("Times of QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveSubcategoriesFromQuestion.expectedInvocations, n)
	mmRemoveSubcategoriesFromQuestion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveSubcategoriesFromQuestion
}

func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) invocationsDone() bool {
	if len(mmRemoveSubcategoriesFromQuestion.expectations) == 0 && mmRemoveSubcategoriesFromQuestion.defaultExpectation == nil && mmRemoveSubcategoriesFromQuestion.mock.funcRemoveSubcategoriesFromQuestion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveSubcategoriesFromQuestion.mock.afterRemoveSubcategoriesFromQuestionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveSubcategoriesFromQuestion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveSubcategoriesFromQuestion implements mm_repository.QuestionSubcategoryRepository
func (mmRemoveSubcategoriesFromQuestion *QuestionSubcategoryRepositoryMock) RemoveSubcategoriesFromQuestion(ctx context.Context, questionID int64, subcategoryIDs []int64) (err error) {
	mm_atomic.AddUint64(&mmRemoveSubcategoriesFromQuestion.beforeRemoveSubcategoriesFromQuestionCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveSubcategoriesFromQuestion.afterRemoveSubcategoriesFromQuestionCounter, 1)

	mmRemoveSubcategoriesFromQuestion.t.Helper()

	if mmRemoveSubcategoriesFromQuestion.inspectFuncRemoveSubcategoriesFromQuestion != nil {
		mmRemoveSubcategoriesFromQuestion.inspectFuncRemoveSubcategoriesFromQuestion(ctx, questionID, subcategoryIDs)
	}

	mm_params := QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams{ctx, questionID, subcategoryIDs}

	// Record call args
	mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.mutex.Lock()
	mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.callArgs = append(mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.callArgs, &mm_params)
	mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.mutex.Unlock()

	for _, e := range mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.paramPtrs

		mm_got := QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams{ctx, questionID, subcategoryIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveSubcategoriesFromQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.questionID != nil && !minimock.Equal(*mm_want_ptrs.questionID, mm_got.questionID) {
				mmRemoveSubcategoriesFromQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion got unexpected parameter questionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.expectationOrigins.originQuestionID, *mm_want_ptrs.questionID, mm_got.questionID, minimock.Diff(*mm_want_ptrs.questionID, mm_got.questionID))
			}

			if mm_want_ptrs.subcategoryIDs != nil && !minimock.Equal(*mm_want_ptrs.subcategoryIDs, mm_got.subcategoryIDs) {
				mmRemoveSubcategoriesFromQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion got unexpected parameter subcategoryIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.expectationOrigins.originSubcategoryIDs, *mm_want_ptrs.subcategoryIDs, mm_got.subcategoryIDs, minimock.Diff(*mm_want_ptrs.subcategoryIDs, mm_got.subcategoryIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveSubcategoriesFromQuestion.t.Errorf("QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveSubcategoriesFromQuestion.RemoveSubcategoriesFromQuestionMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveSubcategoriesFromQuestion.t.Fatal("No results are set for the QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion")
		}
		return (*mm_results).err
	}
	if mmRemoveSubcategoriesFromQuestion.funcRemoveSubcategoriesFromQuestion != nil {
		return mmRemoveSubcategoriesFromQuestion.funcRemoveSubcategoriesFromQuestion(ctx, questionID, subcategoryIDs)
	}
	mmRemoveSubcategoriesFromQuestion.t.Fatalf("Unexpected call to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion. %v %v %v", ctx, questionID, subcategoryIDs)
	return
}

// RemoveSubcategoriesFromQuestionAfterCounter returns a count of finished QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion invocations
func (mmRemoveSubcategoriesFromQuestion *QuestionSubcategoryRepositoryMock) RemoveSubcategoriesFromQuestionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveSubcategoriesFromQuestion.afterRemoveSubcategoriesFromQuestionCounter)
}

// RemoveSubcategoriesFromQuestionBeforeCounter returns a count of QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion invocations
func (mmRemoveSubcategoriesFromQuestion *QuestionSubcategoryRepositoryMock) RemoveSubcategoriesFromQuestionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveSubcategoriesFromQuestion.beforeRemoveSubcategoriesFromQuestionCounter)
}

// Calls returns a list of arguments used in each call to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveSubcategoriesFromQuestion *mQuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestion) Calls() []*QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams {
	mmRemoveSubcategoriesFromQuestion.mutex.RLock()

	argCopy := make([]*QuestionSubcategoryRepositoryMockRemoveSubcategoriesFromQuestionParams, len(mmRemoveSubcategoriesFromQuestion.callArgs))
	copy(argCopy, mmRemoveSubcategoriesFromQuestion.callArgs)

	mmRemoveSubcategoriesFromQuestion.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveSubcategoriesFromQuestionDone returns true if the count of the RemoveSubcategoriesFromQuestion invocations corresponds
// the number of defined expectations
func (m *QuestionSubcategoryRepositoryMock) MinimockRemoveSubcategoriesFromQuestionDone() bool {
	if m.RemoveSubcategoriesFromQuestionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveSubcategoriesFromQuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveSubcategoriesFromQuestionMock.invocationsDone()
}

// MinimockRemoveSubcategoriesFromQuestionInspect logs each unmet expectation
func (m *QuestionSubcategoryRepositoryMock) MinimockRemoveSubcategoriesFromQuestionInspect() {
	for _, e := range m.RemoveSubcategoriesFromQuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveSubcategoriesFromQuestionCounter := mm_atomic.LoadUint64(&m.afterRemoveSubcategoriesFromQuestionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveSubcategoriesFromQuestionMock.defaultExpectation != nil && afterRemoveSubcategoriesFromQuestionCounter < 1 {
		if m.RemoveSubcategoriesFromQuestionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion at\n%s", m.RemoveSubcategoriesFromQuestionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion at\n%s with params: %#v", m.RemoveSubcategoriesFromQuestionMock.defaultExpectation.expectationOrigins.origin, *m.RemoveSubcategoriesFromQuestionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveSubcategoriesFromQuestion != nil && afterRemoveSubcategoriesFromQuestionCounter < 1 {
		m.t.Errorf("Expected call to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion at\n%s", m.funcRemoveSubcategoriesFromQuestionOrigin)
	}

	if !m.RemoveSubcategoriesFromQuestionMock.invocationsDone() && afterRemoveSubcategoriesFromQuestionCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSubcategoryRepositoryMock.RemoveSubcategoriesFromQuestion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveSubcategoriesFromQuestionMock.expectedInvocations), m.RemoveSubcategoriesFromQuestionMock.expectedInvocationsOrigin, afterRemoveSubcategoriesFromQuestionCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *QuestionSubcategoryRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddSubcategoriesToQuestionInspect()

			m.MinimockListSubcategoryIDsByQuestionIDInspect()

			m.MinimockRemoveSubcategoriesFromQuestionInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *QuestionSubcategoryRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *QuestionSubcategoryRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddSubcategoriesToQuestionDone() &&
		m.MinimockListSubcategoryIDsByQuestionIDDone() &&
		m.MinimockRemoveSubcategoriesFromQuestionDone()
}
