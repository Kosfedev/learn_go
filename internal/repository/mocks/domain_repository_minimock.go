// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Kosfedev/learn_go/internal/repository.DomainRepository -o domain_repository_minimock.go -n DomainRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Kosfedev/learn_go/internal/model"
	"github.com/gojuno/minimock/v3"
)

// DomainRepositoryMock implements mm_repository.DomainRepository
type DomainRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, domain *model.NewDomain) (i1 int, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, domain *model.NewDomain)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mDomainRepositoryMockCreate

	funcDelete          func(ctx context.Context, id int) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id int)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mDomainRepositoryMockDelete

	funcGet          func(ctx context.Context, id int) (dp1 *model.Domain, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id int)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mDomainRepositoryMockGet

	funcUpdate          func(ctx context.Context, id int, updatedDomain *model.UpdatedDomain) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, id int, updatedDomain *model.UpdatedDomain)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mDomainRepositoryMockUpdate
}

// NewDomainRepositoryMock returns a mock for mm_repository.DomainRepository
func NewDomainRepositoryMock(t minimock.Tester) *DomainRepositoryMock {
	m := &DomainRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mDomainRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*DomainRepositoryMockCreateParams{}

	m.DeleteMock = mDomainRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*DomainRepositoryMockDeleteParams{}

	m.GetMock = mDomainRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*DomainRepositoryMockGetParams{}

	m.UpdateMock = mDomainRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*DomainRepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mDomainRepositoryMockCreate struct {
	optional           bool
	mock               *DomainRepositoryMock
	defaultExpectation *DomainRepositoryMockCreateExpectation
	expectations       []*DomainRepositoryMockCreateExpectation

	callArgs []*DomainRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DomainRepositoryMockCreateExpectation specifies expectation struct of the DomainRepository.Create
type DomainRepositoryMockCreateExpectation struct {
	mock               *DomainRepositoryMock
	params             *DomainRepositoryMockCreateParams
	paramPtrs          *DomainRepositoryMockCreateParamPtrs
	expectationOrigins DomainRepositoryMockCreateExpectationOrigins
	results            *DomainRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// DomainRepositoryMockCreateParams contains parameters of the DomainRepository.Create
type DomainRepositoryMockCreateParams struct {
	ctx    context.Context
	domain *model.NewDomain
}

// DomainRepositoryMockCreateParamPtrs contains pointers to parameters of the DomainRepository.Create
type DomainRepositoryMockCreateParamPtrs struct {
	ctx    *context.Context
	domain **model.NewDomain
}

// DomainRepositoryMockCreateResults contains results of the DomainRepository.Create
type DomainRepositoryMockCreateResults struct {
	i1  int
	err error
}

// DomainRepositoryMockCreateOrigins contains origins of expectations of the DomainRepository.Create
type DomainRepositoryMockCreateExpectationOrigins struct {
	origin       string
	originCtx    string
	originDomain string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mDomainRepositoryMockCreate) Optional() *mDomainRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for DomainRepository.Create
func (mmCreate *mDomainRepositoryMockCreate) Expect(ctx context.Context, domain *model.NewDomain) *mDomainRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DomainRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &DomainRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("DomainRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &DomainRepositoryMockCreateParams{ctx, domain}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for DomainRepository.Create
func (mmCreate *mDomainRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mDomainRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DomainRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &DomainRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("DomainRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &DomainRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectDomainParam2 sets up expected param domain for DomainRepository.Create
func (mmCreate *mDomainRepositoryMockCreate) ExpectDomainParam2(domain *model.NewDomain) *mDomainRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DomainRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &DomainRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("DomainRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &DomainRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.domain = &domain
	mmCreate.defaultExpectation.expectationOrigins.originDomain = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the DomainRepository.Create
func (mmCreate *mDomainRepositoryMockCreate) Inspect(f func(ctx context.Context, domain *model.NewDomain)) *mDomainRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for DomainRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by DomainRepository.Create
func (mmCreate *mDomainRepositoryMockCreate) Return(i1 int, err error) *DomainRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DomainRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &DomainRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &DomainRepositoryMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the DomainRepository.Create method
func (mmCreate *mDomainRepositoryMockCreate) Set(f func(ctx context.Context, domain *model.NewDomain) (i1 int, err error)) *DomainRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the DomainRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the DomainRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the DomainRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mDomainRepositoryMockCreate) When(ctx context.Context, domain *model.NewDomain) *DomainRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DomainRepositoryMock.Create mock is already set by Set")
	}

	expectation := &DomainRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &DomainRepositoryMockCreateParams{ctx, domain},
		expectationOrigins: DomainRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up DomainRepository.Create return parameters for the expectation previously defined by the When method
func (e *DomainRepositoryMockCreateExpectation) Then(i1 int, err error) *DomainRepositoryMock {
	e.results = &DomainRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times DomainRepository.Create should be invoked
func (mmCreate *mDomainRepositoryMockCreate) Times(n uint64) *mDomainRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of DomainRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mDomainRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_repository.DomainRepository
func (mmCreate *DomainRepositoryMock) Create(ctx context.Context, domain *model.NewDomain) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, domain)
	}

	mm_params := DomainRepositoryMockCreateParams{ctx, domain}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := DomainRepositoryMockCreateParams{ctx, domain}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("DomainRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.domain != nil && !minimock.Equal(*mm_want_ptrs.domain, mm_got.domain) {
				mmCreate.t.Errorf("DomainRepositoryMock.Create got unexpected parameter domain, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originDomain, *mm_want_ptrs.domain, mm_got.domain, minimock.Diff(*mm_want_ptrs.domain, mm_got.domain))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("DomainRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the DomainRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, domain)
	}
	mmCreate.t.Fatalf("Unexpected call to DomainRepositoryMock.Create. %v %v", ctx, domain)
	return
}

// CreateAfterCounter returns a count of finished DomainRepositoryMock.Create invocations
func (mmCreate *DomainRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of DomainRepositoryMock.Create invocations
func (mmCreate *DomainRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to DomainRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mDomainRepositoryMockCreate) Calls() []*DomainRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*DomainRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *DomainRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *DomainRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DomainRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DomainRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DomainRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to DomainRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to DomainRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mDomainRepositoryMockDelete struct {
	optional           bool
	mock               *DomainRepositoryMock
	defaultExpectation *DomainRepositoryMockDeleteExpectation
	expectations       []*DomainRepositoryMockDeleteExpectation

	callArgs []*DomainRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DomainRepositoryMockDeleteExpectation specifies expectation struct of the DomainRepository.Delete
type DomainRepositoryMockDeleteExpectation struct {
	mock               *DomainRepositoryMock
	params             *DomainRepositoryMockDeleteParams
	paramPtrs          *DomainRepositoryMockDeleteParamPtrs
	expectationOrigins DomainRepositoryMockDeleteExpectationOrigins
	results            *DomainRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// DomainRepositoryMockDeleteParams contains parameters of the DomainRepository.Delete
type DomainRepositoryMockDeleteParams struct {
	ctx context.Context
	id  int
}

// DomainRepositoryMockDeleteParamPtrs contains pointers to parameters of the DomainRepository.Delete
type DomainRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int
}

// DomainRepositoryMockDeleteResults contains results of the DomainRepository.Delete
type DomainRepositoryMockDeleteResults struct {
	err error
}

// DomainRepositoryMockDeleteOrigins contains origins of expectations of the DomainRepository.Delete
type DomainRepositoryMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mDomainRepositoryMockDelete) Optional() *mDomainRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for DomainRepository.Delete
func (mmDelete *mDomainRepositoryMockDelete) Expect(ctx context.Context, id int) *mDomainRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("DomainRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &DomainRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("DomainRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &DomainRepositoryMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for DomainRepository.Delete
func (mmDelete *mDomainRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mDomainRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("DomainRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &DomainRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("DomainRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &DomainRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for DomainRepository.Delete
func (mmDelete *mDomainRepositoryMockDelete) ExpectIdParam2(id int) *mDomainRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("DomainRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &DomainRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("DomainRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &DomainRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the DomainRepository.Delete
func (mmDelete *mDomainRepositoryMockDelete) Inspect(f func(ctx context.Context, id int)) *mDomainRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for DomainRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by DomainRepository.Delete
func (mmDelete *mDomainRepositoryMockDelete) Return(err error) *DomainRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("DomainRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &DomainRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &DomainRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the DomainRepository.Delete method
func (mmDelete *mDomainRepositoryMockDelete) Set(f func(ctx context.Context, id int) (err error)) *DomainRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the DomainRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the DomainRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the DomainRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mDomainRepositoryMockDelete) When(ctx context.Context, id int) *DomainRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("DomainRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &DomainRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &DomainRepositoryMockDeleteParams{ctx, id},
		expectationOrigins: DomainRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up DomainRepository.Delete return parameters for the expectation previously defined by the When method
func (e *DomainRepositoryMockDeleteExpectation) Then(err error) *DomainRepositoryMock {
	e.results = &DomainRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times DomainRepository.Delete should be invoked
func (mmDelete *mDomainRepositoryMockDelete) Times(n uint64) *mDomainRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of DomainRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mDomainRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_repository.DomainRepository
func (mmDelete *DomainRepositoryMock) Delete(ctx context.Context, id int) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := DomainRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := DomainRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("DomainRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("DomainRepositoryMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("DomainRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the DomainRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to DomainRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished DomainRepositoryMock.Delete invocations
func (mmDelete *DomainRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of DomainRepositoryMock.Delete invocations
func (mmDelete *DomainRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to DomainRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mDomainRepositoryMockDelete) Calls() []*DomainRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*DomainRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *DomainRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *DomainRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DomainRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DomainRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DomainRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to DomainRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to DomainRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mDomainRepositoryMockGet struct {
	optional           bool
	mock               *DomainRepositoryMock
	defaultExpectation *DomainRepositoryMockGetExpectation
	expectations       []*DomainRepositoryMockGetExpectation

	callArgs []*DomainRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DomainRepositoryMockGetExpectation specifies expectation struct of the DomainRepository.Get
type DomainRepositoryMockGetExpectation struct {
	mock               *DomainRepositoryMock
	params             *DomainRepositoryMockGetParams
	paramPtrs          *DomainRepositoryMockGetParamPtrs
	expectationOrigins DomainRepositoryMockGetExpectationOrigins
	results            *DomainRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// DomainRepositoryMockGetParams contains parameters of the DomainRepository.Get
type DomainRepositoryMockGetParams struct {
	ctx context.Context
	id  int
}

// DomainRepositoryMockGetParamPtrs contains pointers to parameters of the DomainRepository.Get
type DomainRepositoryMockGetParamPtrs struct {
	ctx *context.Context
	id  *int
}

// DomainRepositoryMockGetResults contains results of the DomainRepository.Get
type DomainRepositoryMockGetResults struct {
	dp1 *model.Domain
	err error
}

// DomainRepositoryMockGetOrigins contains origins of expectations of the DomainRepository.Get
type DomainRepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mDomainRepositoryMockGet) Optional() *mDomainRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for DomainRepository.Get
func (mmGet *mDomainRepositoryMockGet) Expect(ctx context.Context, id int) *mDomainRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("DomainRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &DomainRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("DomainRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &DomainRepositoryMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for DomainRepository.Get
func (mmGet *mDomainRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mDomainRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("DomainRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &DomainRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("DomainRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &DomainRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for DomainRepository.Get
func (mmGet *mDomainRepositoryMockGet) ExpectIdParam2(id int) *mDomainRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("DomainRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &DomainRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("DomainRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &DomainRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the DomainRepository.Get
func (mmGet *mDomainRepositoryMockGet) Inspect(f func(ctx context.Context, id int)) *mDomainRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for DomainRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by DomainRepository.Get
func (mmGet *mDomainRepositoryMockGet) Return(dp1 *model.Domain, err error) *DomainRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("DomainRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &DomainRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &DomainRepositoryMockGetResults{dp1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the DomainRepository.Get method
func (mmGet *mDomainRepositoryMockGet) Set(f func(ctx context.Context, id int) (dp1 *model.Domain, err error)) *DomainRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the DomainRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the DomainRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the DomainRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mDomainRepositoryMockGet) When(ctx context.Context, id int) *DomainRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("DomainRepositoryMock.Get mock is already set by Set")
	}

	expectation := &DomainRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &DomainRepositoryMockGetParams{ctx, id},
		expectationOrigins: DomainRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up DomainRepository.Get return parameters for the expectation previously defined by the When method
func (e *DomainRepositoryMockGetExpectation) Then(dp1 *model.Domain, err error) *DomainRepositoryMock {
	e.results = &DomainRepositoryMockGetResults{dp1, err}
	return e.mock
}

// Times sets number of times DomainRepository.Get should be invoked
func (mmGet *mDomainRepositoryMockGet) Times(n uint64) *mDomainRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of DomainRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mDomainRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.DomainRepository
func (mmGet *DomainRepositoryMock) Get(ctx context.Context, id int) (dp1 *model.Domain, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := DomainRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := DomainRepositoryMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("DomainRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("DomainRepositoryMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("DomainRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the DomainRepositoryMock.Get")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to DomainRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished DomainRepositoryMock.Get invocations
func (mmGet *DomainRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of DomainRepositoryMock.Get invocations
func (mmGet *DomainRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to DomainRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mDomainRepositoryMockGet) Calls() []*DomainRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*DomainRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *DomainRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *DomainRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DomainRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DomainRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DomainRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to DomainRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to DomainRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mDomainRepositoryMockUpdate struct {
	optional           bool
	mock               *DomainRepositoryMock
	defaultExpectation *DomainRepositoryMockUpdateExpectation
	expectations       []*DomainRepositoryMockUpdateExpectation

	callArgs []*DomainRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DomainRepositoryMockUpdateExpectation specifies expectation struct of the DomainRepository.Update
type DomainRepositoryMockUpdateExpectation struct {
	mock               *DomainRepositoryMock
	params             *DomainRepositoryMockUpdateParams
	paramPtrs          *DomainRepositoryMockUpdateParamPtrs
	expectationOrigins DomainRepositoryMockUpdateExpectationOrigins
	results            *DomainRepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// DomainRepositoryMockUpdateParams contains parameters of the DomainRepository.Update
type DomainRepositoryMockUpdateParams struct {
	ctx           context.Context
	id            int
	updatedDomain *model.UpdatedDomain
}

// DomainRepositoryMockUpdateParamPtrs contains pointers to parameters of the DomainRepository.Update
type DomainRepositoryMockUpdateParamPtrs struct {
	ctx           *context.Context
	id            *int
	updatedDomain **model.UpdatedDomain
}

// DomainRepositoryMockUpdateResults contains results of the DomainRepository.Update
type DomainRepositoryMockUpdateResults struct {
	err error
}

// DomainRepositoryMockUpdateOrigins contains origins of expectations of the DomainRepository.Update
type DomainRepositoryMockUpdateExpectationOrigins struct {
	origin              string
	originCtx           string
	originId            string
	originUpdatedDomain string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mDomainRepositoryMockUpdate) Optional() *mDomainRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for DomainRepository.Update
func (mmUpdate *mDomainRepositoryMockUpdate) Expect(ctx context.Context, id int, updatedDomain *model.UpdatedDomain) *mDomainRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DomainRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &DomainRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("DomainRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &DomainRepositoryMockUpdateParams{ctx, id, updatedDomain}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for DomainRepository.Update
func (mmUpdate *mDomainRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mDomainRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DomainRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &DomainRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("DomainRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &DomainRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectIdParam2 sets up expected param id for DomainRepository.Update
func (mmUpdate *mDomainRepositoryMockUpdate) ExpectIdParam2(id int) *mDomainRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DomainRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &DomainRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("DomainRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &DomainRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.id = &id
	mmUpdate.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectUpdatedDomainParam3 sets up expected param updatedDomain for DomainRepository.Update
func (mmUpdate *mDomainRepositoryMockUpdate) ExpectUpdatedDomainParam3(updatedDomain *model.UpdatedDomain) *mDomainRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DomainRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &DomainRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("DomainRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &DomainRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.updatedDomain = &updatedDomain
	mmUpdate.defaultExpectation.expectationOrigins.originUpdatedDomain = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the DomainRepository.Update
func (mmUpdate *mDomainRepositoryMockUpdate) Inspect(f func(ctx context.Context, id int, updatedDomain *model.UpdatedDomain)) *mDomainRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for DomainRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by DomainRepository.Update
func (mmUpdate *mDomainRepositoryMockUpdate) Return(err error) *DomainRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DomainRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &DomainRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &DomainRepositoryMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the DomainRepository.Update method
func (mmUpdate *mDomainRepositoryMockUpdate) Set(f func(ctx context.Context, id int, updatedDomain *model.UpdatedDomain) (err error)) *DomainRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the DomainRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the DomainRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the DomainRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mDomainRepositoryMockUpdate) When(ctx context.Context, id int, updatedDomain *model.UpdatedDomain) *DomainRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DomainRepositoryMock.Update mock is already set by Set")
	}

	expectation := &DomainRepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &DomainRepositoryMockUpdateParams{ctx, id, updatedDomain},
		expectationOrigins: DomainRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up DomainRepository.Update return parameters for the expectation previously defined by the When method
func (e *DomainRepositoryMockUpdateExpectation) Then(err error) *DomainRepositoryMock {
	e.results = &DomainRepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times DomainRepository.Update should be invoked
func (mmUpdate *mDomainRepositoryMockUpdate) Times(n uint64) *mDomainRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of DomainRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mDomainRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_repository.DomainRepository
func (mmUpdate *DomainRepositoryMock) Update(ctx context.Context, id int, updatedDomain *model.UpdatedDomain) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, id, updatedDomain)
	}

	mm_params := DomainRepositoryMockUpdateParams{ctx, id, updatedDomain}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := DomainRepositoryMockUpdateParams{ctx, id, updatedDomain}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("DomainRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdate.t.Errorf("DomainRepositoryMock.Update got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.updatedDomain != nil && !minimock.Equal(*mm_want_ptrs.updatedDomain, mm_got.updatedDomain) {
				mmUpdate.t.Errorf("DomainRepositoryMock.Update got unexpected parameter updatedDomain, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originUpdatedDomain, *mm_want_ptrs.updatedDomain, mm_got.updatedDomain, minimock.Diff(*mm_want_ptrs.updatedDomain, mm_got.updatedDomain))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("DomainRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the DomainRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, id, updatedDomain)
	}
	mmUpdate.t.Fatalf("Unexpected call to DomainRepositoryMock.Update. %v %v %v", ctx, id, updatedDomain)
	return
}

// UpdateAfterCounter returns a count of finished DomainRepositoryMock.Update invocations
func (mmUpdate *DomainRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of DomainRepositoryMock.Update invocations
func (mmUpdate *DomainRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to DomainRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mDomainRepositoryMockUpdate) Calls() []*DomainRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*DomainRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *DomainRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *DomainRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DomainRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DomainRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DomainRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to DomainRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to DomainRepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DomainRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DomainRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DomainRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockUpdateDone()
}
