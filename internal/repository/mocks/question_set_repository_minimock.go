// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Kosfedev/learn_go/internal/repository.QuestionSetRepository -o question_set_repository_minimock.go -n QuestionSetRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// QuestionSetRepositoryMock implements mm_repository.QuestionSetRepository
type QuestionSetRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddQuestionToSets          func(ctx context.Context, questionID int64, setIDs []int64) (err error)
	funcAddQuestionToSetsOrigin    string
	inspectFuncAddQuestionToSets   func(ctx context.Context, questionID int64, setIDs []int64)
	afterAddQuestionToSetsCounter  uint64
	beforeAddQuestionToSetsCounter uint64
	AddQuestionToSetsMock          mQuestionSetRepositoryMockAddQuestionToSets

	funcAddQuestionsToSet          func(ctx context.Context, setID int64, questionIDs []int64) (err error)
	funcAddQuestionsToSetOrigin    string
	inspectFuncAddQuestionsToSet   func(ctx context.Context, setID int64, questionIDs []int64)
	afterAddQuestionsToSetCounter  uint64
	beforeAddQuestionsToSetCounter uint64
	AddQuestionsToSetMock          mQuestionSetRepositoryMockAddQuestionsToSet

	funcListQuestionIDsBySetID          func(ctx context.Context, setID int64) (ia1 []int64, err error)
	funcListQuestionIDsBySetIDOrigin    string
	inspectFuncListQuestionIDsBySetID   func(ctx context.Context, setID int64)
	afterListQuestionIDsBySetIDCounter  uint64
	beforeListQuestionIDsBySetIDCounter uint64
	ListQuestionIDsBySetIDMock          mQuestionSetRepositoryMockListQuestionIDsBySetID

	funcListSetIDsByQuestionID          func(ctx context.Context, questionID int64) (ia1 []int64, err error)
	funcListSetIDsByQuestionIDOrigin    string
	inspectFuncListSetIDsByQuestionID   func(ctx context.Context, questionID int64)
	afterListSetIDsByQuestionIDCounter  uint64
	beforeListSetIDsByQuestionIDCounter uint64
	ListSetIDsByQuestionIDMock          mQuestionSetRepositoryMockListSetIDsByQuestionID

	funcRemoveQuestionFromSets          func(ctx context.Context, questionID int64, setIDs []int64) (err error)
	funcRemoveQuestionFromSetsOrigin    string
	inspectFuncRemoveQuestionFromSets   func(ctx context.Context, questionID int64, setIDs []int64)
	afterRemoveQuestionFromSetsCounter  uint64
	beforeRemoveQuestionFromSetsCounter uint64
	RemoveQuestionFromSetsMock          mQuestionSetRepositoryMockRemoveQuestionFromSets

	funcRemoveQuestionsFromSet          func(ctx context.Context, setID int64, questionIDs []int64) (err error)
	funcRemoveQuestionsFromSetOrigin    string
	inspectFuncRemoveQuestionsFromSet   func(ctx context.Context, setID int64, questionIDs []int64)
	afterRemoveQuestionsFromSetCounter  uint64
	beforeRemoveQuestionsFromSetCounter uint64
	RemoveQuestionsFromSetMock          mQuestionSetRepositoryMockRemoveQuestionsFromSet
}

// NewQuestionSetRepositoryMock returns a mock for mm_repository.QuestionSetRepository
func NewQuestionSetRepositoryMock(t minimock.Tester) *QuestionSetRepositoryMock {
	m := &QuestionSetRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddQuestionToSetsMock = mQuestionSetRepositoryMockAddQuestionToSets{mock: m}
	m.AddQuestionToSetsMock.callArgs = []*QuestionSetRepositoryMockAddQuestionToSetsParams{}

	m.AddQuestionsToSetMock = mQuestionSetRepositoryMockAddQuestionsToSet{mock: m}
	m.AddQuestionsToSetMock.callArgs = []*QuestionSetRepositoryMockAddQuestionsToSetParams{}

	m.ListQuestionIDsBySetIDMock = mQuestionSetRepositoryMockListQuestionIDsBySetID{mock: m}
	m.ListQuestionIDsBySetIDMock.callArgs = []*QuestionSetRepositoryMockListQuestionIDsBySetIDParams{}

	m.ListSetIDsByQuestionIDMock = mQuestionSetRepositoryMockListSetIDsByQuestionID{mock: m}
	m.ListSetIDsByQuestionIDMock.callArgs = []*QuestionSetRepositoryMockListSetIDsByQuestionIDParams{}

	m.RemoveQuestionFromSetsMock = mQuestionSetRepositoryMockRemoveQuestionFromSets{mock: m}
	m.RemoveQuestionFromSetsMock.callArgs = []*QuestionSetRepositoryMockRemoveQuestionFromSetsParams{}

	m.RemoveQuestionsFromSetMock = mQuestionSetRepositoryMockRemoveQuestionsFromSet{mock: m}
	m.RemoveQuestionsFromSetMock.callArgs = []*QuestionSetRepositoryMockRemoveQuestionsFromSetParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mQuestionSetRepositoryMockAddQuestionToSets struct {
	optional           bool
	mock               *QuestionSetRepositoryMock
	defaultExpectation *QuestionSetRepositoryMockAddQuestionToSetsExpectation
	expectations       []*QuestionSetRepositoryMockAddQuestionToSetsExpectation

	callArgs []*QuestionSetRepositoryMockAddQuestionToSetsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSetRepositoryMockAddQuestionToSetsExpectation specifies expectation struct of the QuestionSetRepository.AddQuestionToSets
type QuestionSetRepositoryMockAddQuestionToSetsExpectation struct {
	mock               *QuestionSetRepositoryMock
	params             *QuestionSetRepositoryMockAddQuestionToSetsParams
	paramPtrs          *QuestionSetRepositoryMockAddQuestionToSetsParamPtrs
	expectationOrigins QuestionSetRepositoryMockAddQuestionToSetsExpectationOrigins
	results            *QuestionSetRepositoryMockAddQuestionToSetsResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSetRepositoryMockAddQuestionToSetsParams contains parameters of the QuestionSetRepository.AddQuestionToSets
type QuestionSetRepositoryMockAddQuestionToSetsParams struct {
	ctx        context.Context
	questionID int64
	setIDs     []int64
}

// QuestionSetRepositoryMockAddQuestionToSetsParamPtrs contains pointers to parameters of the QuestionSetRepository.AddQuestionToSets
type QuestionSetRepositoryMockAddQuestionToSetsParamPtrs struct {
	ctx        *context.Context
	questionID *int64
	setIDs     *[]int64
}

// QuestionSetRepositoryMockAddQuestionToSetsResults contains results of the QuestionSetRepository.AddQuestionToSets
type QuestionSetRepositoryMockAddQuestionToSetsResults struct {
	err error
}

// QuestionSetRepositoryMockAddQuestionToSetsOrigins contains origins of expectations of the QuestionSetRepository.AddQuestionToSets
type QuestionSetRepositoryMockAddQuestionToSetsExpectationOrigins struct {
	origin           string
	originCtx        string
	originQuestionID string
	originSetIDs     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddQuestionToSets *mQuestionSetRepositoryMockAddQuestionToSets) Optional() *mQuestionSetRepositoryMockAddQuestionToSets {
	mmAddQuestionToSets.optional = true
	return mmAddQuestionToSets
}

// Expect sets up expected params for QuestionSetRepository.AddQuestionToSets
func (mmAddQuestionToSets *mQuestionSetRepositoryMockAddQuestionToSets) Expect(ctx context.Context, questionID int64, setIDs []int64) *mQuestionSetRepositoryMockAddQuestionToSets {
	if mmAddQuestionToSets.mock.funcAddQuestionToSets != nil {
		mmAddQuestionToSets.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionToSets mock is already set by Set")
	}

	if mmAddQuestionToSets.defaultExpectation == nil {
		mmAddQuestionToSets.defaultExpectation = &QuestionSetRepositoryMockAddQuestionToSetsExpectation{}
	}

	if mmAddQuestionToSets.defaultExpectation.paramPtrs != nil {
		mmAddQuestionToSets.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionToSets mock is already set by ExpectParams functions")
	}

	mmAddQuestionToSets.defaultExpectation.params = &QuestionSetRepositoryMockAddQuestionToSetsParams{ctx, questionID, setIDs}
	mmAddQuestionToSets.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddQuestionToSets.expectations {
		if minimock.Equal(e.params, mmAddQuestionToSets.defaultExpectation.params) {
			mmAddQuestionToSets.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddQuestionToSets.defaultExpectation.params)
		}
	}

	return mmAddQuestionToSets
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSetRepository.AddQuestionToSets
func (mmAddQuestionToSets *mQuestionSetRepositoryMockAddQuestionToSets) ExpectCtxParam1(ctx context.Context) *mQuestionSetRepositoryMockAddQuestionToSets {
	if mmAddQuestionToSets.mock.funcAddQuestionToSets != nil {
		mmAddQuestionToSets.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionToSets mock is already set by Set")
	}

	if mmAddQuestionToSets.defaultExpectation == nil {
		mmAddQuestionToSets.defaultExpectation = &QuestionSetRepositoryMockAddQuestionToSetsExpectation{}
	}

	if mmAddQuestionToSets.defaultExpectation.params != nil {
		mmAddQuestionToSets.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionToSets mock is already set by Expect")
	}

	if mmAddQuestionToSets.defaultExpectation.paramPtrs == nil {
		mmAddQuestionToSets.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockAddQuestionToSetsParamPtrs{}
	}
	mmAddQuestionToSets.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddQuestionToSets.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddQuestionToSets
}

// ExpectQuestionIDParam2 sets up expected param questionID for QuestionSetRepository.AddQuestionToSets
func (mmAddQuestionToSets *mQuestionSetRepositoryMockAddQuestionToSets) ExpectQuestionIDParam2(questionID int64) *mQuestionSetRepositoryMockAddQuestionToSets {
	if mmAddQuestionToSets.mock.funcAddQuestionToSets != nil {
		mmAddQuestionToSets.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionToSets mock is already set by Set")
	}

	if mmAddQuestionToSets.defaultExpectation == nil {
		mmAddQuestionToSets.defaultExpectation = &QuestionSetRepositoryMockAddQuestionToSetsExpectation{}
	}

	if mmAddQuestionToSets.defaultExpectation.params != nil {
		mmAddQuestionToSets.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionToSets mock is already set by Expect")
	}

	if mmAddQuestionToSets.defaultExpectation.paramPtrs == nil {
		mmAddQuestionToSets.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockAddQuestionToSetsParamPtrs{}
	}
	mmAddQuestionToSets.defaultExpectation.paramPtrs.questionID = &questionID
	mmAddQuestionToSets.defaultExpectation.expectationOrigins.originQuestionID = minimock.CallerInfo(1)

	return mmAddQuestionToSets
}

// ExpectSetIDsParam3 sets up expected param setIDs for QuestionSetRepository.AddQuestionToSets
func (mmAddQuestionToSets *mQuestionSetRepositoryMockAddQuestionToSets) ExpectSetIDsParam3(setIDs []int64) *mQuestionSetRepositoryMockAddQuestionToSets {
	if mmAddQuestionToSets.mock.funcAddQuestionToSets != nil {
		mmAddQuestionToSets.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionToSets mock is already set by Set")
	}

	if mmAddQuestionToSets.defaultExpectation == nil {
		mmAddQuestionToSets.defaultExpectation = &QuestionSetRepositoryMockAddQuestionToSetsExpectation{}
	}

	if mmAddQuestionToSets.defaultExpectation.params != nil {
		mmAddQuestionToSets.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionToSets mock is already set by Expect")
	}

	if mmAddQuestionToSets.defaultExpectation.paramPtrs == nil {
		mmAddQuestionToSets.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockAddQuestionToSetsParamPtrs{}
	}
	mmAddQuestionToSets.defaultExpectation.paramPtrs.setIDs = &setIDs
	mmAddQuestionToSets.defaultExpectation.expectationOrigins.originSetIDs = minimock.CallerInfo(1)

	return mmAddQuestionToSets
}

// Inspect accepts an inspector function that has same arguments as the QuestionSetRepository.AddQuestionToSets
func (mmAddQuestionToSets *mQuestionSetRepositoryMockAddQuestionToSets) Inspect(f func(ctx context.Context, questionID int64, setIDs []int64)) *mQuestionSetRepositoryMockAddQuestionToSets {
	if mmAddQuestionToSets.mock.inspectFuncAddQuestionToSets != nil {
		mmAddQuestionToSets.mock.t.Fatalf("Inspect function is already set for QuestionSetRepositoryMock.AddQuestionToSets")
	}

	mmAddQuestionToSets.mock.inspectFuncAddQuestionToSets = f

	return mmAddQuestionToSets
}

// Return sets up results that will be returned by QuestionSetRepository.AddQuestionToSets
func (mmAddQuestionToSets *mQuestionSetRepositoryMockAddQuestionToSets) Return(err error) *QuestionSetRepositoryMock {
	if mmAddQuestionToSets.mock.funcAddQuestionToSets != nil {
		mmAddQuestionToSets.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionToSets mock is already set by Set")
	}

	if mmAddQuestionToSets.defaultExpectation == nil {
		mmAddQuestionToSets.defaultExpectation = &QuestionSetRepositoryMockAddQuestionToSetsExpectation{mock: mmAddQuestionToSets.mock}
	}
	mmAddQuestionToSets.defaultExpectation.results = &QuestionSetRepositoryMockAddQuestionToSetsResults{err}
	mmAddQuestionToSets.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddQuestionToSets.mock
}

// Set uses given function f to mock the QuestionSetRepository.AddQuestionToSets method
func (mmAddQuestionToSets *mQuestionSetRepositoryMockAddQuestionToSets) Set(f func(ctx context.Context, questionID int64, setIDs []int64) (err error)) *QuestionSetRepositoryMock {
	if mmAddQuestionToSets.defaultExpectation != nil {
		mmAddQuestionToSets.mock.t.Fatalf("Default expectation is already set for the QuestionSetRepository.AddQuestionToSets method")
	}

	if len(mmAddQuestionToSets.expectations) > 0 {
		mmAddQuestionToSets.mock.t.Fatalf("Some expectations are already set for the QuestionSetRepository.AddQuestionToSets method")
	}

	mmAddQuestionToSets.mock.funcAddQuestionToSets = f
	mmAddQuestionToSets.mock.funcAddQuestionToSetsOrigin = minimock.CallerInfo(1)
	return mmAddQuestionToSets.mock
}

// When sets expectation for the QuestionSetRepository.AddQuestionToSets which will trigger the result defined by the following
// Then helper
func (mmAddQuestionToSets *mQuestionSetRepositoryMockAddQuestionToSets) When(ctx context.Context, questionID int64, setIDs []int64) *QuestionSetRepositoryMockAddQuestionToSetsExpectation {
	if mmAddQuestionToSets.mock.funcAddQuestionToSets != nil {
		mmAddQuestionToSets.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionToSets mock is already set by Set")
	}

	expectation := &QuestionSetRepositoryMockAddQuestionToSetsExpectation{
		mock:               mmAddQuestionToSets.mock,
		params:             &QuestionSetRepositoryMockAddQuestionToSetsParams{ctx, questionID, setIDs},
		expectationOrigins: QuestionSetRepositoryMockAddQuestionToSetsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddQuestionToSets.expectations = append(mmAddQuestionToSets.expectations, expectation)
	return expectation
}

// Then sets up QuestionSetRepository.AddQuestionToSets return parameters for the expectation previously defined by the When method
func (e *QuestionSetRepositoryMockAddQuestionToSetsExpectation) Then(err error) *QuestionSetRepositoryMock {
	e.results = &QuestionSetRepositoryMockAddQuestionToSetsResults{err}
	return e.mock
}

// Times sets number of times QuestionSetRepository.AddQuestionToSets should be invoked
func (mmAddQuestionToSets *mQuestionSetRepositoryMockAddQuestionToSets) Times(n uint64) *mQuestionSetRepositoryMockAddQuestionToSets {
	if n == 0 {
		mmAddQuestionToSets.mock.t.Fatalf("Times of QuestionSetRepositoryMock.AddQuestionToSets mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddQuestionToSets.expectedInvocations, n)
	mmAddQuestionToSets.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddQuestionToSets
}

func (mmAddQuestionToSets *mQuestionSetRepositoryMockAddQuestionToSets) invocationsDone() bool {
	if len(mmAddQuestionToSets.expectations) == 0 && mmAddQuestionToSets.defaultExpectation == nil && mmAddQuestionToSets.mock.funcAddQuestionToSets == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddQuestionToSets.mock.afterAddQuestionToSetsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddQuestionToSets.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddQuestionToSets implements mm_repository.QuestionSetRepository
func (mmAddQuestionToSets *QuestionSetRepositoryMock) AddQuestionToSets(ctx context.Context, questionID int64, setIDs []int64) (err error) {
	mm_atomic.AddUint64(&mmAddQuestionToSets.beforeAddQuestionToSetsCounter, 1)
	defer mm_atomic.AddUint64(&mmAddQuestionToSets.afterAddQuestionToSetsCounter, 1)

	mmAddQuestionToSets.t.Helper()

	if mmAddQuestionToSets.inspectFuncAddQuestionToSets != nil {
		mmAddQuestionToSets.inspectFuncAddQuestionToSets(ctx, questionID, setIDs)
	}

	mm_params := QuestionSetRepositoryMockAddQuestionToSetsParams{ctx, questionID, setIDs}

	// Record call args
	mmAddQuestionToSets.AddQuestionToSetsMock.mutex.Lock()
	mmAddQuestionToSets.AddQuestionToSetsMock.callArgs = append(mmAddQuestionToSets.AddQuestionToSetsMock.callArgs, &mm_params)
	mmAddQuestionToSets.AddQuestionToSetsMock.mutex.Unlock()

	for _, e := range mmAddQuestionToSets.AddQuestionToSetsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddQuestionToSets.AddQuestionToSetsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddQuestionToSets.AddQuestionToSetsMock.defaultExpectation.Counter, 1)
		mm_want := mmAddQuestionToSets.AddQuestionToSetsMock.defaultExpectation.params
		mm_want_ptrs := mmAddQuestionToSets.AddQuestionToSetsMock.defaultExpectation.paramPtrs

		mm_got := QuestionSetRepositoryMockAddQuestionToSetsParams{ctx, questionID, setIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddQuestionToSets.t.Errorf("QuestionSetRepositoryMock.AddQuestionToSets got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddQuestionToSets.AddQuestionToSetsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.questionID != nil && !minimock.Equal(*mm_want_ptrs.questionID, mm_got.questionID) {
				mmAddQuestionToSets.t.Errorf("QuestionSetRepositoryMock.AddQuestionToSets got unexpected parameter questionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddQuestionToSets.AddQuestionToSetsMock.defaultExpectation.expectationOrigins.originQuestionID, *mm_want_ptrs.questionID, mm_got.questionID, minimock.Diff(*mm_want_ptrs.questionID, mm_got.questionID))
			}

			if mm_want_ptrs.setIDs != nil && !minimock.Equal(*mm_want_ptrs.setIDs, mm_got.setIDs) {
				mmAddQuestionToSets.t.Errorf("QuestionSetRepositoryMock.AddQuestionToSets got unexpected parameter setIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddQuestionToSets.AddQuestionToSetsMock.defaultExpectation.expectationOrigins.originSetIDs, *mm_want_ptrs.setIDs, mm_got.setIDs, minimock.Diff(*mm_want_ptrs.setIDs, mm_got.setIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddQuestionToSets.t.Errorf("QuestionSetRepositoryMock.AddQuestionToSets got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddQuestionToSets.AddQuestionToSetsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddQuestionToSets.AddQuestionToSetsMock.defaultExpectation.results
		if mm_results == nil {
			mmAddQuestionToSets.t.Fatal("No results are set for the QuestionSetRepositoryMock.AddQuestionToSets")
		}
		return (*mm_results).err
	}
	if mmAddQuestionToSets.funcAddQuestionToSets != nil {
		return mmAddQuestionToSets.funcAddQuestionToSets(ctx, questionID, setIDs)
	}
	mmAddQuestionToSets.t.Fatalf("Unexpected call to QuestionSetRepositoryMock.AddQuestionToSets. %v %v %v", ctx, questionID, setIDs)
	return
}

// AddQuestionToSetsAfterCounter returns a count of finished QuestionSetRepositoryMock.AddQuestionToSets invocations
func (mmAddQuestionToSets *QuestionSetRepositoryMock) AddQuestionToSetsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddQuestionToSets.afterAddQuestionToSetsCounter)
}

// AddQuestionToSetsBeforeCounter returns a count of QuestionSetRepositoryMock.AddQuestionToSets invocations
func (mmAddQuestionToSets *QuestionSetRepositoryMock) AddQuestionToSetsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddQuestionToSets.beforeAddQuestionToSetsCounter)
}

// Calls returns a list of arguments used in each call to QuestionSetRepositoryMock.AddQuestionToSets.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddQuestionToSets *mQuestionSetRepositoryMockAddQuestionToSets) Calls() []*QuestionSetRepositoryMockAddQuestionToSetsParams {
	mmAddQuestionToSets.mutex.RLock()

	argCopy := make([]*QuestionSetRepositoryMockAddQuestionToSetsParams, len(mmAddQuestionToSets.callArgs))
	copy(argCopy, mmAddQuestionToSets.callArgs)

	mmAddQuestionToSets.mutex.RUnlock()

	return argCopy
}

// MinimockAddQuestionToSetsDone returns true if the count of the AddQuestionToSets invocations corresponds
// the number of defined expectations
func (m *QuestionSetRepositoryMock) MinimockAddQuestionToSetsDone() bool {
	if m.AddQuestionToSetsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddQuestionToSetsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddQuestionToSetsMock.invocationsDone()
}

// MinimockAddQuestionToSetsInspect logs each unmet expectation
func (m *QuestionSetRepositoryMock) MinimockAddQuestionToSetsInspect() {
	for _, e := range m.AddQuestionToSetsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.AddQuestionToSets at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddQuestionToSetsCounter := mm_atomic.LoadUint64(&m.afterAddQuestionToSetsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddQuestionToSetsMock.defaultExpectation != nil && afterAddQuestionToSetsCounter < 1 {
		if m.AddQuestionToSetsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.AddQuestionToSets at\n%s", m.AddQuestionToSetsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.AddQuestionToSets at\n%s with params: %#v", m.AddQuestionToSetsMock.defaultExpectation.expectationOrigins.origin, *m.AddQuestionToSetsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddQuestionToSets != nil && afterAddQuestionToSetsCounter < 1 {
		m.t.Errorf("Expected call to QuestionSetRepositoryMock.AddQuestionToSets at\n%s", m.funcAddQuestionToSetsOrigin)
	}

	if !m.AddQuestionToSetsMock.invocationsDone() && afterAddQuestionToSetsCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSetRepositoryMock.AddQuestionToSets at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddQuestionToSetsMock.expectedInvocations), m.AddQuestionToSetsMock.expectedInvocationsOrigin, afterAddQuestionToSetsCounter)
	}
}

type mQuestionSetRepositoryMockAddQuestionsToSet struct {
	optional           bool
	mock               *QuestionSetRepositoryMock
	defaultExpectation *QuestionSetRepositoryMockAddQuestionsToSetExpectation
	expectations       []*QuestionSetRepositoryMockAddQuestionsToSetExpectation

	callArgs []*QuestionSetRepositoryMockAddQuestionsToSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSetRepositoryMockAddQuestionsToSetExpectation specifies expectation struct of the QuestionSetRepository.AddQuestionsToSet
type QuestionSetRepositoryMockAddQuestionsToSetExpectation struct {
	mock               *QuestionSetRepositoryMock
	params             *QuestionSetRepositoryMockAddQuestionsToSetParams
	paramPtrs          *QuestionSetRepositoryMockAddQuestionsToSetParamPtrs
	expectationOrigins QuestionSetRepositoryMockAddQuestionsToSetExpectationOrigins
	results            *QuestionSetRepositoryMockAddQuestionsToSetResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSetRepositoryMockAddQuestionsToSetParams contains parameters of the QuestionSetRepository.AddQuestionsToSet
type QuestionSetRepositoryMockAddQuestionsToSetParams struct {
	ctx         context.Context
	setID       int64
	questionIDs []int64
}

// QuestionSetRepositoryMockAddQuestionsToSetParamPtrs contains pointers to parameters of the QuestionSetRepository.AddQuestionsToSet
type QuestionSetRepositoryMockAddQuestionsToSetParamPtrs struct {
	ctx         *context.Context
	setID       *int64
	questionIDs *[]int64
}

// QuestionSetRepositoryMockAddQuestionsToSetResults contains results of the QuestionSetRepository.AddQuestionsToSet
type QuestionSetRepositoryMockAddQuestionsToSetResults struct {
	err error
}

// QuestionSetRepositoryMockAddQuestionsToSetOrigins contains origins of expectations of the QuestionSetRepository.AddQuestionsToSet
type QuestionSetRepositoryMockAddQuestionsToSetExpectationOrigins struct {
	origin            string
	originCtx         string
	originSetID       string
	originQuestionIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddQuestionsToSet *mQuestionSetRepositoryMockAddQuestionsToSet) Optional() *mQuestionSetRepositoryMockAddQuestionsToSet {
	mmAddQuestionsToSet.optional = true
	return mmAddQuestionsToSet
}

// Expect sets up expected params for QuestionSetRepository.AddQuestionsToSet
func (mmAddQuestionsToSet *mQuestionSetRepositoryMockAddQuestionsToSet) Expect(ctx context.Context, setID int64, questionIDs []int64) *mQuestionSetRepositoryMockAddQuestionsToSet {
	if mmAddQuestionsToSet.mock.funcAddQuestionsToSet != nil {
		mmAddQuestionsToSet.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionsToSet mock is already set by Set")
	}

	if mmAddQuestionsToSet.defaultExpectation == nil {
		mmAddQuestionsToSet.defaultExpectation = &QuestionSetRepositoryMockAddQuestionsToSetExpectation{}
	}

	if mmAddQuestionsToSet.defaultExpectation.paramPtrs != nil {
		mmAddQuestionsToSet.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionsToSet mock is already set by ExpectParams functions")
	}

	mmAddQuestionsToSet.defaultExpectation.params = &QuestionSetRepositoryMockAddQuestionsToSetParams{ctx, setID, questionIDs}
	mmAddQuestionsToSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddQuestionsToSet.expectations {
		if minimock.Equal(e.params, mmAddQuestionsToSet.defaultExpectation.params) {
			mmAddQuestionsToSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddQuestionsToSet.defaultExpectation.params)
		}
	}

	return mmAddQuestionsToSet
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSetRepository.AddQuestionsToSet
func (mmAddQuestionsToSet *mQuestionSetRepositoryMockAddQuestionsToSet) ExpectCtxParam1(ctx context.Context) *mQuestionSetRepositoryMockAddQuestionsToSet {
	if mmAddQuestionsToSet.mock.funcAddQuestionsToSet != nil {
		mmAddQuestionsToSet.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionsToSet mock is already set by Set")
	}

	if mmAddQuestionsToSet.defaultExpectation == nil {
		mmAddQuestionsToSet.defaultExpectation = &QuestionSetRepositoryMockAddQuestionsToSetExpectation{}
	}

	if mmAddQuestionsToSet.defaultExpectation.params != nil {
		mmAddQuestionsToSet.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionsToSet mock is already set by Expect")
	}

	if mmAddQuestionsToSet.defaultExpectation.paramPtrs == nil {
		mmAddQuestionsToSet.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockAddQuestionsToSetParamPtrs{}
	}
	mmAddQuestionsToSet.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddQuestionsToSet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddQuestionsToSet
}

// ExpectSetIDParam2 sets up expected param setID for QuestionSetRepository.AddQuestionsToSet
func (mmAddQuestionsToSet *mQuestionSetRepositoryMockAddQuestionsToSet) ExpectSetIDParam2(setID int64) *mQuestionSetRepositoryMockAddQuestionsToSet {
	if mmAddQuestionsToSet.mock.funcAddQuestionsToSet != nil {
		mmAddQuestionsToSet.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionsToSet mock is already set by Set")
	}

	if mmAddQuestionsToSet.defaultExpectation == nil {
		mmAddQuestionsToSet.defaultExpectation = &QuestionSetRepositoryMockAddQuestionsToSetExpectation{}
	}

	if mmAddQuestionsToSet.defaultExpectation.params != nil {
		mmAddQuestionsToSet.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionsToSet mock is already set by Expect")
	}

	if mmAddQuestionsToSet.defaultExpectation.paramPtrs == nil {
		mmAddQuestionsToSet.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockAddQuestionsToSetParamPtrs{}
	}
	mmAddQuestionsToSet.defaultExpectation.paramPtrs.setID = &setID
	mmAddQuestionsToSet.defaultExpectation.expectationOrigins.originSetID = minimock.CallerInfo(1)

	return mmAddQuestionsToSet
}

// ExpectQuestionIDsParam3 sets up expected param questionIDs for QuestionSetRepository.AddQuestionsToSet
func (mmAddQuestionsToSet *mQuestionSetRepositoryMockAddQuestionsToSet) ExpectQuestionIDsParam3(questionIDs []int64) *mQuestionSetRepositoryMockAddQuestionsToSet {
	if mmAddQuestionsToSet.mock.funcAddQuestionsToSet != nil {
		mmAddQuestionsToSet.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionsToSet mock is already set by Set")
	}

	if mmAddQuestionsToSet.defaultExpectation == nil {
		mmAddQuestionsToSet.defaultExpectation = &QuestionSetRepositoryMockAddQuestionsToSetExpectation{}
	}

	if mmAddQuestionsToSet.defaultExpectation.params != nil {
		mmAddQuestionsToSet.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionsToSet mock is already set by Expect")
	}

	if mmAddQuestionsToSet.defaultExpectation.paramPtrs == nil {
		mmAddQuestionsToSet.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockAddQuestionsToSetParamPtrs{}
	}
	mmAddQuestionsToSet.defaultExpectation.paramPtrs.questionIDs = &questionIDs
	mmAddQuestionsToSet.defaultExpectation.expectationOrigins.originQuestionIDs = minimock.CallerInfo(1)

	return mmAddQuestionsToSet
}

// Inspect accepts an inspector function that has same arguments as the QuestionSetRepository.AddQuestionsToSet
func (mmAddQuestionsToSet *mQuestionSetRepositoryMockAddQuestionsToSet) Inspect(f func(ctx context.Context, setID int64, questionIDs []int64)) *mQuestionSetRepositoryMockAddQuestionsToSet {
	if mmAddQuestionsToSet.mock.inspectFuncAddQuestionsToSet != nil {
		mmAddQuestionsToSet.mock.t.Fatalf("Inspect function is already set for QuestionSetRepositoryMock.AddQuestionsToSet")
	}

	mmAddQuestionsToSet.mock.inspectFuncAddQuestionsToSet = f

	return mmAddQuestionsToSet
}

// Return sets up results that will be returned by QuestionSetRepository.AddQuestionsToSet
func (mmAddQuestionsToSet *mQuestionSetRepositoryMockAddQuestionsToSet) Return(err error) *QuestionSetRepositoryMock {
	if mmAddQuestionsToSet.mock.funcAddQuestionsToSet != nil {
		mmAddQuestionsToSet.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionsToSet mock is already set by Set")
	}

	if mmAddQuestionsToSet.defaultExpectation == nil {
		mmAddQuestionsToSet.defaultExpectation = &QuestionSetRepositoryMockAddQuestionsToSetExpectation{mock: mmAddQuestionsToSet.mock}
	}
	mmAddQuestionsToSet.defaultExpectation.results = &QuestionSetRepositoryMockAddQuestionsToSetResults{err}
	mmAddQuestionsToSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddQuestionsToSet.mock
}

// Set uses given function f to mock the QuestionSetRepository.AddQuestionsToSet method
func (mmAddQuestionsToSet *mQuestionSetRepositoryMockAddQuestionsToSet) Set(f func(ctx context.Context, setID int64, questionIDs []int64) (err error)) *QuestionSetRepositoryMock {
	if mmAddQuestionsToSet.defaultExpectation != nil {
		mmAddQuestionsToSet.mock.t.Fatalf("Default expectation is already set for the QuestionSetRepository.AddQuestionsToSet method")
	}

	if len(mmAddQuestionsToSet.expectations) > 0 {
		mmAddQuestionsToSet.mock.t.Fatalf("Some expectations are already set for the QuestionSetRepository.AddQuestionsToSet method")
	}

	mmAddQuestionsToSet.mock.funcAddQuestionsToSet = f
	mmAddQuestionsToSet.mock.funcAddQuestionsToSetOrigin = minimock.CallerInfo(1)
	return mmAddQuestionsToSet.mock
}

// When sets expectation for the QuestionSetRepository.AddQuestionsToSet which will trigger the result defined by the following
// Then helper
func (mmAddQuestionsToSet *mQuestionSetRepositoryMockAddQuestionsToSet) When(ctx context.Context, setID int64, questionIDs []int64) *QuestionSetRepositoryMockAddQuestionsToSetExpectation {
	if mmAddQuestionsToSet.mock.funcAddQuestionsToSet != nil {
		mmAddQuestionsToSet.mock.t.Fatalf("QuestionSetRepositoryMock.AddQuestionsToSet mock is already set by Set")
	}

	expectation := &QuestionSetRepositoryMockAddQuestionsToSetExpectation{
		mock:               mmAddQuestionsToSet.mock,
		params:             &QuestionSetRepositoryMockAddQuestionsToSetParams{ctx, setID, questionIDs},
		expectationOrigins: QuestionSetRepositoryMockAddQuestionsToSetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddQuestionsToSet.expectations = append(mmAddQuestionsToSet.expectations, expectation)
	return expectation
}

// Then sets up QuestionSetRepository.AddQuestionsToSet return parameters for the expectation previously defined by the When method
func (e *QuestionSetRepositoryMockAddQuestionsToSetExpectation) Then(err error) *QuestionSetRepositoryMock {
	e.results = &QuestionSetRepositoryMockAddQuestionsToSetResults{err}
	return e.mock
}

// Times sets number of times QuestionSetRepository.AddQuestionsToSet should be invoked
func (mmAddQuestionsToSet *mQuestionSetRepositoryMockAddQuestionsToSet) Times(n uint64) *mQuestionSetRepositoryMockAddQuestionsToSet {
	if n == 0 {
		mmAddQuestionsToSet.mock.t.Fatalf("Times of QuestionSetRepositoryMock.AddQuestionsToSet mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddQuestionsToSet.expectedInvocations, n)
	mmAddQuestionsToSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddQuestionsToSet
}

func (mmAddQuestionsToSet *mQuestionSetRepositoryMockAddQuestionsToSet) invocationsDone() bool {
	if len(mmAddQuestionsToSet.expectations) == 0 && mmAddQuestionsToSet.defaultExpectation == nil && mmAddQuestionsToSet.mock.funcAddQuestionsToSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddQuestionsToSet.mock.afterAddQuestionsToSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddQuestionsToSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddQuestionsToSet implements mm_repository.QuestionSetRepository
func (mmAddQuestionsToSet *QuestionSetRepositoryMock) AddQuestionsToSet(ctx context.Context, setID int64, questionIDs []int64) (err error) {
	mm_atomic.AddUint64(&mmAddQuestionsToSet.beforeAddQuestionsToSetCounter, 1)
	defer mm_atomic.AddUint64(&mmAddQuestionsToSet.afterAddQuestionsToSetCounter, 1)

	mmAddQuestionsToSet.t.Helper()

	if mmAddQuestionsToSet.inspectFuncAddQuestionsToSet != nil {
		mmAddQuestionsToSet.inspectFuncAddQuestionsToSet(ctx, setID, questionIDs)
	}

	mm_params := QuestionSetRepositoryMockAddQuestionsToSetParams{ctx, setID, questionIDs}

	// Record call args
	mmAddQuestionsToSet.AddQuestionsToSetMock.mutex.Lock()
	mmAddQuestionsToSet.AddQuestionsToSetMock.callArgs = append(mmAddQuestionsToSet.AddQuestionsToSetMock.callArgs, &mm_params)
	mmAddQuestionsToSet.AddQuestionsToSetMock.mutex.Unlock()

	for _, e := range mmAddQuestionsToSet.AddQuestionsToSetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddQuestionsToSet.AddQuestionsToSetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddQuestionsToSet.AddQuestionsToSetMock.defaultExpectation.Counter, 1)
		mm_want := mmAddQuestionsToSet.AddQuestionsToSetMock.defaultExpectation.params
		mm_want_ptrs := mmAddQuestionsToSet.AddQuestionsToSetMock.defaultExpectation.paramPtrs

		mm_got := QuestionSetRepositoryMockAddQuestionsToSetParams{ctx, setID, questionIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddQuestionsToSet.t.Errorf("QuestionSetRepositoryMock.AddQuestionsToSet got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddQuestionsToSet.AddQuestionsToSetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.setID != nil && !minimock.Equal(*mm_want_ptrs.setID, mm_got.setID) {
				mmAddQuestionsToSet.t.Errorf("QuestionSetRepositoryMock.AddQuestionsToSet got unexpected parameter setID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddQuestionsToSet.AddQuestionsToSetMock.defaultExpectation.expectationOrigins.originSetID, *mm_want_ptrs.setID, mm_got.setID, minimock.Diff(*mm_want_ptrs.setID, mm_got.setID))
			}

			if mm_want_ptrs.questionIDs != nil && !minimock.Equal(*mm_want_ptrs.questionIDs, mm_got.questionIDs) {
				mmAddQuestionsToSet.t.Errorf("QuestionSetRepositoryMock.AddQuestionsToSet got unexpected parameter questionIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddQuestionsToSet.AddQuestionsToSetMock.defaultExpectation.expectationOrigins.originQuestionIDs, *mm_want_ptrs.questionIDs, mm_got.questionIDs, minimock.Diff(*mm_want_ptrs.questionIDs, mm_got.questionIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddQuestionsToSet.t.Errorf("QuestionSetRepositoryMock.AddQuestionsToSet got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddQuestionsToSet.AddQuestionsToSetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddQuestionsToSet.AddQuestionsToSetMock.defaultExpectation.results
		if mm_results == nil {
			mmAddQuestionsToSet.t.Fatal("No results are set for the QuestionSetRepositoryMock.AddQuestionsToSet")
		}
		return (*mm_results).err
	}
	if mmAddQuestionsToSet.funcAddQuestionsToSet != nil {
		return mmAddQuestionsToSet.funcAddQuestionsToSet(ctx, setID, questionIDs)
	}
	mmAddQuestionsToSet.t.Fatalf("Unexpected call to QuestionSetRepositoryMock.AddQuestionsToSet. %v %v %v", ctx, setID, questionIDs)
	return
}

// AddQuestionsToSetAfterCounter returns a count of finished QuestionSetRepositoryMock.AddQuestionsToSet invocations
func (mmAddQuestionsToSet *QuestionSetRepositoryMock) AddQuestionsToSetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddQuestionsToSet.afterAddQuestionsToSetCounter)
}

// AddQuestionsToSetBeforeCounter returns a count of QuestionSetRepositoryMock.AddQuestionsToSet invocations
func (mmAddQuestionsToSet *QuestionSetRepositoryMock) AddQuestionsToSetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddQuestionsToSet.beforeAddQuestionsToSetCounter)
}

// Calls returns a list of arguments used in each call to QuestionSetRepositoryMock.AddQuestionsToSet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddQuestionsToSet *mQuestionSetRepositoryMockAddQuestionsToSet) Calls() []*QuestionSetRepositoryMockAddQuestionsToSetParams {
	mmAddQuestionsToSet.mutex.RLock()

	argCopy := make([]*QuestionSetRepositoryMockAddQuestionsToSetParams, len(mmAddQuestionsToSet.callArgs))
	copy(argCopy, mmAddQuestionsToSet.callArgs)

	mmAddQuestionsToSet.mutex.RUnlock()

	return argCopy
}

// MinimockAddQuestionsToSetDone returns true if the count of the AddQuestionsToSet invocations corresponds
// the number of defined expectations
func (m *QuestionSetRepositoryMock) MinimockAddQuestionsToSetDone() bool {
	if m.AddQuestionsToSetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddQuestionsToSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddQuestionsToSetMock.invocationsDone()
}

// MinimockAddQuestionsToSetInspect logs each unmet expectation
func (m *QuestionSetRepositoryMock) MinimockAddQuestionsToSetInspect() {
	for _, e := range m.AddQuestionsToSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.AddQuestionsToSet at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddQuestionsToSetCounter := mm_atomic.LoadUint64(&m.afterAddQuestionsToSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddQuestionsToSetMock.defaultExpectation != nil && afterAddQuestionsToSetCounter < 1 {
		if m.AddQuestionsToSetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.AddQuestionsToSet at\n%s", m.AddQuestionsToSetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.AddQuestionsToSet at\n%s with params: %#v", m.AddQuestionsToSetMock.defaultExpectation.expectationOrigins.origin, *m.AddQuestionsToSetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddQuestionsToSet != nil && afterAddQuestionsToSetCounter < 1 {
		m.t.Errorf("Expected call to QuestionSetRepositoryMock.AddQuestionsToSet at\n%s", m.funcAddQuestionsToSetOrigin)
	}

	if !m.AddQuestionsToSetMock.invocationsDone() && afterAddQuestionsToSetCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSetRepositoryMock.AddQuestionsToSet at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddQuestionsToSetMock.expectedInvocations), m.AddQuestionsToSetMock.expectedInvocationsOrigin, afterAddQuestionsToSetCounter)
	}
}

type mQuestionSetRepositoryMockListQuestionIDsBySetID struct {
	optional           bool
	mock               *QuestionSetRepositoryMock
	defaultExpectation *QuestionSetRepositoryMockListQuestionIDsBySetIDExpectation
	expectations       []*QuestionSetRepositoryMockListQuestionIDsBySetIDExpectation

	callArgs []*QuestionSetRepositoryMockListQuestionIDsBySetIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSetRepositoryMockListQuestionIDsBySetIDExpectation specifies expectation struct of the QuestionSetRepository.ListQuestionIDsBySetID
type QuestionSetRepositoryMockListQuestionIDsBySetIDExpectation struct {
	mock               *QuestionSetRepositoryMock
	params             *QuestionSetRepositoryMockListQuestionIDsBySetIDParams
	paramPtrs          *QuestionSetRepositoryMockListQuestionIDsBySetIDParamPtrs
	expectationOrigins QuestionSetRepositoryMockListQuestionIDsBySetIDExpectationOrigins
	results            *QuestionSetRepositoryMockListQuestionIDsBySetIDResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSetRepositoryMockListQuestionIDsBySetIDParams contains parameters of the QuestionSetRepository.ListQuestionIDsBySetID
type QuestionSetRepositoryMockListQuestionIDsBySetIDParams struct {
	ctx   context.Context
	setID int64
}

// QuestionSetRepositoryMockListQuestionIDsBySetIDParamPtrs contains pointers to parameters of the QuestionSetRepository.ListQuestionIDsBySetID
type QuestionSetRepositoryMockListQuestionIDsBySetIDParamPtrs struct {
	ctx   *context.Context
	setID *int64
}

// QuestionSetRepositoryMockListQuestionIDsBySetIDResults contains results of the QuestionSetRepository.ListQuestionIDsBySetID
type QuestionSetRepositoryMockListQuestionIDsBySetIDResults struct {
	ia1 []int64
	err error
}

// QuestionSetRepositoryMockListQuestionIDsBySetIDOrigins contains origins of expectations of the QuestionSetRepository.ListQuestionIDsBySetID
type QuestionSetRepositoryMockListQuestionIDsBySetIDExpectationOrigins struct {
	origin      string
	originCtx   string
	originSetID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListQuestionIDsBySetID *mQuestionSetRepositoryMockListQuestionIDsBySetID) Optional() *mQuestionSetRepositoryMockListQuestionIDsBySetID {
	mmListQuestionIDsBySetID.optional = true
	return mmListQuestionIDsBySetID
}

// Expect sets up expected params for QuestionSetRepository.ListQuestionIDsBySetID
func (mmListQuestionIDsBySetID *mQuestionSetRepositoryMockListQuestionIDsBySetID) Expect(ctx context.Context, setID int64) *mQuestionSetRepositoryMockListQuestionIDsBySetID {
	if mmListQuestionIDsBySetID.mock.funcListQuestionIDsBySetID != nil {
		mmListQuestionIDsBySetID.mock.t.Fatalf("QuestionSetRepositoryMock.ListQuestionIDsBySetID mock is already set by Set")
	}

	if mmListQuestionIDsBySetID.defaultExpectation == nil {
		mmListQuestionIDsBySetID.defaultExpectation = &QuestionSetRepositoryMockListQuestionIDsBySetIDExpectation{}
	}

	if mmListQuestionIDsBySetID.defaultExpectation.paramPtrs != nil {
		mmListQuestionIDsBySetID.mock.t.Fatalf("QuestionSetRepositoryMock.ListQuestionIDsBySetID mock is already set by ExpectParams functions")
	}

	mmListQuestionIDsBySetID.defaultExpectation.params = &QuestionSetRepositoryMockListQuestionIDsBySetIDParams{ctx, setID}
	mmListQuestionIDsBySetID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListQuestionIDsBySetID.expectations {
		if minimock.Equal(e.params, mmListQuestionIDsBySetID.defaultExpectation.params) {
			mmListQuestionIDsBySetID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListQuestionIDsBySetID.defaultExpectation.params)
		}
	}

	return mmListQuestionIDsBySetID
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSetRepository.ListQuestionIDsBySetID
func (mmListQuestionIDsBySetID *mQuestionSetRepositoryMockListQuestionIDsBySetID) ExpectCtxParam1(ctx context.Context) *mQuestionSetRepositoryMockListQuestionIDsBySetID {
	if mmListQuestionIDsBySetID.mock.funcListQuestionIDsBySetID != nil {
		mmListQuestionIDsBySetID.mock.t.Fatalf("QuestionSetRepositoryMock.ListQuestionIDsBySetID mock is already set by Set")
	}

	if mmListQuestionIDsBySetID.defaultExpectation == nil {
		mmListQuestionIDsBySetID.defaultExpectation = &QuestionSetRepositoryMockListQuestionIDsBySetIDExpectation{}
	}

	if mmListQuestionIDsBySetID.defaultExpectation.params != nil {
		mmListQuestionIDsBySetID.mock.t.Fatalf("QuestionSetRepositoryMock.ListQuestionIDsBySetID mock is already set by Expect")
	}

	if mmListQuestionIDsBySetID.defaultExpectation.paramPtrs == nil {
		mmListQuestionIDsBySetID.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockListQuestionIDsBySetIDParamPtrs{}
	}
	mmListQuestionIDsBySetID.defaultExpectation.paramPtrs.ctx = &ctx
	mmListQuestionIDsBySetID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListQuestionIDsBySetID
}

// ExpectSetIDParam2 sets up expected param setID for QuestionSetRepository.ListQuestionIDsBySetID
func (mmListQuestionIDsBySetID *mQuestionSetRepositoryMockListQuestionIDsBySetID) ExpectSetIDParam2(setID int64) *mQuestionSetRepositoryMockListQuestionIDsBySetID {
	if mmListQuestionIDsBySetID.mock.funcListQuestionIDsBySetID != nil {
		mmListQuestionIDsBySetID.mock.t.Fatalf("QuestionSetRepositoryMock.ListQuestionIDsBySetID mock is already set by Set")
	}

	if mmListQuestionIDsBySetID.defaultExpectation == nil {
		mmListQuestionIDsBySetID.defaultExpectation = &QuestionSetRepositoryMockListQuestionIDsBySetIDExpectation{}
	}

	if mmListQuestionIDsBySetID.defaultExpectation.params != nil {
		mmListQuestionIDsBySetID.mock.t.Fatalf("QuestionSetRepositoryMock.ListQuestionIDsBySetID mock is already set by Expect")
	}

	if mmListQuestionIDsBySetID.defaultExpectation.paramPtrs == nil {
		mmListQuestionIDsBySetID.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockListQuestionIDsBySetIDParamPtrs{}
	}
	mmListQuestionIDsBySetID.defaultExpectation.paramPtrs.setID = &setID
	mmListQuestionIDsBySetID.defaultExpectation.expectationOrigins.originSetID = minimock.CallerInfo(1)

	return mmListQuestionIDsBySetID
}

// Inspect accepts an inspector function that has same arguments as the QuestionSetRepository.ListQuestionIDsBySetID
func (mmListQuestionIDsBySetID *mQuestionSetRepositoryMockListQuestionIDsBySetID) Inspect(f func(ctx context.Context, setID int64)) *mQuestionSetRepositoryMockListQuestionIDsBySetID {
	if mmListQuestionIDsBySetID.mock.inspectFuncListQuestionIDsBySetID != nil {
		mmListQuestionIDsBySetID.mock.t.Fatalf("Inspect function is already set for QuestionSetRepositoryMock.ListQuestionIDsBySetID")
	}

	mmListQuestionIDsBySetID.mock.inspectFuncListQuestionIDsBySetID = f

	return mmListQuestionIDsBySetID
}

// Return sets up results that will be returned by QuestionSetRepository.ListQuestionIDsBySetID
func (mmListQuestionIDsBySetID *mQuestionSetRepositoryMockListQuestionIDsBySetID) Return(ia1 []int64, err error) *QuestionSetRepositoryMock {
	if mmListQuestionIDsBySetID.mock.funcListQuestionIDsBySetID != nil {
		mmListQuestionIDsBySetID.mock.t.Fatalf("QuestionSetRepositoryMock.ListQuestionIDsBySetID mock is already set by Set")
	}

	if mmListQuestionIDsBySetID.defaultExpectation == nil {
		mmListQuestionIDsBySetID.defaultExpectation = &QuestionSetRepositoryMockListQuestionIDsBySetIDExpectation{mock: mmListQuestionIDsBySetID.mock}
	}
	mmListQuestionIDsBySetID.defaultExpectation.results = &QuestionSetRepositoryMockListQuestionIDsBySetIDResults{ia1, err}
	mmListQuestionIDsBySetID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListQuestionIDsBySetID.mock
}

// Set uses given function f to mock the QuestionSetRepository.ListQuestionIDsBySetID method
func (mmListQuestionIDsBySetID *mQuestionSetRepositoryMockListQuestionIDsBySetID) Set(f func(ctx context.Context, setID int64) (ia1 []int64, err error)) *QuestionSetRepositoryMock {
	if mmListQuestionIDsBySetID.defaultExpectation != nil {
		mmListQuestionIDsBySetID.mock.t.Fatalf("Default expectation is already set for the QuestionSetRepository.ListQuestionIDsBySetID method")
	}

	if len(mmListQuestionIDsBySetID.expectations) > 0 {
		mmListQuestionIDsBySetID.mock.t.Fatalf("Some expectations are already set for the QuestionSetRepository.ListQuestionIDsBySetID method")
	}

	mmListQuestionIDsBySetID.mock.funcListQuestionIDsBySetID = f
	mmListQuestionIDsBySetID.mock.funcListQuestionIDsBySetIDOrigin = minimock.CallerInfo(1)
	return mmListQuestionIDsBySetID.mock
}

// When sets expectation for the QuestionSetRepository.ListQuestionIDsBySetID which will trigger the result defined by the following
// Then helper
func (mmListQuestionIDsBySetID *mQuestionSetRepositoryMockListQuestionIDsBySetID) When(ctx context.Context, setID int64) *QuestionSetRepositoryMockListQuestionIDsBySetIDExpectation {
	if mmListQuestionIDsBySetID.mock.funcListQuestionIDsBySetID != nil {
		mmListQuestionIDsBySetID.mock.t.Fatalf("QuestionSetRepositoryMock.ListQuestionIDsBySetID mock is already set by Set")
	}

	expectation := &QuestionSetRepositoryMockListQuestionIDsBySetIDExpectation{
		mock:               mmListQuestionIDsBySetID.mock,
		params:             &QuestionSetRepositoryMockListQuestionIDsBySetIDParams{ctx, setID},
		expectationOrigins: QuestionSetRepositoryMockListQuestionIDsBySetIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListQuestionIDsBySetID.expectations = append(mmListQuestionIDsBySetID.expectations, expectation)
	return expectation
}

// Then sets up QuestionSetRepository.ListQuestionIDsBySetID return parameters for the expectation previously defined by the When method
func (e *QuestionSetRepositoryMockListQuestionIDsBySetIDExpectation) Then(ia1 []int64, err error) *QuestionSetRepositoryMock {
	e.results = &QuestionSetRepositoryMockListQuestionIDsBySetIDResults{ia1, err}
	return e.mock
}

// Times sets number of times QuestionSetRepository.ListQuestionIDsBySetID should be invoked
func (mmListQuestionIDsBySetID *mQuestionSetRepositoryMockListQuestionIDsBySetID) Times(n uint64) *mQuestionSetRepositoryMockListQuestionIDsBySetID {
	if n == 0 {
		mmListQuestionIDsBySetID.mock.t.Fatalf("Times of QuestionSetRepositoryMock.ListQuestionIDsBySetID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListQuestionIDsBySetID.expectedInvocations, n)
	mmListQuestionIDsBySetID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListQuestionIDsBySetID
}

func (mmListQuestionIDsBySetID *mQuestionSetRepositoryMockListQuestionIDsBySetID) invocationsDone() bool {
	if len(mmListQuestionIDsBySetID.expectations) == 0 && mmListQuestionIDsBySetID.defaultExpectation == nil && mmListQuestionIDsBySetID.mock.funcListQuestionIDsBySetID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListQuestionIDsBySetID.mock.afterListQuestionIDsBySetIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListQuestionIDsBySetID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListQuestionIDsBySetID implements mm_repository.QuestionSetRepository
func (mmListQuestionIDsBySetID *QuestionSetRepositoryMock) ListQuestionIDsBySetID(ctx context.Context, setID int64) (ia1 []int64, err error) {
	mm_atomic.AddUint64(&mmListQuestionIDsBySetID.beforeListQuestionIDsBySetIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListQuestionIDsBySetID.afterListQuestionIDsBySetIDCounter, 1)

	mmListQuestionIDsBySetID.t.Helper()

	if mmListQuestionIDsBySetID.inspectFuncListQuestionIDsBySetID != nil {
		mmListQuestionIDsBySetID.inspectFuncListQuestionIDsBySetID(ctx, setID)
	}

	mm_params := QuestionSetRepositoryMockListQuestionIDsBySetIDParams{ctx, setID}

	// Record call args
	mmListQuestionIDsBySetID.ListQuestionIDsBySetIDMock.mutex.Lock()
	mmListQuestionIDsBySetID.ListQuestionIDsBySetIDMock.callArgs = append(mmListQuestionIDsBySetID.ListQuestionIDsBySetIDMock.callArgs, &mm_params)
	mmListQuestionIDsBySetID.ListQuestionIDsBySetIDMock.mutex.Unlock()

	for _, e := range mmListQuestionIDsBySetID.ListQuestionIDsBySetIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmListQuestionIDsBySetID.ListQuestionIDsBySetIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListQuestionIDsBySetID.ListQuestionIDsBySetIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListQuestionIDsBySetID.ListQuestionIDsBySetIDMock.defaultExpectation.params
		mm_want_ptrs := mmListQuestionIDsBySetID.ListQuestionIDsBySetIDMock.defaultExpectation.paramPtrs

		mm_got := QuestionSetRepositoryMockListQuestionIDsBySetIDParams{ctx, setID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListQuestionIDsBySetID.t.Errorf("QuestionSetRepositoryMock.ListQuestionIDsBySetID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListQuestionIDsBySetID.ListQuestionIDsBySetIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.setID != nil && !minimock.Equal(*mm_want_ptrs.setID, mm_got.setID) {
				mmListQuestionIDsBySetID.t.Errorf("QuestionSetRepositoryMock.ListQuestionIDsBySetID got unexpected parameter setID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListQuestionIDsBySetID.ListQuestionIDsBySetIDMock.defaultExpectation.expectationOrigins.originSetID, *mm_want_ptrs.setID, mm_got.setID, minimock.Diff(*mm_want_ptrs.setID, mm_got.setID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListQuestionIDsBySetID.t.Errorf("QuestionSetRepositoryMock.ListQuestionIDsBySetID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListQuestionIDsBySetID.ListQuestionIDsBySetIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListQuestionIDsBySetID.ListQuestionIDsBySetIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListQuestionIDsBySetID.t.Fatal("No results are set for the QuestionSetRepositoryMock.ListQuestionIDsBySetID")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmListQuestionIDsBySetID.funcListQuestionIDsBySetID != nil {
		return mmListQuestionIDsBySetID.funcListQuestionIDsBySetID(ctx, setID)
	}
	mmListQuestionIDsBySetID.t.Fatalf("Unexpected call to QuestionSetRepositoryMock.ListQuestionIDsBySetID. %v %v", ctx, setID)
	return
}

// ListQuestionIDsBySetIDAfterCounter returns a count of finished QuestionSetRepositoryMock.ListQuestionIDsBySetID invocations
func (mmListQuestionIDsBySetID *QuestionSetRepositoryMock) ListQuestionIDsBySetIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListQuestionIDsBySetID.afterListQuestionIDsBySetIDCounter)
}

// ListQuestionIDsBySetIDBeforeCounter returns a count of QuestionSetRepositoryMock.ListQuestionIDsBySetID invocations
func (mmListQuestionIDsBySetID *QuestionSetRepositoryMock) ListQuestionIDsBySetIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListQuestionIDsBySetID.beforeListQuestionIDsBySetIDCounter)
}

// Calls returns a list of arguments used in each call to QuestionSetRepositoryMock.ListQuestionIDsBySetID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListQuestionIDsBySetID *mQuestionSetRepositoryMockListQuestionIDsBySetID) Calls() []*QuestionSetRepositoryMockListQuestionIDsBySetIDParams {
	mmListQuestionIDsBySetID.mutex.RLock()

	argCopy := make([]*QuestionSetRepositoryMockListQuestionIDsBySetIDParams, len(mmListQuestionIDsBySetID.callArgs))
	copy(argCopy, mmListQuestionIDsBySetID.callArgs)

	mmListQuestionIDsBySetID.mutex.RUnlock()

	return argCopy
}

// MinimockListQuestionIDsBySetIDDone returns true if the count of the ListQuestionIDsBySetID invocations corresponds
// the number of defined expectations
func (m *QuestionSetRepositoryMock) MinimockListQuestionIDsBySetIDDone() bool {
	if m.ListQuestionIDsBySetIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListQuestionIDsBySetIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListQuestionIDsBySetIDMock.invocationsDone()
}

// MinimockListQuestionIDsBySetIDInspect logs each unmet expectation
func (m *QuestionSetRepositoryMock) MinimockListQuestionIDsBySetIDInspect() {
	for _, e := range m.ListQuestionIDsBySetIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.ListQuestionIDsBySetID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListQuestionIDsBySetIDCounter := mm_atomic.LoadUint64(&m.afterListQuestionIDsBySetIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListQuestionIDsBySetIDMock.defaultExpectation != nil && afterListQuestionIDsBySetIDCounter < 1 {
		if m.ListQuestionIDsBySetIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.ListQuestionIDsBySetID at\n%s", m.ListQuestionIDsBySetIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.ListQuestionIDsBySetID at\n%s with params: %#v", m.ListQuestionIDsBySetIDMock.defaultExpectation.expectationOrigins.origin, *m.ListQuestionIDsBySetIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListQuestionIDsBySetID != nil && afterListQuestionIDsBySetIDCounter < 1 {
		m.t.Errorf("Expected call to QuestionSetRepositoryMock.ListQuestionIDsBySetID at\n%s", m.funcListQuestionIDsBySetIDOrigin)
	}

	if !m.ListQuestionIDsBySetIDMock.invocationsDone() && afterListQuestionIDsBySetIDCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSetRepositoryMock.ListQuestionIDsBySetID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListQuestionIDsBySetIDMock.expectedInvocations), m.ListQuestionIDsBySetIDMock.expectedInvocationsOrigin, afterListQuestionIDsBySetIDCounter)
	}
}

type mQuestionSetRepositoryMockListSetIDsByQuestionID struct {
	optional           bool
	mock               *QuestionSetRepositoryMock
	defaultExpectation *QuestionSetRepositoryMockListSetIDsByQuestionIDExpectation
	expectations       []*QuestionSetRepositoryMockListSetIDsByQuestionIDExpectation

	callArgs []*QuestionSetRepositoryMockListSetIDsByQuestionIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSetRepositoryMockListSetIDsByQuestionIDExpectation specifies expectation struct of the QuestionSetRepository.ListSetIDsByQuestionID
type QuestionSetRepositoryMockListSetIDsByQuestionIDExpectation struct {
	mock               *QuestionSetRepositoryMock
	params             *QuestionSetRepositoryMockListSetIDsByQuestionIDParams
	paramPtrs          *QuestionSetRepositoryMockListSetIDsByQuestionIDParamPtrs
	expectationOrigins QuestionSetRepositoryMockListSetIDsByQuestionIDExpectationOrigins
	results            *QuestionSetRepositoryMockListSetIDsByQuestionIDResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSetRepositoryMockListSetIDsByQuestionIDParams contains parameters of the QuestionSetRepository.ListSetIDsByQuestionID
type QuestionSetRepositoryMockListSetIDsByQuestionIDParams struct {
	ctx        context.Context
	questionID int64
}

// QuestionSetRepositoryMockListSetIDsByQuestionIDParamPtrs contains pointers to parameters of the QuestionSetRepository.ListSetIDsByQuestionID
type QuestionSetRepositoryMockListSetIDsByQuestionIDParamPtrs struct {
	ctx        *context.Context
	questionID *int64
}

// QuestionSetRepositoryMockListSetIDsByQuestionIDResults contains results of the QuestionSetRepository.ListSetIDsByQuestionID
type QuestionSetRepositoryMockListSetIDsByQuestionIDResults struct {
	ia1 []int64
	err error
}

// QuestionSetRepositoryMockListSetIDsByQuestionIDOrigins contains origins of expectations of the QuestionSetRepository.ListSetIDsByQuestionID
type QuestionSetRepositoryMockListSetIDsByQuestionIDExpectationOrigins struct {
	origin           string
	originCtx        string
	originQuestionID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListSetIDsByQuestionID *mQuestionSetRepositoryMockListSetIDsByQuestionID) Optional() *mQuestionSetRepositoryMockListSetIDsByQuestionID {
	mmListSetIDsByQuestionID.optional = true
	return mmListSetIDsByQuestionID
}

// Expect sets up expected params for QuestionSetRepository.ListSetIDsByQuestionID
func (mmListSetIDsByQuestionID *mQuestionSetRepositoryMockListSetIDsByQuestionID) Expect(ctx context.Context, questionID int64) *mQuestionSetRepositoryMockListSetIDsByQuestionID {
	if mmListSetIDsByQuestionID.mock.funcListSetIDsByQuestionID != nil {
		mmListSetIDsByQuestionID.mock.t.Fatalf("QuestionSetRepositoryMock.ListSetIDsByQuestionID mock is already set by Set")
	}

	if mmListSetIDsByQuestionID.defaultExpectation == nil {
		mmListSetIDsByQuestionID.defaultExpectation = &QuestionSetRepositoryMockListSetIDsByQuestionIDExpectation{}
	}

	if mmListSetIDsByQuestionID.defaultExpectation.paramPtrs != nil {
		mmListSetIDsByQuestionID.mock.t.Fatalf("QuestionSetRepositoryMock.ListSetIDsByQuestionID mock is already set by ExpectParams functions")
	}

	mmListSetIDsByQuestionID.defaultExpectation.params = &QuestionSetRepositoryMockListSetIDsByQuestionIDParams{ctx, questionID}
	mmListSetIDsByQuestionID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListSetIDsByQuestionID.expectations {
		if minimock.Equal(e.params, mmListSetIDsByQuestionID.defaultExpectation.params) {
			mmListSetIDsByQuestionID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListSetIDsByQuestionID.defaultExpectation.params)
		}
	}

	return mmListSetIDsByQuestionID
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSetRepository.ListSetIDsByQuestionID
func (mmListSetIDsByQuestionID *mQuestionSetRepositoryMockListSetIDsByQuestionID) ExpectCtxParam1(ctx context.Context) *mQuestionSetRepositoryMockListSetIDsByQuestionID {
	if mmListSetIDsByQuestionID.mock.funcListSetIDsByQuestionID != nil {
		mmListSetIDsByQuestionID.mock.t.Fatalf("QuestionSetRepositoryMock.ListSetIDsByQuestionID mock is already set by Set")
	}

	if mmListSetIDsByQuestionID.defaultExpectation == nil {
		mmListSetIDsByQuestionID.defaultExpectation = &QuestionSetRepositoryMockListSetIDsByQuestionIDExpectation{}
	}

	if mmListSetIDsByQuestionID.defaultExpectation.params != nil {
		mmListSetIDsByQuestionID.mock.t.Fatalf("QuestionSetRepositoryMock.ListSetIDsByQuestionID mock is already set by Expect")
	}

	if mmListSetIDsByQuestionID.defaultExpectation.paramPtrs == nil {
		mmListSetIDsByQuestionID.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockListSetIDsByQuestionIDParamPtrs{}
	}
	mmListSetIDsByQuestionID.defaultExpectation.paramPtrs.ctx = &ctx
	mmListSetIDsByQuestionID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListSetIDsByQuestionID
}

// ExpectQuestionIDParam2 sets up expected param questionID for QuestionSetRepository.ListSetIDsByQuestionID
func (mmListSetIDsByQuestionID *mQuestionSetRepositoryMockListSetIDsByQuestionID) ExpectQuestionIDParam2(questionID int64) *mQuestionSetRepositoryMockListSetIDsByQuestionID {
	if mmListSetIDsByQuestionID.mock.funcListSetIDsByQuestionID != nil {
		mmListSetIDsByQuestionID.mock.t.Fatalf("QuestionSetRepositoryMock.ListSetIDsByQuestionID mock is already set by Set")
	}

	if mmListSetIDsByQuestionID.defaultExpectation == nil {
		mmListSetIDsByQuestionID.defaultExpectation = &QuestionSetRepositoryMockListSetIDsByQuestionIDExpectation{}
	}

	if mmListSetIDsByQuestionID.defaultExpectation.params != nil {
		mmListSetIDsByQuestionID.mock.t.Fatalf("QuestionSetRepositoryMock.ListSetIDsByQuestionID mock is already set by Expect")
	}

	if mmListSetIDsByQuestionID.defaultExpectation.paramPtrs == nil {
		mmListSetIDsByQuestionID.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockListSetIDsByQuestionIDParamPtrs{}
	}
	mmListSetIDsByQuestionID.defaultExpectation.paramPtrs.questionID = &questionID
	mmListSetIDsByQuestionID.defaultExpectation.expectationOrigins.originQuestionID = minimock.CallerInfo(1)

	return mmListSetIDsByQuestionID
}

// Inspect accepts an inspector function that has same arguments as the QuestionSetRepository.ListSetIDsByQuestionID
func (mmListSetIDsByQuestionID *mQuestionSetRepositoryMockListSetIDsByQuestionID) Inspect(f func(ctx context.Context, questionID int64)) *mQuestionSetRepositoryMockListSetIDsByQuestionID {
	if mmListSetIDsByQuestionID.mock.inspectFuncListSetIDsByQuestionID != nil {
		mmListSetIDsByQuestionID.mock.t.Fatalf("Inspect function is already set for QuestionSetRepositoryMock.ListSetIDsByQuestionID")
	}

	mmListSetIDsByQuestionID.mock.inspectFuncListSetIDsByQuestionID = f

	return mmListSetIDsByQuestionID
}

// Return sets up results that will be returned by QuestionSetRepository.ListSetIDsByQuestionID
func (mmListSetIDsByQuestionID *mQuestionSetRepositoryMockListSetIDsByQuestionID) Return(ia1 []int64, err error) *QuestionSetRepositoryMock {
	if mmListSetIDsByQuestionID.mock.funcListSetIDsByQuestionID != nil {
		mmListSetIDsByQuestionID.mock.t.Fatalf("QuestionSetRepositoryMock.ListSetIDsByQuestionID mock is already set by Set")
	}

	if mmListSetIDsByQuestionID.defaultExpectation == nil {
		mmListSetIDsByQuestionID.defaultExpectation = &QuestionSetRepositoryMockListSetIDsByQuestionIDExpectation{mock: mmListSetIDsByQuestionID.mock}
	}
	mmListSetIDsByQuestionID.defaultExpectation.results = &QuestionSetRepositoryMockListSetIDsByQuestionIDResults{ia1, err}
	mmListSetIDsByQuestionID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListSetIDsByQuestionID.mock
}

// Set uses given function f to mock the QuestionSetRepository.ListSetIDsByQuestionID method
func (mmListSetIDsByQuestionID *mQuestionSetRepositoryMockListSetIDsByQuestionID) Set(f func(ctx context.Context, questionID int64) (ia1 []int64, err error)) *QuestionSetRepositoryMock {
	if mmListSetIDsByQuestionID.defaultExpectation != nil {
		mmListSetIDsByQuestionID.mock.t.Fatalf("Default expectation is already set for the QuestionSetRepository.ListSetIDsByQuestionID method")
	}

	if len(mmListSetIDsByQuestionID.expectations) > 0 {
		mmListSetIDsByQuestionID.mock.t.Fatalf("Some expectations are already set for the QuestionSetRepository.ListSetIDsByQuestionID method")
	}

	mmListSetIDsByQuestionID.mock.funcListSetIDsByQuestionID = f
	mmListSetIDsByQuestionID.mock.funcListSetIDsByQuestionIDOrigin = minimock.CallerInfo(1)
	return mmListSetIDsByQuestionID.mock
}

// When sets expectation for the QuestionSetRepository.ListSetIDsByQuestionID which will trigger the result defined by the following
// Then helper
func (mmListSetIDsByQuestionID *mQuestionSetRepositoryMockListSetIDsByQuestionID) When(ctx context.Context, questionID int64) *QuestionSetRepositoryMockListSetIDsByQuestionIDExpectation {
	if mmListSetIDsByQuestionID.mock.funcListSetIDsByQuestionID != nil {
		mmListSetIDsByQuestionID.mock.t.Fatalf("QuestionSetRepositoryMock.ListSetIDsByQuestionID mock is already set by Set")
	}

	expectation := &QuestionSetRepositoryMockListSetIDsByQuestionIDExpectation{
		mock:               mmListSetIDsByQuestionID.mock,
		params:             &QuestionSetRepositoryMockListSetIDsByQuestionIDParams{ctx, questionID},
		expectationOrigins: QuestionSetRepositoryMockListSetIDsByQuestionIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListSetIDsByQuestionID.expectations = append(mmListSetIDsByQuestionID.expectations, expectation)
	return expectation
}

// Then sets up QuestionSetRepository.ListSetIDsByQuestionID return parameters for the expectation previously defined by the When method
func (e *QuestionSetRepositoryMockListSetIDsByQuestionIDExpectation) Then(ia1 []int64, err error) *QuestionSetRepositoryMock {
	e.results = &QuestionSetRepositoryMockListSetIDsByQuestionIDResults{ia1, err}
	return e.mock
}

// Times sets number of times QuestionSetRepository.ListSetIDsByQuestionID should be invoked
func (mmListSetIDsByQuestionID *mQuestionSetRepositoryMockListSetIDsByQuestionID) Times(n uint64) *mQuestionSetRepositoryMockListSetIDsByQuestionID {
	if n == 0 {
		mmListSetIDsByQuestionID.mock.t.Fatalf("Times of QuestionSetRepositoryMock.ListSetIDsByQuestionID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListSetIDsByQuestionID.expectedInvocations, n)
	mmListSetIDsByQuestionID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListSetIDsByQuestionID
}

func (mmListSetIDsByQuestionID *mQuestionSetRepositoryMockListSetIDsByQuestionID) invocationsDone() bool {
	if len(mmListSetIDsByQuestionID.expectations) == 0 && mmListSetIDsByQuestionID.defaultExpectation == nil && mmListSetIDsByQuestionID.mock.funcListSetIDsByQuestionID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListSetIDsByQuestionID.mock.afterListSetIDsByQuestionIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListSetIDsByQuestionID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListSetIDsByQuestionID implements mm_repository.QuestionSetRepository
func (mmListSetIDsByQuestionID *QuestionSetRepositoryMock) ListSetIDsByQuestionID(ctx context.Context, questionID int64) (ia1 []int64, err error) {
	mm_atomic.AddUint64(&mmListSetIDsByQuestionID.beforeListSetIDsByQuestionIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListSetIDsByQuestionID.afterListSetIDsByQuestionIDCounter, 1)

	mmListSetIDsByQuestionID.t.Helper()

	if mmListSetIDsByQuestionID.inspectFuncListSetIDsByQuestionID != nil {
		mmListSetIDsByQuestionID.inspectFuncListSetIDsByQuestionID(ctx, questionID)
	}

	mm_params := QuestionSetRepositoryMockListSetIDsByQuestionIDParams{ctx, questionID}

	// Record call args
	mmListSetIDsByQuestionID.ListSetIDsByQuestionIDMock.mutex.Lock()
	mmListSetIDsByQuestionID.ListSetIDsByQuestionIDMock.callArgs = append(mmListSetIDsByQuestionID.ListSetIDsByQuestionIDMock.callArgs, &mm_params)
	mmListSetIDsByQuestionID.ListSetIDsByQuestionIDMock.mutex.Unlock()

	for _, e := range mmListSetIDsByQuestionID.ListSetIDsByQuestionIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmListSetIDsByQuestionID.ListSetIDsByQuestionIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListSetIDsByQuestionID.ListSetIDsByQuestionIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListSetIDsByQuestionID.ListSetIDsByQuestionIDMock.defaultExpectation.params
		mm_want_ptrs := mmListSetIDsByQuestionID.ListSetIDsByQuestionIDMock.defaultExpectation.paramPtrs

		mm_got := QuestionSetRepositoryMockListSetIDsByQuestionIDParams{ctx, questionID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListSetIDsByQuestionID.t.Errorf("QuestionSetRepositoryMock.ListSetIDsByQuestionID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSetIDsByQuestionID.ListSetIDsByQuestionIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.questionID != nil && !minimock.Equal(*mm_want_ptrs.questionID, mm_got.questionID) {
				mmListSetIDsByQuestionID.t.Errorf("QuestionSetRepositoryMock.ListSetIDsByQuestionID got unexpected parameter questionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSetIDsByQuestionID.ListSetIDsByQuestionIDMock.defaultExpectation.expectationOrigins.originQuestionID, *mm_want_ptrs.questionID, mm_got.questionID, minimock.Diff(*mm_want_ptrs.questionID, mm_got.questionID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListSetIDsByQuestionID.t.Errorf("QuestionSetRepositoryMock.ListSetIDsByQuestionID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListSetIDsByQuestionID.ListSetIDsByQuestionIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListSetIDsByQuestionID.ListSetIDsByQuestionIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListSetIDsByQuestionID.t.Fatal("No results are set for the QuestionSetRepositoryMock.ListSetIDsByQuestionID")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmListSetIDsByQuestionID.funcListSetIDsByQuestionID != nil {
		return mmListSetIDsByQuestionID.funcListSetIDsByQuestionID(ctx, questionID)
	}
	mmListSetIDsByQuestionID.t.Fatalf("Unexpected call to QuestionSetRepositoryMock.ListSetIDsByQuestionID. %v %v", ctx, questionID)
	return
}

// ListSetIDsByQuestionIDAfterCounter returns a count of finished QuestionSetRepositoryMock.ListSetIDsByQuestionID invocations
func (mmListSetIDsByQuestionID *QuestionSetRepositoryMock) ListSetIDsByQuestionIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSetIDsByQuestionID.afterListSetIDsByQuestionIDCounter)
}

// ListSetIDsByQuestionIDBeforeCounter returns a count of QuestionSetRepositoryMock.ListSetIDsByQuestionID invocations
func (mmListSetIDsByQuestionID *QuestionSetRepositoryMock) ListSetIDsByQuestionIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSetIDsByQuestionID.beforeListSetIDsByQuestionIDCounter)
}

// Calls returns a list of arguments used in each call to QuestionSetRepositoryMock.ListSetIDsByQuestionID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListSetIDsByQuestionID *mQuestionSetRepositoryMockListSetIDsByQuestionID) Calls() []*QuestionSetRepositoryMockListSetIDsByQuestionIDParams {
	mmListSetIDsByQuestionID.mutex.RLock()

	argCopy := make([]*QuestionSetRepositoryMockListSetIDsByQuestionIDParams, len(mmListSetIDsByQuestionID.callArgs))
	copy(argCopy, mmListSetIDsByQuestionID.callArgs)

	mmListSetIDsByQuestionID.mutex.RUnlock()

	return argCopy
}

// MinimockListSetIDsByQuestionIDDone returns true if the count of the ListSetIDsByQuestionID invocations corresponds
// the number of defined expectations
func (m *QuestionSetRepositoryMock) MinimockListSetIDsByQuestionIDDone() bool {
	if m.ListSetIDsByQuestionIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListSetIDsByQuestionIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListSetIDsByQuestionIDMock.invocationsDone()
}

// MinimockListSetIDsByQuestionIDInspect logs each unmet expectation
func (m *QuestionSetRepositoryMock) MinimockListSetIDsByQuestionIDInspect() {
	for _, e := range m.ListSetIDsByQuestionIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.ListSetIDsByQuestionID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListSetIDsByQuestionIDCounter := mm_atomic.LoadUint64(&m.afterListSetIDsByQuestionIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListSetIDsByQuestionIDMock.defaultExpectation != nil && afterListSetIDsByQuestionIDCounter < 1 {
		if m.ListSetIDsByQuestionIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.ListSetIDsByQuestionID at\n%s", m.ListSetIDsByQuestionIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.ListSetIDsByQuestionID at\n%s with params: %#v", m.ListSetIDsByQuestionIDMock.defaultExpectation.expectationOrigins.origin, *m.ListSetIDsByQuestionIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSetIDsByQuestionID != nil && afterListSetIDsByQuestionIDCounter < 1 {
		m.t.Errorf("Expected call to QuestionSetRepositoryMock.ListSetIDsByQuestionID at\n%s", m.funcListSetIDsByQuestionIDOrigin)
	}

	if !m.ListSetIDsByQuestionIDMock.invocationsDone() && afterListSetIDsByQuestionIDCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSetRepositoryMock.ListSetIDsByQuestionID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListSetIDsByQuestionIDMock.expectedInvocations), m.ListSetIDsByQuestionIDMock.expectedInvocationsOrigin, afterListSetIDsByQuestionIDCounter)
	}
}

type mQuestionSetRepositoryMockRemoveQuestionFromSets struct {
	optional           bool
	mock               *QuestionSetRepositoryMock
	defaultExpectation *QuestionSetRepositoryMockRemoveQuestionFromSetsExpectation
	expectations       []*QuestionSetRepositoryMockRemoveQuestionFromSetsExpectation

	callArgs []*QuestionSetRepositoryMockRemoveQuestionFromSetsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSetRepositoryMockRemoveQuestionFromSetsExpectation specifies expectation struct of the QuestionSetRepository.RemoveQuestionFromSets
type QuestionSetRepositoryMockRemoveQuestionFromSetsExpectation struct {
	mock               *QuestionSetRepositoryMock
	params             *QuestionSetRepositoryMockRemoveQuestionFromSetsParams
	paramPtrs          *QuestionSetRepositoryMockRemoveQuestionFromSetsParamPtrs
	expectationOrigins QuestionSetRepositoryMockRemoveQuestionFromSetsExpectationOrigins
	results            *QuestionSetRepositoryMockRemoveQuestionFromSetsResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSetRepositoryMockRemoveQuestionFromSetsParams contains parameters of the QuestionSetRepository.RemoveQuestionFromSets
type QuestionSetRepositoryMockRemoveQuestionFromSetsParams struct {
	ctx        context.Context
	questionID int64
	setIDs     []int64
}

// QuestionSetRepositoryMockRemoveQuestionFromSetsParamPtrs contains pointers to parameters of the QuestionSetRepository.RemoveQuestionFromSets
type QuestionSetRepositoryMockRemoveQuestionFromSetsParamPtrs struct {
	ctx        *context.Context
	questionID *int64
	setIDs     *[]int64
}

// QuestionSetRepositoryMockRemoveQuestionFromSetsResults contains results of the QuestionSetRepository.RemoveQuestionFromSets
type QuestionSetRepositoryMockRemoveQuestionFromSetsResults struct {
	err error
}

// QuestionSetRepositoryMockRemoveQuestionFromSetsOrigins contains origins of expectations of the QuestionSetRepository.RemoveQuestionFromSets
type QuestionSetRepositoryMockRemoveQuestionFromSetsExpectationOrigins struct {
	origin           string
	originCtx        string
	originQuestionID string
	originSetIDs     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveQuestionFromSets *mQuestionSetRepositoryMockRemoveQuestionFromSets) Optional() *mQuestionSetRepositoryMockRemoveQuestionFromSets {
	mmRemoveQuestionFromSets.optional = true
	return mmRemoveQuestionFromSets
}

// Expect sets up expected params for QuestionSetRepository.RemoveQuestionFromSets
func (mmRemoveQuestionFromSets *mQuestionSetRepositoryMockRemoveQuestionFromSets) Expect(ctx context.Context, questionID int64, setIDs []int64) *mQuestionSetRepositoryMockRemoveQuestionFromSets {
	if mmRemoveQuestionFromSets.mock.funcRemoveQuestionFromSets != nil {
		mmRemoveQuestionFromSets.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionFromSets mock is already set by Set")
	}

	if mmRemoveQuestionFromSets.defaultExpectation == nil {
		mmRemoveQuestionFromSets.defaultExpectation = &QuestionSetRepositoryMockRemoveQuestionFromSetsExpectation{}
	}

	if mmRemoveQuestionFromSets.defaultExpectation.paramPtrs != nil {
		mmRemoveQuestionFromSets.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionFromSets mock is already set by ExpectParams functions")
	}

	mmRemoveQuestionFromSets.defaultExpectation.params = &QuestionSetRepositoryMockRemoveQuestionFromSetsParams{ctx, questionID, setIDs}
	mmRemoveQuestionFromSets.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveQuestionFromSets.expectations {
		if minimock.Equal(e.params, mmRemoveQuestionFromSets.defaultExpectation.params) {
			mmRemoveQuestionFromSets.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveQuestionFromSets.defaultExpectation.params)
		}
	}

	return mmRemoveQuestionFromSets
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSetRepository.RemoveQuestionFromSets
func (mmRemoveQuestionFromSets *mQuestionSetRepositoryMockRemoveQuestionFromSets) ExpectCtxParam1(ctx context.Context) *mQuestionSetRepositoryMockRemoveQuestionFromSets {
	if mmRemoveQuestionFromSets.mock.funcRemoveQuestionFromSets != nil {
		mmRemoveQuestionFromSets.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionFromSets mock is already set by Set")
	}

	if mmRemoveQuestionFromSets.defaultExpectation == nil {
		mmRemoveQuestionFromSets.defaultExpectation = &QuestionSetRepositoryMockRemoveQuestionFromSetsExpectation{}
	}

	if mmRemoveQuestionFromSets.defaultExpectation.params != nil {
		mmRemoveQuestionFromSets.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionFromSets mock is already set by Expect")
	}

	if mmRemoveQuestionFromSets.defaultExpectation.paramPtrs == nil {
		mmRemoveQuestionFromSets.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockRemoveQuestionFromSetsParamPtrs{}
	}
	mmRemoveQuestionFromSets.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveQuestionFromSets.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveQuestionFromSets
}

// ExpectQuestionIDParam2 sets up expected param questionID for QuestionSetRepository.RemoveQuestionFromSets
func (mmRemoveQuestionFromSets *mQuestionSetRepositoryMockRemoveQuestionFromSets) ExpectQuestionIDParam2(questionID int64) *mQuestionSetRepositoryMockRemoveQuestionFromSets {
	if mmRemoveQuestionFromSets.mock.funcRemoveQuestionFromSets != nil {
		mmRemoveQuestionFromSets.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionFromSets mock is already set by Set")
	}

	if mmRemoveQuestionFromSets.defaultExpectation == nil {
		mmRemoveQuestionFromSets.defaultExpectation = &QuestionSetRepositoryMockRemoveQuestionFromSetsExpectation{}
	}

	if mmRemoveQuestionFromSets.defaultExpectation.params != nil {
		mmRemoveQuestionFromSets.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionFromSets mock is already set by Expect")
	}

	if mmRemoveQuestionFromSets.defaultExpectation.paramPtrs == nil {
		mmRemoveQuestionFromSets.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockRemoveQuestionFromSetsParamPtrs{}
	}
	mmRemoveQuestionFromSets.defaultExpectation.paramPtrs.questionID = &questionID
	mmRemoveQuestionFromSets.defaultExpectation.expectationOrigins.originQuestionID = minimock.CallerInfo(1)

	return mmRemoveQuestionFromSets
}

// ExpectSetIDsParam3 sets up expected param setIDs for QuestionSetRepository.RemoveQuestionFromSets
func (mmRemoveQuestionFromSets *mQuestionSetRepositoryMockRemoveQuestionFromSets) ExpectSetIDsParam3(setIDs []int64) *mQuestionSetRepositoryMockRemoveQuestionFromSets {
	if mmRemoveQuestionFromSets.mock.funcRemoveQuestionFromSets != nil {
		mmRemoveQuestionFromSets.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionFromSets mock is already set by Set")
	}

	if mmRemoveQuestionFromSets.defaultExpectation == nil {
		mmRemoveQuestionFromSets.defaultExpectation = &QuestionSetRepositoryMockRemoveQuestionFromSetsExpectation{}
	}

	if mmRemoveQuestionFromSets.defaultExpectation.params != nil {
		mmRemoveQuestionFromSets.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionFromSets mock is already set by Expect")
	}

	if mmRemoveQuestionFromSets.defaultExpectation.paramPtrs == nil {
		mmRemoveQuestionFromSets.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockRemoveQuestionFromSetsParamPtrs{}
	}
	mmRemoveQuestionFromSets.defaultExpectation.paramPtrs.setIDs = &setIDs
	mmRemoveQuestionFromSets.defaultExpectation.expectationOrigins.originSetIDs = minimock.CallerInfo(1)

	return mmRemoveQuestionFromSets
}

// Inspect accepts an inspector function that has same arguments as the QuestionSetRepository.RemoveQuestionFromSets
func (mmRemoveQuestionFromSets *mQuestionSetRepositoryMockRemoveQuestionFromSets) Inspect(f func(ctx context.Context, questionID int64, setIDs []int64)) *mQuestionSetRepositoryMockRemoveQuestionFromSets {
	if mmRemoveQuestionFromSets.mock.inspectFuncRemoveQuestionFromSets != nil {
		mmRemoveQuestionFromSets.mock.t.Fatalf("Inspect function is already set for QuestionSetRepositoryMock.RemoveQuestionFromSets")
	}

	mmRemoveQuestionFromSets.mock.inspectFuncRemoveQuestionFromSets = f

	return mmRemoveQuestionFromSets
}

// Return sets up results that will be returned by QuestionSetRepository.RemoveQuestionFromSets
func (mmRemoveQuestionFromSets *mQuestionSetRepositoryMockRemoveQuestionFromSets) Return(err error) *QuestionSetRepositoryMock {
	if mmRemoveQuestionFromSets.mock.funcRemoveQuestionFromSets != nil {
		mmRemoveQuestionFromSets.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionFromSets mock is already set by Set")
	}

	if mmRemoveQuestionFromSets.defaultExpectation == nil {
		mmRemoveQuestionFromSets.defaultExpectation = &QuestionSetRepositoryMockRemoveQuestionFromSetsExpectation{mock: mmRemoveQuestionFromSets.mock}
	}
	mmRemoveQuestionFromSets.defaultExpectation.results = &QuestionSetRepositoryMockRemoveQuestionFromSetsResults{err}
	mmRemoveQuestionFromSets.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveQuestionFromSets.mock
}

// Set uses given function f to mock the QuestionSetRepository.RemoveQuestionFromSets method
func (mmRemoveQuestionFromSets *mQuestionSetRepositoryMockRemoveQuestionFromSets) Set(f func(ctx context.Context, questionID int64, setIDs []int64) (err error)) *QuestionSetRepositoryMock {
	if mmRemoveQuestionFromSets.defaultExpectation != nil {
		mmRemoveQuestionFromSets.mock.t.Fatalf("Default expectation is already set for the QuestionSetRepository.RemoveQuestionFromSets method")
	}

	if len(mmRemoveQuestionFromSets.expectations) > 0 {
		mmRemoveQuestionFromSets.mock.t.Fatalf("Some expectations are already set for the QuestionSetRepository.RemoveQuestionFromSets method")
	}

	mmRemoveQuestionFromSets.mock.funcRemoveQuestionFromSets = f
	mmRemoveQuestionFromSets.mock.funcRemoveQuestionFromSetsOrigin = minimock.CallerInfo(1)
	return mmRemoveQuestionFromSets.mock
}

// When sets expectation for the QuestionSetRepository.RemoveQuestionFromSets which will trigger the result defined by the following
// Then helper
func (mmRemoveQuestionFromSets *mQuestionSetRepositoryMockRemoveQuestionFromSets) When(ctx context.Context, questionID int64, setIDs []int64) *QuestionSetRepositoryMockRemoveQuestionFromSetsExpectation {
	if mmRemoveQuestionFromSets.mock.funcRemoveQuestionFromSets != nil {
		mmRemoveQuestionFromSets.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionFromSets mock is already set by Set")
	}

	expectation := &QuestionSetRepositoryMockRemoveQuestionFromSetsExpectation{
		mock:               mmRemoveQuestionFromSets.mock,
		params:             &QuestionSetRepositoryMockRemoveQuestionFromSetsParams{ctx, questionID, setIDs},
		expectationOrigins: QuestionSetRepositoryMockRemoveQuestionFromSetsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveQuestionFromSets.expectations = append(mmRemoveQuestionFromSets.expectations, expectation)
	return expectation
}

// Then sets up QuestionSetRepository.RemoveQuestionFromSets return parameters for the expectation previously defined by the When method
func (e *QuestionSetRepositoryMockRemoveQuestionFromSetsExpectation) Then(err error) *QuestionSetRepositoryMock {
	e.results = &QuestionSetRepositoryMockRemoveQuestionFromSetsResults{err}
	return e.mock
}

// Times sets number of times QuestionSetRepository.RemoveQuestionFromSets should be invoked
func (mmRemoveQuestionFromSets *mQuestionSetRepositoryMockRemoveQuestionFromSets) Times(n uint64) *mQuestionSetRepositoryMockRemoveQuestionFromSets {
	if n == 0 {
		mmRemoveQuestionFromSets.mock.t.Fatalf("Times of QuestionSetRepositoryMock.RemoveQuestionFromSets mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveQuestionFromSets.expectedInvocations, n)
	mmRemoveQuestionFromSets.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveQuestionFromSets
}

func (mmRemoveQuestionFromSets *mQuestionSetRepositoryMockRemoveQuestionFromSets) invocationsDone() bool {
	if len(mmRemoveQuestionFromSets.expectations) == 0 && mmRemoveQuestionFromSets.defaultExpectation == nil && mmRemoveQuestionFromSets.mock.funcRemoveQuestionFromSets == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveQuestionFromSets.mock.afterRemoveQuestionFromSetsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveQuestionFromSets.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveQuestionFromSets implements mm_repository.QuestionSetRepository
func (mmRemoveQuestionFromSets *QuestionSetRepositoryMock) RemoveQuestionFromSets(ctx context.Context, questionID int64, setIDs []int64) (err error) {
	mm_atomic.AddUint64(&mmRemoveQuestionFromSets.beforeRemoveQuestionFromSetsCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveQuestionFromSets.afterRemoveQuestionFromSetsCounter, 1)

	mmRemoveQuestionFromSets.t.Helper()

	if mmRemoveQuestionFromSets.inspectFuncRemoveQuestionFromSets != nil {
		mmRemoveQuestionFromSets.inspectFuncRemoveQuestionFromSets(ctx, questionID, setIDs)
	}

	mm_params := QuestionSetRepositoryMockRemoveQuestionFromSetsParams{ctx, questionID, setIDs}

	// Record call args
	mmRemoveQuestionFromSets.RemoveQuestionFromSetsMock.mutex.Lock()
	mmRemoveQuestionFromSets.RemoveQuestionFromSetsMock.callArgs = append(mmRemoveQuestionFromSets.RemoveQuestionFromSetsMock.callArgs, &mm_params)
	mmRemoveQuestionFromSets.RemoveQuestionFromSetsMock.mutex.Unlock()

	for _, e := range mmRemoveQuestionFromSets.RemoveQuestionFromSetsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveQuestionFromSets.RemoveQuestionFromSetsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveQuestionFromSets.RemoveQuestionFromSetsMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveQuestionFromSets.RemoveQuestionFromSetsMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveQuestionFromSets.RemoveQuestionFromSetsMock.defaultExpectation.paramPtrs

		mm_got := QuestionSetRepositoryMockRemoveQuestionFromSetsParams{ctx, questionID, setIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveQuestionFromSets.t.Errorf("QuestionSetRepositoryMock.RemoveQuestionFromSets got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveQuestionFromSets.RemoveQuestionFromSetsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.questionID != nil && !minimock.Equal(*mm_want_ptrs.questionID, mm_got.questionID) {
				mmRemoveQuestionFromSets.t.Errorf("QuestionSetRepositoryMock.RemoveQuestionFromSets got unexpected parameter questionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveQuestionFromSets.RemoveQuestionFromSetsMock.defaultExpectation.expectationOrigins.originQuestionID, *mm_want_ptrs.questionID, mm_got.questionID, minimock.Diff(*mm_want_ptrs.questionID, mm_got.questionID))
			}

			if mm_want_ptrs.setIDs != nil && !minimock.Equal(*mm_want_ptrs.setIDs, mm_got.setIDs) {
				mmRemoveQuestionFromSets.t.Errorf("QuestionSetRepositoryMock.RemoveQuestionFromSets got unexpected parameter setIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveQuestionFromSets.RemoveQuestionFromSetsMock.defaultExpectation.expectationOrigins.originSetIDs, *mm_want_ptrs.setIDs, mm_got.setIDs, minimock.Diff(*mm_want_ptrs.setIDs, mm_got.setIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveQuestionFromSets.t.Errorf("QuestionSetRepositoryMock.RemoveQuestionFromSets got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveQuestionFromSets.RemoveQuestionFromSetsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveQuestionFromSets.RemoveQuestionFromSetsMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveQuestionFromSets.t.Fatal("No results are set for the QuestionSetRepositoryMock.RemoveQuestionFromSets")
		}
		return (*mm_results).err
	}
	if mmRemoveQuestionFromSets.funcRemoveQuestionFromSets != nil {
		return mmRemoveQuestionFromSets.funcRemoveQuestionFromSets(ctx, questionID, setIDs)
	}
	mmRemoveQuestionFromSets.t.Fatalf("Unexpected call to QuestionSetRepositoryMock.RemoveQuestionFromSets. %v %v %v", ctx, questionID, setIDs)
	return
}

// RemoveQuestionFromSetsAfterCounter returns a count of finished QuestionSetRepositoryMock.RemoveQuestionFromSets invocations
func (mmRemoveQuestionFromSets *QuestionSetRepositoryMock) RemoveQuestionFromSetsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveQuestionFromSets.afterRemoveQuestionFromSetsCounter)
}

// RemoveQuestionFromSetsBeforeCounter returns a count of QuestionSetRepositoryMock.RemoveQuestionFromSets invocations
func (mmRemoveQuestionFromSets *QuestionSetRepositoryMock) RemoveQuestionFromSetsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveQuestionFromSets.beforeRemoveQuestionFromSetsCounter)
}

// Calls returns a list of arguments used in each call to QuestionSetRepositoryMock.RemoveQuestionFromSets.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveQuestionFromSets *mQuestionSetRepositoryMockRemoveQuestionFromSets) Calls() []*QuestionSetRepositoryMockRemoveQuestionFromSetsParams {
	mmRemoveQuestionFromSets.mutex.RLock()

	argCopy := make([]*QuestionSetRepositoryMockRemoveQuestionFromSetsParams, len(mmRemoveQuestionFromSets.callArgs))
	copy(argCopy, mmRemoveQuestionFromSets.callArgs)

	mmRemoveQuestionFromSets.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveQuestionFromSetsDone returns true if the count of the RemoveQuestionFromSets invocations corresponds
// the number of defined expectations
func (m *QuestionSetRepositoryMock) MinimockRemoveQuestionFromSetsDone() bool {
	if m.RemoveQuestionFromSetsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveQuestionFromSetsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveQuestionFromSetsMock.invocationsDone()
}

// MinimockRemoveQuestionFromSetsInspect logs each unmet expectation
func (m *QuestionSetRepositoryMock) MinimockRemoveQuestionFromSetsInspect() {
	for _, e := range m.RemoveQuestionFromSetsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.RemoveQuestionFromSets at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveQuestionFromSetsCounter := mm_atomic.LoadUint64(&m.afterRemoveQuestionFromSetsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveQuestionFromSetsMock.defaultExpectation != nil && afterRemoveQuestionFromSetsCounter < 1 {
		if m.RemoveQuestionFromSetsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.RemoveQuestionFromSets at\n%s", m.RemoveQuestionFromSetsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.RemoveQuestionFromSets at\n%s with params: %#v", m.RemoveQuestionFromSetsMock.defaultExpectation.expectationOrigins.origin, *m.RemoveQuestionFromSetsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveQuestionFromSets != nil && afterRemoveQuestionFromSetsCounter < 1 {
		m.t.Errorf("Expected call to QuestionSetRepositoryMock.RemoveQuestionFromSets at\n%s", m.funcRemoveQuestionFromSetsOrigin)
	}

	if !m.RemoveQuestionFromSetsMock.invocationsDone() && afterRemoveQuestionFromSetsCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSetRepositoryMock.RemoveQuestionFromSets at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveQuestionFromSetsMock.expectedInvocations), m.RemoveQuestionFromSetsMock.expectedInvocationsOrigin, afterRemoveQuestionFromSetsCounter)
	}
}

type mQuestionSetRepositoryMockRemoveQuestionsFromSet struct {
	optional           bool
	mock               *QuestionSetRepositoryMock
	defaultExpectation *QuestionSetRepositoryMockRemoveQuestionsFromSetExpectation
	expectations       []*QuestionSetRepositoryMockRemoveQuestionsFromSetExpectation

	callArgs []*QuestionSetRepositoryMockRemoveQuestionsFromSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSetRepositoryMockRemoveQuestionsFromSetExpectation specifies expectation struct of the QuestionSetRepository.RemoveQuestionsFromSet
type QuestionSetRepositoryMockRemoveQuestionsFromSetExpectation struct {
	mock               *QuestionSetRepositoryMock
	params             *QuestionSetRepositoryMockRemoveQuestionsFromSetParams
	paramPtrs          *QuestionSetRepositoryMockRemoveQuestionsFromSetParamPtrs
	expectationOrigins QuestionSetRepositoryMockRemoveQuestionsFromSetExpectationOrigins
	results            *QuestionSetRepositoryMockRemoveQuestionsFromSetResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSetRepositoryMockRemoveQuestionsFromSetParams contains parameters of the QuestionSetRepository.RemoveQuestionsFromSet
type QuestionSetRepositoryMockRemoveQuestionsFromSetParams struct {
	ctx         context.Context
	setID       int64
	questionIDs []int64
}

// QuestionSetRepositoryMockRemoveQuestionsFromSetParamPtrs contains pointers to parameters of the QuestionSetRepository.RemoveQuestionsFromSet
type QuestionSetRepositoryMockRemoveQuestionsFromSetParamPtrs struct {
	ctx         *context.Context
	setID       *int64
	questionIDs *[]int64
}

// QuestionSetRepositoryMockRemoveQuestionsFromSetResults contains results of the QuestionSetRepository.RemoveQuestionsFromSet
type QuestionSetRepositoryMockRemoveQuestionsFromSetResults struct {
	err error
}

// QuestionSetRepositoryMockRemoveQuestionsFromSetOrigins contains origins of expectations of the QuestionSetRepository.RemoveQuestionsFromSet
type QuestionSetRepositoryMockRemoveQuestionsFromSetExpectationOrigins struct {
	origin            string
	originCtx         string
	originSetID       string
	originQuestionIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveQuestionsFromSet *mQuestionSetRepositoryMockRemoveQuestionsFromSet) Optional() *mQuestionSetRepositoryMockRemoveQuestionsFromSet {
	mmRemoveQuestionsFromSet.optional = true
	return mmRemoveQuestionsFromSet
}

// Expect sets up expected params for QuestionSetRepository.RemoveQuestionsFromSet
func (mmRemoveQuestionsFromSet *mQuestionSetRepositoryMockRemoveQuestionsFromSet) Expect(ctx context.Context, setID int64, questionIDs []int64) *mQuestionSetRepositoryMockRemoveQuestionsFromSet {
	if mmRemoveQuestionsFromSet.mock.funcRemoveQuestionsFromSet != nil {
		mmRemoveQuestionsFromSet.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionsFromSet mock is already set by Set")
	}

	if mmRemoveQuestionsFromSet.defaultExpectation == nil {
		mmRemoveQuestionsFromSet.defaultExpectation = &QuestionSetRepositoryMockRemoveQuestionsFromSetExpectation{}
	}

	if mmRemoveQuestionsFromSet.defaultExpectation.paramPtrs != nil {
		mmRemoveQuestionsFromSet.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionsFromSet mock is already set by ExpectParams functions")
	}

	mmRemoveQuestionsFromSet.defaultExpectation.params = &QuestionSetRepositoryMockRemoveQuestionsFromSetParams{ctx, setID, questionIDs}
	mmRemoveQuestionsFromSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveQuestionsFromSet.expectations {
		if minimock.Equal(e.params, mmRemoveQuestionsFromSet.defaultExpectation.params) {
			mmRemoveQuestionsFromSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveQuestionsFromSet.defaultExpectation.params)
		}
	}

	return mmRemoveQuestionsFromSet
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSetRepository.RemoveQuestionsFromSet
func (mmRemoveQuestionsFromSet *mQuestionSetRepositoryMockRemoveQuestionsFromSet) ExpectCtxParam1(ctx context.Context) *mQuestionSetRepositoryMockRemoveQuestionsFromSet {
	if mmRemoveQuestionsFromSet.mock.funcRemoveQuestionsFromSet != nil {
		mmRemoveQuestionsFromSet.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionsFromSet mock is already set by Set")
	}

	if mmRemoveQuestionsFromSet.defaultExpectation == nil {
		mmRemoveQuestionsFromSet.defaultExpectation = &QuestionSetRepositoryMockRemoveQuestionsFromSetExpectation{}
	}

	if mmRemoveQuestionsFromSet.defaultExpectation.params != nil {
		mmRemoveQuestionsFromSet.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionsFromSet mock is already set by Expect")
	}

	if mmRemoveQuestionsFromSet.defaultExpectation.paramPtrs == nil {
		mmRemoveQuestionsFromSet.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockRemoveQuestionsFromSetParamPtrs{}
	}
	mmRemoveQuestionsFromSet.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveQuestionsFromSet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveQuestionsFromSet
}

// ExpectSetIDParam2 sets up expected param setID for QuestionSetRepository.RemoveQuestionsFromSet
func (mmRemoveQuestionsFromSet *mQuestionSetRepositoryMockRemoveQuestionsFromSet) ExpectSetIDParam2(setID int64) *mQuestionSetRepositoryMockRemoveQuestionsFromSet {
	if mmRemoveQuestionsFromSet.mock.funcRemoveQuestionsFromSet != nil {
		mmRemoveQuestionsFromSet.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionsFromSet mock is already set by Set")
	}

	if mmRemoveQuestionsFromSet.defaultExpectation == nil {
		mmRemoveQuestionsFromSet.defaultExpectation = &QuestionSetRepositoryMockRemoveQuestionsFromSetExpectation{}
	}

	if mmRemoveQuestionsFromSet.defaultExpectation.params != nil {
		mmRemoveQuestionsFromSet.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionsFromSet mock is already set by Expect")
	}

	if mmRemoveQuestionsFromSet.defaultExpectation.paramPtrs == nil {
		mmRemoveQuestionsFromSet.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockRemoveQuestionsFromSetParamPtrs{}
	}
	mmRemoveQuestionsFromSet.defaultExpectation.paramPtrs.setID = &setID
	mmRemoveQuestionsFromSet.defaultExpectation.expectationOrigins.originSetID = minimock.CallerInfo(1)

	return mmRemoveQuestionsFromSet
}

// ExpectQuestionIDsParam3 sets up expected param questionIDs for QuestionSetRepository.RemoveQuestionsFromSet
func (mmRemoveQuestionsFromSet *mQuestionSetRepositoryMockRemoveQuestionsFromSet) ExpectQuestionIDsParam3(questionIDs []int64) *mQuestionSetRepositoryMockRemoveQuestionsFromSet {
	if mmRemoveQuestionsFromSet.mock.funcRemoveQuestionsFromSet != nil {
		mmRemoveQuestionsFromSet.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionsFromSet mock is already set by Set")
	}

	if mmRemoveQuestionsFromSet.defaultExpectation == nil {
		mmRemoveQuestionsFromSet.defaultExpectation = &QuestionSetRepositoryMockRemoveQuestionsFromSetExpectation{}
	}

	if mmRemoveQuestionsFromSet.defaultExpectation.params != nil {
		mmRemoveQuestionsFromSet.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionsFromSet mock is already set by Expect")
	}

	if mmRemoveQuestionsFromSet.defaultExpectation.paramPtrs == nil {
		mmRemoveQuestionsFromSet.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockRemoveQuestionsFromSetParamPtrs{}
	}
	mmRemoveQuestionsFromSet.defaultExpectation.paramPtrs.questionIDs = &questionIDs
	mmRemoveQuestionsFromSet.defaultExpectation.expectationOrigins.originQuestionIDs = minimock.CallerInfo(1)

	return mmRemoveQuestionsFromSet
}

// Inspect accepts an inspector function that has same arguments as the QuestionSetRepository.RemoveQuestionsFromSet
func (mmRemoveQuestionsFromSet *mQuestionSetRepositoryMockRemoveQuestionsFromSet) Inspect(f func(ctx context.Context, setID int64, questionIDs []int64)) *mQuestionSetRepositoryMockRemoveQuestionsFromSet {
	if mmRemoveQuestionsFromSet.mock.inspectFuncRemoveQuestionsFromSet != nil {
		mmRemoveQuestionsFromSet.mock.t.Fatalf("Inspect function is already set for QuestionSetRepositoryMock.RemoveQuestionsFromSet")
	}

	mmRemoveQuestionsFromSet.mock.inspectFuncRemoveQuestionsFromSet = f

	return mmRemoveQuestionsFromSet
}

// Return sets up results that will be returned by QuestionSetRepository.RemoveQuestionsFromSet
func (mmRemoveQuestionsFromSet *mQuestionSetRepositoryMockRemoveQuestionsFromSet) Return(err error) *QuestionSetRepositoryMock {
	if mmRemoveQuestionsFromSet.mock.funcRemoveQuestionsFromSet != nil {
		mmRemoveQuestionsFromSet.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionsFromSet mock is already set by Set")
	}

	if mmRemoveQuestionsFromSet.defaultExpectation == nil {
		mmRemoveQuestionsFromSet.defaultExpectation = &QuestionSetRepositoryMockRemoveQuestionsFromSetExpectation{mock: mmRemoveQuestionsFromSet.mock}
	}
	mmRemoveQuestionsFromSet.defaultExpectation.results = &QuestionSetRepositoryMockRemoveQuestionsFromSetResults{err}
	mmRemoveQuestionsFromSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveQuestionsFromSet.mock
}

// Set uses given function f to mock the QuestionSetRepository.RemoveQuestionsFromSet method
func (mmRemoveQuestionsFromSet *mQuestionSetRepositoryMockRemoveQuestionsFromSet) Set(f func(ctx context.Context, setID int64, questionIDs []int64) (err error)) *QuestionSetRepositoryMock {
	if mmRemoveQuestionsFromSet.defaultExpectation != nil {
		mmRemoveQuestionsFromSet.mock.t.Fatalf("Default expectation is already set for the QuestionSetRepository.RemoveQuestionsFromSet method")
	}

	if len(mmRemoveQuestionsFromSet.expectations) > 0 {
		mmRemoveQuestionsFromSet.mock.t.Fatalf("Some expectations are already set for the QuestionSetRepository.RemoveQuestionsFromSet method")
	}

	mmRemoveQuestionsFromSet.mock.funcRemoveQuestionsFromSet = f
	mmRemoveQuestionsFromSet.mock.funcRemoveQuestionsFromSetOrigin = minimock.CallerInfo(1)
	return mmRemoveQuestionsFromSet.mock
}

// When sets expectation for the QuestionSetRepository.RemoveQuestionsFromSet which will trigger the result defined by the following
// Then helper
func (mmRemoveQuestionsFromSet *mQuestionSetRepositoryMockRemoveQuestionsFromSet) When(ctx context.Context, setID int64, questionIDs []int64) *QuestionSetRepositoryMockRemoveQuestionsFromSetExpectation {
	if mmRemoveQuestionsFromSet.mock.funcRemoveQuestionsFromSet != nil {
		mmRemoveQuestionsFromSet.mock.t.Fatalf("QuestionSetRepositoryMock.RemoveQuestionsFromSet mock is already set by Set")
	}

	expectation := &QuestionSetRepositoryMockRemoveQuestionsFromSetExpectation{
		mock:               mmRemoveQuestionsFromSet.mock,
		params:             &QuestionSetRepositoryMockRemoveQuestionsFromSetParams{ctx, setID, questionIDs},
		expectationOrigins: QuestionSetRepositoryMockRemoveQuestionsFromSetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveQuestionsFromSet.expectations = append(mmRemoveQuestionsFromSet.expectations, expectation)
	return expectation
}

// Then sets up QuestionSetRepository.RemoveQuestionsFromSet return parameters for the expectation previously defined by the When method
func (e *QuestionSetRepositoryMockRemoveQuestionsFromSetExpectation) Then(err error) *QuestionSetRepositoryMock {
	e.results = &QuestionSetRepositoryMockRemoveQuestionsFromSetResults{err}
	return e.mock
}

// Times sets number of times QuestionSetRepository.RemoveQuestionsFromSet should be invoked
func (mmRemoveQuestionsFromSet *mQuestionSetRepositoryMockRemoveQuestionsFromSet) Times(n uint64) *mQuestionSetRepositoryMockRemoveQuestionsFromSet {
	if n == 0 {
		mmRemoveQuestionsFromSet.mock.t.Fatalf("Times of QuestionSetRepositoryMock.RemoveQuestionsFromSet mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveQuestionsFromSet.expectedInvocations, n)
	mmRemoveQuestionsFromSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveQuestionsFromSet
}

func (mmRemoveQuestionsFromSet *mQuestionSetRepositoryMockRemoveQuestionsFromSet) invocationsDone() bool {
	if len(mmRemoveQuestionsFromSet.expectations) == 0 && mmRemoveQuestionsFromSet.defaultExpectation == nil && mmRemoveQuestionsFromSet.mock.funcRemoveQuestionsFromSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveQuestionsFromSet.mock.afterRemoveQuestionsFromSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveQuestionsFromSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveQuestionsFromSet implements mm_repository.QuestionSetRepository
func (mmRemoveQuestionsFromSet *QuestionSetRepositoryMock) RemoveQuestionsFromSet(ctx context.Context, setID int64, questionIDs []int64) (err error) {
	mm_atomic.AddUint64(&mmRemoveQuestionsFromSet.beforeRemoveQuestionsFromSetCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveQuestionsFromSet.afterRemoveQuestionsFromSetCounter, 1)

	mmRemoveQuestionsFromSet.t.Helper()

	if mmRemoveQuestionsFromSet.inspectFuncRemoveQuestionsFromSet != nil {
		mmRemoveQuestionsFromSet.inspectFuncRemoveQuestionsFromSet(ctx, setID, questionIDs)
	}

	mm_params := QuestionSetRepositoryMockRemoveQuestionsFromSetParams{ctx, setID, questionIDs}

	// Record call args
	mmRemoveQuestionsFromSet.RemoveQuestionsFromSetMock.mutex.Lock()
	mmRemoveQuestionsFromSet.RemoveQuestionsFromSetMock.callArgs = append(mmRemoveQuestionsFromSet.RemoveQuestionsFromSetMock.callArgs, &mm_params)
	mmRemoveQuestionsFromSet.RemoveQuestionsFromSetMock.mutex.Unlock()

	for _, e := range mmRemoveQuestionsFromSet.RemoveQuestionsFromSetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveQuestionsFromSet.RemoveQuestionsFromSetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveQuestionsFromSet.RemoveQuestionsFromSetMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveQuestionsFromSet.RemoveQuestionsFromSetMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveQuestionsFromSet.RemoveQuestionsFromSetMock.defaultExpectation.paramPtrs

		mm_got := QuestionSetRepositoryMockRemoveQuestionsFromSetParams{ctx, setID, questionIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveQuestionsFromSet.t.Errorf("QuestionSetRepositoryMock.RemoveQuestionsFromSet got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveQuestionsFromSet.RemoveQuestionsFromSetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.setID != nil && !minimock.Equal(*mm_want_ptrs.setID, mm_got.setID) {
				mmRemoveQuestionsFromSet.t.Errorf("QuestionSetRepositoryMock.RemoveQuestionsFromSet got unexpected parameter setID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveQuestionsFromSet.RemoveQuestionsFromSetMock.defaultExpectation.expectationOrigins.originSetID, *mm_want_ptrs.setID, mm_got.setID, minimock.Diff(*mm_want_ptrs.setID, mm_got.setID))
			}

			if mm_want_ptrs.questionIDs != nil && !minimock.Equal(*mm_want_ptrs.questionIDs, mm_got.questionIDs) {
				mmRemoveQuestionsFromSet.t.Errorf("QuestionSetRepositoryMock.RemoveQuestionsFromSet got unexpected parameter questionIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveQuestionsFromSet.RemoveQuestionsFromSetMock.defaultExpectation.expectationOrigins.originQuestionIDs, *mm_want_ptrs.questionIDs, mm_got.questionIDs, minimock.Diff(*mm_want_ptrs.questionIDs, mm_got.questionIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveQuestionsFromSet.t.Errorf("QuestionSetRepositoryMock.RemoveQuestionsFromSet got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveQuestionsFromSet.RemoveQuestionsFromSetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveQuestionsFromSet.RemoveQuestionsFromSetMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveQuestionsFromSet.t.Fatal("No results are set for the QuestionSetRepositoryMock.RemoveQuestionsFromSet")
		}
		return (*mm_results).err
	}
	if mmRemoveQuestionsFromSet.funcRemoveQuestionsFromSet != nil {
		return mmRemoveQuestionsFromSet.funcRemoveQuestionsFromSet(ctx, setID, questionIDs)
	}
	mmRemoveQuestionsFromSet.t.Fatalf("Unexpected call to QuestionSetRepositoryMock.RemoveQuestionsFromSet. %v %v %v", ctx, setID, questionIDs)
	return
}

// RemoveQuestionsFromSetAfterCounter returns a count of finished QuestionSetRepositoryMock.RemoveQuestionsFromSet invocations
func (mmRemoveQuestionsFromSet *QuestionSetRepositoryMock) RemoveQuestionsFromSetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveQuestionsFromSet.afterRemoveQuestionsFromSetCounter)
}

// RemoveQuestionsFromSetBeforeCounter returns a count of QuestionSetRepositoryMock.RemoveQuestionsFromSet invocations
func (mmRemoveQuestionsFromSet *QuestionSetRepositoryMock) RemoveQuestionsFromSetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveQuestionsFromSet.beforeRemoveQuestionsFromSetCounter)
}

// Calls returns a list of arguments used in each call to QuestionSetRepositoryMock.RemoveQuestionsFromSet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveQuestionsFromSet *mQuestionSetRepositoryMockRemoveQuestionsFromSet) Calls() []*QuestionSetRepositoryMockRemoveQuestionsFromSetParams {
	mmRemoveQuestionsFromSet.mutex.RLock()

	argCopy := make([]*QuestionSetRepositoryMockRemoveQuestionsFromSetParams, len(mmRemoveQuestionsFromSet.callArgs))
	copy(argCopy, mmRemoveQuestionsFromSet.callArgs)

	mmRemoveQuestionsFromSet.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveQuestionsFromSetDone returns true if the count of the RemoveQuestionsFromSet invocations corresponds
// the number of defined expectations
func (m *QuestionSetRepositoryMock) MinimockRemoveQuestionsFromSetDone() bool {
	if m.RemoveQuestionsFromSetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveQuestionsFromSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveQuestionsFromSetMock.invocationsDone()
}

// MinimockRemoveQuestionsFromSetInspect logs each unmet expectation
func (m *QuestionSetRepositoryMock) MinimockRemoveQuestionsFromSetInspect() {
	for _, e := range m.RemoveQuestionsFromSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.RemoveQuestionsFromSet at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveQuestionsFromSetCounter := mm_atomic.LoadUint64(&m.afterRemoveQuestionsFromSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveQuestionsFromSetMock.defaultExpectation != nil && afterRemoveQuestionsFromSetCounter < 1 {
		if m.RemoveQuestionsFromSetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.RemoveQuestionsFromSet at\n%s", m.RemoveQuestionsFromSetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.RemoveQuestionsFromSet at\n%s with params: %#v", m.RemoveQuestionsFromSetMock.defaultExpectation.expectationOrigins.origin, *m.RemoveQuestionsFromSetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveQuestionsFromSet != nil && afterRemoveQuestionsFromSetCounter < 1 {
		m.t.Errorf("Expected call to QuestionSetRepositoryMock.RemoveQuestionsFromSet at\n%s", m.funcRemoveQuestionsFromSetOrigin)
	}

	if !m.RemoveQuestionsFromSetMock.invocationsDone() && afterRemoveQuestionsFromSetCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSetRepositoryMock.RemoveQuestionsFromSet at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveQuestionsFromSetMock.expectedInvocations), m.RemoveQuestionsFromSetMock.expectedInvocationsOrigin, afterRemoveQuestionsFromSetCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *QuestionSetRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddQuestionToSetsInspect()

			m.MinimockAddQuestionsToSetInspect()

			m.MinimockListQuestionIDsBySetIDInspect()

			m.MinimockListSetIDsByQuestionIDInspect()

			m.MinimockRemoveQuestionFromSetsInspect()

			m.MinimockRemoveQuestionsFromSetInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *QuestionSetRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *QuestionSetRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddQuestionToSetsDone() &&
		m.MinimockAddQuestionsToSetDone() &&
		m.MinimockListQuestionIDsBySetIDDone() &&
		m.MinimockListSetIDsByQuestionIDDone() &&
		m.MinimockRemoveQuestionFromSetsDone() &&
		m.MinimockRemoveQuestionsFromSetDone()
}
