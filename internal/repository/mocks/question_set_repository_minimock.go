// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Kosfedev/learn_go/internal/repository.QuestionSetRepository -o question_set_repository_minimock.go -n QuestionSetRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Kosfedev/learn_go/internal/model"
	"github.com/gojuno/minimock/v3"
)

// QuestionSetRepositoryMock implements mm_repository.QuestionSetRepository
type QuestionSetRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, question *model.NewQuestionSet) (i1 int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, question *model.NewQuestionSet)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mQuestionSetRepositoryMockCreate

	funcDelete          func(ctx context.Context, id int64) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mQuestionSetRepositoryMockDelete

	funcGet          func(ctx context.Context, id int64) (qp1 *model.QuestionSet, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id int64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mQuestionSetRepositoryMockGet

	funcUpdate          func(ctx context.Context, id int64, updatedQuestion *model.UpdatedQuestionSet) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, id int64, updatedQuestion *model.UpdatedQuestionSet)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mQuestionSetRepositoryMockUpdate
}

// NewQuestionSetRepositoryMock returns a mock for mm_repository.QuestionSetRepository
func NewQuestionSetRepositoryMock(t minimock.Tester) *QuestionSetRepositoryMock {
	m := &QuestionSetRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mQuestionSetRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*QuestionSetRepositoryMockCreateParams{}

	m.DeleteMock = mQuestionSetRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*QuestionSetRepositoryMockDeleteParams{}

	m.GetMock = mQuestionSetRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*QuestionSetRepositoryMockGetParams{}

	m.UpdateMock = mQuestionSetRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*QuestionSetRepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mQuestionSetRepositoryMockCreate struct {
	optional           bool
	mock               *QuestionSetRepositoryMock
	defaultExpectation *QuestionSetRepositoryMockCreateExpectation
	expectations       []*QuestionSetRepositoryMockCreateExpectation

	callArgs []*QuestionSetRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSetRepositoryMockCreateExpectation specifies expectation struct of the QuestionSetRepository.Create
type QuestionSetRepositoryMockCreateExpectation struct {
	mock               *QuestionSetRepositoryMock
	params             *QuestionSetRepositoryMockCreateParams
	paramPtrs          *QuestionSetRepositoryMockCreateParamPtrs
	expectationOrigins QuestionSetRepositoryMockCreateExpectationOrigins
	results            *QuestionSetRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSetRepositoryMockCreateParams contains parameters of the QuestionSetRepository.Create
type QuestionSetRepositoryMockCreateParams struct {
	ctx      context.Context
	question *model.NewQuestionSet
}

// QuestionSetRepositoryMockCreateParamPtrs contains pointers to parameters of the QuestionSetRepository.Create
type QuestionSetRepositoryMockCreateParamPtrs struct {
	ctx      *context.Context
	question **model.NewQuestionSet
}

// QuestionSetRepositoryMockCreateResults contains results of the QuestionSetRepository.Create
type QuestionSetRepositoryMockCreateResults struct {
	i1  int64
	err error
}

// QuestionSetRepositoryMockCreateOrigins contains origins of expectations of the QuestionSetRepository.Create
type QuestionSetRepositoryMockCreateExpectationOrigins struct {
	origin         string
	originCtx      string
	originQuestion string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mQuestionSetRepositoryMockCreate) Optional() *mQuestionSetRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for QuestionSetRepository.Create
func (mmCreate *mQuestionSetRepositoryMockCreate) Expect(ctx context.Context, question *model.NewQuestionSet) *mQuestionSetRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("QuestionSetRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &QuestionSetRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("QuestionSetRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &QuestionSetRepositoryMockCreateParams{ctx, question}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSetRepository.Create
func (mmCreate *mQuestionSetRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mQuestionSetRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("QuestionSetRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &QuestionSetRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("QuestionSetRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectQuestionParam2 sets up expected param question for QuestionSetRepository.Create
func (mmCreate *mQuestionSetRepositoryMockCreate) ExpectQuestionParam2(question *model.NewQuestionSet) *mQuestionSetRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("QuestionSetRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &QuestionSetRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("QuestionSetRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.question = &question
	mmCreate.defaultExpectation.expectationOrigins.originQuestion = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the QuestionSetRepository.Create
func (mmCreate *mQuestionSetRepositoryMockCreate) Inspect(f func(ctx context.Context, question *model.NewQuestionSet)) *mQuestionSetRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for QuestionSetRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by QuestionSetRepository.Create
func (mmCreate *mQuestionSetRepositoryMockCreate) Return(i1 int64, err error) *QuestionSetRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("QuestionSetRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &QuestionSetRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &QuestionSetRepositoryMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the QuestionSetRepository.Create method
func (mmCreate *mQuestionSetRepositoryMockCreate) Set(f func(ctx context.Context, question *model.NewQuestionSet) (i1 int64, err error)) *QuestionSetRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the QuestionSetRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the QuestionSetRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the QuestionSetRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mQuestionSetRepositoryMockCreate) When(ctx context.Context, question *model.NewQuestionSet) *QuestionSetRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("QuestionSetRepositoryMock.Create mock is already set by Set")
	}

	expectation := &QuestionSetRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &QuestionSetRepositoryMockCreateParams{ctx, question},
		expectationOrigins: QuestionSetRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up QuestionSetRepository.Create return parameters for the expectation previously defined by the When method
func (e *QuestionSetRepositoryMockCreateExpectation) Then(i1 int64, err error) *QuestionSetRepositoryMock {
	e.results = &QuestionSetRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times QuestionSetRepository.Create should be invoked
func (mmCreate *mQuestionSetRepositoryMockCreate) Times(n uint64) *mQuestionSetRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of QuestionSetRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mQuestionSetRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_repository.QuestionSetRepository
func (mmCreate *QuestionSetRepositoryMock) Create(ctx context.Context, question *model.NewQuestionSet) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, question)
	}

	mm_params := QuestionSetRepositoryMockCreateParams{ctx, question}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := QuestionSetRepositoryMockCreateParams{ctx, question}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("QuestionSetRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.question != nil && !minimock.Equal(*mm_want_ptrs.question, mm_got.question) {
				mmCreate.t.Errorf("QuestionSetRepositoryMock.Create got unexpected parameter question, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originQuestion, *mm_want_ptrs.question, mm_got.question, minimock.Diff(*mm_want_ptrs.question, mm_got.question))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("QuestionSetRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the QuestionSetRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, question)
	}
	mmCreate.t.Fatalf("Unexpected call to QuestionSetRepositoryMock.Create. %v %v", ctx, question)
	return
}

// CreateAfterCounter returns a count of finished QuestionSetRepositoryMock.Create invocations
func (mmCreate *QuestionSetRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of QuestionSetRepositoryMock.Create invocations
func (mmCreate *QuestionSetRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to QuestionSetRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mQuestionSetRepositoryMockCreate) Calls() []*QuestionSetRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*QuestionSetRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *QuestionSetRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *QuestionSetRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to QuestionSetRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSetRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mQuestionSetRepositoryMockDelete struct {
	optional           bool
	mock               *QuestionSetRepositoryMock
	defaultExpectation *QuestionSetRepositoryMockDeleteExpectation
	expectations       []*QuestionSetRepositoryMockDeleteExpectation

	callArgs []*QuestionSetRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSetRepositoryMockDeleteExpectation specifies expectation struct of the QuestionSetRepository.Delete
type QuestionSetRepositoryMockDeleteExpectation struct {
	mock               *QuestionSetRepositoryMock
	params             *QuestionSetRepositoryMockDeleteParams
	paramPtrs          *QuestionSetRepositoryMockDeleteParamPtrs
	expectationOrigins QuestionSetRepositoryMockDeleteExpectationOrigins
	results            *QuestionSetRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSetRepositoryMockDeleteParams contains parameters of the QuestionSetRepository.Delete
type QuestionSetRepositoryMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// QuestionSetRepositoryMockDeleteParamPtrs contains pointers to parameters of the QuestionSetRepository.Delete
type QuestionSetRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// QuestionSetRepositoryMockDeleteResults contains results of the QuestionSetRepository.Delete
type QuestionSetRepositoryMockDeleteResults struct {
	err error
}

// QuestionSetRepositoryMockDeleteOrigins contains origins of expectations of the QuestionSetRepository.Delete
type QuestionSetRepositoryMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mQuestionSetRepositoryMockDelete) Optional() *mQuestionSetRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for QuestionSetRepository.Delete
func (mmDelete *mQuestionSetRepositoryMockDelete) Expect(ctx context.Context, id int64) *mQuestionSetRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("QuestionSetRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &QuestionSetRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("QuestionSetRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &QuestionSetRepositoryMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSetRepository.Delete
func (mmDelete *mQuestionSetRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mQuestionSetRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("QuestionSetRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &QuestionSetRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("QuestionSetRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for QuestionSetRepository.Delete
func (mmDelete *mQuestionSetRepositoryMockDelete) ExpectIdParam2(id int64) *mQuestionSetRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("QuestionSetRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &QuestionSetRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("QuestionSetRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the QuestionSetRepository.Delete
func (mmDelete *mQuestionSetRepositoryMockDelete) Inspect(f func(ctx context.Context, id int64)) *mQuestionSetRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for QuestionSetRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by QuestionSetRepository.Delete
func (mmDelete *mQuestionSetRepositoryMockDelete) Return(err error) *QuestionSetRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("QuestionSetRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &QuestionSetRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &QuestionSetRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the QuestionSetRepository.Delete method
func (mmDelete *mQuestionSetRepositoryMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *QuestionSetRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the QuestionSetRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the QuestionSetRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the QuestionSetRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mQuestionSetRepositoryMockDelete) When(ctx context.Context, id int64) *QuestionSetRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("QuestionSetRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &QuestionSetRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &QuestionSetRepositoryMockDeleteParams{ctx, id},
		expectationOrigins: QuestionSetRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up QuestionSetRepository.Delete return parameters for the expectation previously defined by the When method
func (e *QuestionSetRepositoryMockDeleteExpectation) Then(err error) *QuestionSetRepositoryMock {
	e.results = &QuestionSetRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times QuestionSetRepository.Delete should be invoked
func (mmDelete *mQuestionSetRepositoryMockDelete) Times(n uint64) *mQuestionSetRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of QuestionSetRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mQuestionSetRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_repository.QuestionSetRepository
func (mmDelete *QuestionSetRepositoryMock) Delete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := QuestionSetRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := QuestionSetRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("QuestionSetRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("QuestionSetRepositoryMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("QuestionSetRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the QuestionSetRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to QuestionSetRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished QuestionSetRepositoryMock.Delete invocations
func (mmDelete *QuestionSetRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of QuestionSetRepositoryMock.Delete invocations
func (mmDelete *QuestionSetRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to QuestionSetRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mQuestionSetRepositoryMockDelete) Calls() []*QuestionSetRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*QuestionSetRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *QuestionSetRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *QuestionSetRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to QuestionSetRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSetRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mQuestionSetRepositoryMockGet struct {
	optional           bool
	mock               *QuestionSetRepositoryMock
	defaultExpectation *QuestionSetRepositoryMockGetExpectation
	expectations       []*QuestionSetRepositoryMockGetExpectation

	callArgs []*QuestionSetRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSetRepositoryMockGetExpectation specifies expectation struct of the QuestionSetRepository.Get
type QuestionSetRepositoryMockGetExpectation struct {
	mock               *QuestionSetRepositoryMock
	params             *QuestionSetRepositoryMockGetParams
	paramPtrs          *QuestionSetRepositoryMockGetParamPtrs
	expectationOrigins QuestionSetRepositoryMockGetExpectationOrigins
	results            *QuestionSetRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSetRepositoryMockGetParams contains parameters of the QuestionSetRepository.Get
type QuestionSetRepositoryMockGetParams struct {
	ctx context.Context
	id  int64
}

// QuestionSetRepositoryMockGetParamPtrs contains pointers to parameters of the QuestionSetRepository.Get
type QuestionSetRepositoryMockGetParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// QuestionSetRepositoryMockGetResults contains results of the QuestionSetRepository.Get
type QuestionSetRepositoryMockGetResults struct {
	qp1 *model.QuestionSet
	err error
}

// QuestionSetRepositoryMockGetOrigins contains origins of expectations of the QuestionSetRepository.Get
type QuestionSetRepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mQuestionSetRepositoryMockGet) Optional() *mQuestionSetRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for QuestionSetRepository.Get
func (mmGet *mQuestionSetRepositoryMockGet) Expect(ctx context.Context, id int64) *mQuestionSetRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("QuestionSetRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &QuestionSetRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("QuestionSetRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &QuestionSetRepositoryMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSetRepository.Get
func (mmGet *mQuestionSetRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mQuestionSetRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("QuestionSetRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &QuestionSetRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("QuestionSetRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for QuestionSetRepository.Get
func (mmGet *mQuestionSetRepositoryMockGet) ExpectIdParam2(id int64) *mQuestionSetRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("QuestionSetRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &QuestionSetRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("QuestionSetRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the QuestionSetRepository.Get
func (mmGet *mQuestionSetRepositoryMockGet) Inspect(f func(ctx context.Context, id int64)) *mQuestionSetRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for QuestionSetRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by QuestionSetRepository.Get
func (mmGet *mQuestionSetRepositoryMockGet) Return(qp1 *model.QuestionSet, err error) *QuestionSetRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("QuestionSetRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &QuestionSetRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &QuestionSetRepositoryMockGetResults{qp1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the QuestionSetRepository.Get method
func (mmGet *mQuestionSetRepositoryMockGet) Set(f func(ctx context.Context, id int64) (qp1 *model.QuestionSet, err error)) *QuestionSetRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the QuestionSetRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the QuestionSetRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the QuestionSetRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mQuestionSetRepositoryMockGet) When(ctx context.Context, id int64) *QuestionSetRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("QuestionSetRepositoryMock.Get mock is already set by Set")
	}

	expectation := &QuestionSetRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &QuestionSetRepositoryMockGetParams{ctx, id},
		expectationOrigins: QuestionSetRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up QuestionSetRepository.Get return parameters for the expectation previously defined by the When method
func (e *QuestionSetRepositoryMockGetExpectation) Then(qp1 *model.QuestionSet, err error) *QuestionSetRepositoryMock {
	e.results = &QuestionSetRepositoryMockGetResults{qp1, err}
	return e.mock
}

// Times sets number of times QuestionSetRepository.Get should be invoked
func (mmGet *mQuestionSetRepositoryMockGet) Times(n uint64) *mQuestionSetRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of QuestionSetRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mQuestionSetRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.QuestionSetRepository
func (mmGet *QuestionSetRepositoryMock) Get(ctx context.Context, id int64) (qp1 *model.QuestionSet, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := QuestionSetRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.qp1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := QuestionSetRepositoryMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("QuestionSetRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("QuestionSetRepositoryMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("QuestionSetRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the QuestionSetRepositoryMock.Get")
		}
		return (*mm_results).qp1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to QuestionSetRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished QuestionSetRepositoryMock.Get invocations
func (mmGet *QuestionSetRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of QuestionSetRepositoryMock.Get invocations
func (mmGet *QuestionSetRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to QuestionSetRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mQuestionSetRepositoryMockGet) Calls() []*QuestionSetRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*QuestionSetRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *QuestionSetRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *QuestionSetRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to QuestionSetRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSetRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mQuestionSetRepositoryMockUpdate struct {
	optional           bool
	mock               *QuestionSetRepositoryMock
	defaultExpectation *QuestionSetRepositoryMockUpdateExpectation
	expectations       []*QuestionSetRepositoryMockUpdateExpectation

	callArgs []*QuestionSetRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// QuestionSetRepositoryMockUpdateExpectation specifies expectation struct of the QuestionSetRepository.Update
type QuestionSetRepositoryMockUpdateExpectation struct {
	mock               *QuestionSetRepositoryMock
	params             *QuestionSetRepositoryMockUpdateParams
	paramPtrs          *QuestionSetRepositoryMockUpdateParamPtrs
	expectationOrigins QuestionSetRepositoryMockUpdateExpectationOrigins
	results            *QuestionSetRepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// QuestionSetRepositoryMockUpdateParams contains parameters of the QuestionSetRepository.Update
type QuestionSetRepositoryMockUpdateParams struct {
	ctx             context.Context
	id              int64
	updatedQuestion *model.UpdatedQuestionSet
}

// QuestionSetRepositoryMockUpdateParamPtrs contains pointers to parameters of the QuestionSetRepository.Update
type QuestionSetRepositoryMockUpdateParamPtrs struct {
	ctx             *context.Context
	id              *int64
	updatedQuestion **model.UpdatedQuestionSet
}

// QuestionSetRepositoryMockUpdateResults contains results of the QuestionSetRepository.Update
type QuestionSetRepositoryMockUpdateResults struct {
	err error
}

// QuestionSetRepositoryMockUpdateOrigins contains origins of expectations of the QuestionSetRepository.Update
type QuestionSetRepositoryMockUpdateExpectationOrigins struct {
	origin                string
	originCtx             string
	originId              string
	originUpdatedQuestion string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mQuestionSetRepositoryMockUpdate) Optional() *mQuestionSetRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for QuestionSetRepository.Update
func (mmUpdate *mQuestionSetRepositoryMockUpdate) Expect(ctx context.Context, id int64, updatedQuestion *model.UpdatedQuestionSet) *mQuestionSetRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("QuestionSetRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &QuestionSetRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("QuestionSetRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &QuestionSetRepositoryMockUpdateParams{ctx, id, updatedQuestion}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for QuestionSetRepository.Update
func (mmUpdate *mQuestionSetRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mQuestionSetRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("QuestionSetRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &QuestionSetRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("QuestionSetRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectIdParam2 sets up expected param id for QuestionSetRepository.Update
func (mmUpdate *mQuestionSetRepositoryMockUpdate) ExpectIdParam2(id int64) *mQuestionSetRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("QuestionSetRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &QuestionSetRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("QuestionSetRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.id = &id
	mmUpdate.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectUpdatedQuestionParam3 sets up expected param updatedQuestion for QuestionSetRepository.Update
func (mmUpdate *mQuestionSetRepositoryMockUpdate) ExpectUpdatedQuestionParam3(updatedQuestion *model.UpdatedQuestionSet) *mQuestionSetRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("QuestionSetRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &QuestionSetRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("QuestionSetRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &QuestionSetRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.updatedQuestion = &updatedQuestion
	mmUpdate.defaultExpectation.expectationOrigins.originUpdatedQuestion = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the QuestionSetRepository.Update
func (mmUpdate *mQuestionSetRepositoryMockUpdate) Inspect(f func(ctx context.Context, id int64, updatedQuestion *model.UpdatedQuestionSet)) *mQuestionSetRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for QuestionSetRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by QuestionSetRepository.Update
func (mmUpdate *mQuestionSetRepositoryMockUpdate) Return(err error) *QuestionSetRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("QuestionSetRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &QuestionSetRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &QuestionSetRepositoryMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the QuestionSetRepository.Update method
func (mmUpdate *mQuestionSetRepositoryMockUpdate) Set(f func(ctx context.Context, id int64, updatedQuestion *model.UpdatedQuestionSet) (err error)) *QuestionSetRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the QuestionSetRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the QuestionSetRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the QuestionSetRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mQuestionSetRepositoryMockUpdate) When(ctx context.Context, id int64, updatedQuestion *model.UpdatedQuestionSet) *QuestionSetRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("QuestionSetRepositoryMock.Update mock is already set by Set")
	}

	expectation := &QuestionSetRepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &QuestionSetRepositoryMockUpdateParams{ctx, id, updatedQuestion},
		expectationOrigins: QuestionSetRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up QuestionSetRepository.Update return parameters for the expectation previously defined by the When method
func (e *QuestionSetRepositoryMockUpdateExpectation) Then(err error) *QuestionSetRepositoryMock {
	e.results = &QuestionSetRepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times QuestionSetRepository.Update should be invoked
func (mmUpdate *mQuestionSetRepositoryMockUpdate) Times(n uint64) *mQuestionSetRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of QuestionSetRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mQuestionSetRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_repository.QuestionSetRepository
func (mmUpdate *QuestionSetRepositoryMock) Update(ctx context.Context, id int64, updatedQuestion *model.UpdatedQuestionSet) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, id, updatedQuestion)
	}

	mm_params := QuestionSetRepositoryMockUpdateParams{ctx, id, updatedQuestion}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := QuestionSetRepositoryMockUpdateParams{ctx, id, updatedQuestion}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("QuestionSetRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdate.t.Errorf("QuestionSetRepositoryMock.Update got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.updatedQuestion != nil && !minimock.Equal(*mm_want_ptrs.updatedQuestion, mm_got.updatedQuestion) {
				mmUpdate.t.Errorf("QuestionSetRepositoryMock.Update got unexpected parameter updatedQuestion, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originUpdatedQuestion, *mm_want_ptrs.updatedQuestion, mm_got.updatedQuestion, minimock.Diff(*mm_want_ptrs.updatedQuestion, mm_got.updatedQuestion))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("QuestionSetRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the QuestionSetRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, id, updatedQuestion)
	}
	mmUpdate.t.Fatalf("Unexpected call to QuestionSetRepositoryMock.Update. %v %v %v", ctx, id, updatedQuestion)
	return
}

// UpdateAfterCounter returns a count of finished QuestionSetRepositoryMock.Update invocations
func (mmUpdate *QuestionSetRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of QuestionSetRepositoryMock.Update invocations
func (mmUpdate *QuestionSetRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to QuestionSetRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mQuestionSetRepositoryMockUpdate) Calls() []*QuestionSetRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*QuestionSetRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *QuestionSetRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *QuestionSetRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to QuestionSetRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to QuestionSetRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to QuestionSetRepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *QuestionSetRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *QuestionSetRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *QuestionSetRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockUpdateDone()
}
