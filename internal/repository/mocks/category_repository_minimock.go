// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Kosfedev/learn_go/internal/repository.CategoryRepository -o category_repository_minimock.go -n CategoryRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Kosfedev/learn_go/internal/model"
	"github.com/gojuno/minimock/v3"
)

// CategoryRepositoryMock implements mm_repository.CategoryRepository
type CategoryRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, category *model.NewCategory) (i1 int, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, category *model.NewCategory)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mCategoryRepositoryMockCreate

	funcDelete          func(ctx context.Context, id int) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id int)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mCategoryRepositoryMockDelete

	funcGet          func(ctx context.Context, id int) (cp1 *model.Category, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id int)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mCategoryRepositoryMockGet

	funcUpdate          func(ctx context.Context, id int, updatedCategory *model.UpdatedCategory) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, id int, updatedCategory *model.UpdatedCategory)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mCategoryRepositoryMockUpdate
}

// NewCategoryRepositoryMock returns a mock for mm_repository.CategoryRepository
func NewCategoryRepositoryMock(t minimock.Tester) *CategoryRepositoryMock {
	m := &CategoryRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mCategoryRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*CategoryRepositoryMockCreateParams{}

	m.DeleteMock = mCategoryRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*CategoryRepositoryMockDeleteParams{}

	m.GetMock = mCategoryRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*CategoryRepositoryMockGetParams{}

	m.UpdateMock = mCategoryRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*CategoryRepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCategoryRepositoryMockCreate struct {
	optional           bool
	mock               *CategoryRepositoryMock
	defaultExpectation *CategoryRepositoryMockCreateExpectation
	expectations       []*CategoryRepositoryMockCreateExpectation

	callArgs []*CategoryRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CategoryRepositoryMockCreateExpectation specifies expectation struct of the CategoryRepository.Create
type CategoryRepositoryMockCreateExpectation struct {
	mock               *CategoryRepositoryMock
	params             *CategoryRepositoryMockCreateParams
	paramPtrs          *CategoryRepositoryMockCreateParamPtrs
	expectationOrigins CategoryRepositoryMockCreateExpectationOrigins
	results            *CategoryRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// CategoryRepositoryMockCreateParams contains parameters of the CategoryRepository.Create
type CategoryRepositoryMockCreateParams struct {
	ctx      context.Context
	category *model.NewCategory
}

// CategoryRepositoryMockCreateParamPtrs contains pointers to parameters of the CategoryRepository.Create
type CategoryRepositoryMockCreateParamPtrs struct {
	ctx      *context.Context
	category **model.NewCategory
}

// CategoryRepositoryMockCreateResults contains results of the CategoryRepository.Create
type CategoryRepositoryMockCreateResults struct {
	i1  int
	err error
}

// CategoryRepositoryMockCreateOrigins contains origins of expectations of the CategoryRepository.Create
type CategoryRepositoryMockCreateExpectationOrigins struct {
	origin         string
	originCtx      string
	originCategory string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mCategoryRepositoryMockCreate) Optional() *mCategoryRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for CategoryRepository.Create
func (mmCreate *mCategoryRepositoryMockCreate) Expect(ctx context.Context, category *model.NewCategory) *mCategoryRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CategoryRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &CategoryRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("CategoryRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &CategoryRepositoryMockCreateParams{ctx, category}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for CategoryRepository.Create
func (mmCreate *mCategoryRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mCategoryRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CategoryRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &CategoryRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("CategoryRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &CategoryRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectCategoryParam2 sets up expected param category for CategoryRepository.Create
func (mmCreate *mCategoryRepositoryMockCreate) ExpectCategoryParam2(category *model.NewCategory) *mCategoryRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CategoryRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &CategoryRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("CategoryRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &CategoryRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.category = &category
	mmCreate.defaultExpectation.expectationOrigins.originCategory = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the CategoryRepository.Create
func (mmCreate *mCategoryRepositoryMockCreate) Inspect(f func(ctx context.Context, category *model.NewCategory)) *mCategoryRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for CategoryRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by CategoryRepository.Create
func (mmCreate *mCategoryRepositoryMockCreate) Return(i1 int, err error) *CategoryRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CategoryRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &CategoryRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &CategoryRepositoryMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the CategoryRepository.Create method
func (mmCreate *mCategoryRepositoryMockCreate) Set(f func(ctx context.Context, category *model.NewCategory) (i1 int, err error)) *CategoryRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the CategoryRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the CategoryRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the CategoryRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mCategoryRepositoryMockCreate) When(ctx context.Context, category *model.NewCategory) *CategoryRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CategoryRepositoryMock.Create mock is already set by Set")
	}

	expectation := &CategoryRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &CategoryRepositoryMockCreateParams{ctx, category},
		expectationOrigins: CategoryRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up CategoryRepository.Create return parameters for the expectation previously defined by the When method
func (e *CategoryRepositoryMockCreateExpectation) Then(i1 int, err error) *CategoryRepositoryMock {
	e.results = &CategoryRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times CategoryRepository.Create should be invoked
func (mmCreate *mCategoryRepositoryMockCreate) Times(n uint64) *mCategoryRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of CategoryRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mCategoryRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_repository.CategoryRepository
func (mmCreate *CategoryRepositoryMock) Create(ctx context.Context, category *model.NewCategory) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, category)
	}

	mm_params := CategoryRepositoryMockCreateParams{ctx, category}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := CategoryRepositoryMockCreateParams{ctx, category}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("CategoryRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.category != nil && !minimock.Equal(*mm_want_ptrs.category, mm_got.category) {
				mmCreate.t.Errorf("CategoryRepositoryMock.Create got unexpected parameter category, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCategory, *mm_want_ptrs.category, mm_got.category, minimock.Diff(*mm_want_ptrs.category, mm_got.category))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("CategoryRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the CategoryRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, category)
	}
	mmCreate.t.Fatalf("Unexpected call to CategoryRepositoryMock.Create. %v %v", ctx, category)
	return
}

// CreateAfterCounter returns a count of finished CategoryRepositoryMock.Create invocations
func (mmCreate *CategoryRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of CategoryRepositoryMock.Create invocations
func (mmCreate *CategoryRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to CategoryRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mCategoryRepositoryMockCreate) Calls() []*CategoryRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*CategoryRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *CategoryRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *CategoryRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CategoryRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CategoryRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CategoryRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to CategoryRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to CategoryRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mCategoryRepositoryMockDelete struct {
	optional           bool
	mock               *CategoryRepositoryMock
	defaultExpectation *CategoryRepositoryMockDeleteExpectation
	expectations       []*CategoryRepositoryMockDeleteExpectation

	callArgs []*CategoryRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CategoryRepositoryMockDeleteExpectation specifies expectation struct of the CategoryRepository.Delete
type CategoryRepositoryMockDeleteExpectation struct {
	mock               *CategoryRepositoryMock
	params             *CategoryRepositoryMockDeleteParams
	paramPtrs          *CategoryRepositoryMockDeleteParamPtrs
	expectationOrigins CategoryRepositoryMockDeleteExpectationOrigins
	results            *CategoryRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// CategoryRepositoryMockDeleteParams contains parameters of the CategoryRepository.Delete
type CategoryRepositoryMockDeleteParams struct {
	ctx context.Context
	id  int
}

// CategoryRepositoryMockDeleteParamPtrs contains pointers to parameters of the CategoryRepository.Delete
type CategoryRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int
}

// CategoryRepositoryMockDeleteResults contains results of the CategoryRepository.Delete
type CategoryRepositoryMockDeleteResults struct {
	err error
}

// CategoryRepositoryMockDeleteOrigins contains origins of expectations of the CategoryRepository.Delete
type CategoryRepositoryMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mCategoryRepositoryMockDelete) Optional() *mCategoryRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for CategoryRepository.Delete
func (mmDelete *mCategoryRepositoryMockDelete) Expect(ctx context.Context, id int) *mCategoryRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CategoryRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CategoryRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("CategoryRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &CategoryRepositoryMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for CategoryRepository.Delete
func (mmDelete *mCategoryRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mCategoryRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CategoryRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CategoryRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("CategoryRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &CategoryRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for CategoryRepository.Delete
func (mmDelete *mCategoryRepositoryMockDelete) ExpectIdParam2(id int) *mCategoryRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CategoryRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CategoryRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("CategoryRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &CategoryRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the CategoryRepository.Delete
func (mmDelete *mCategoryRepositoryMockDelete) Inspect(f func(ctx context.Context, id int)) *mCategoryRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for CategoryRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by CategoryRepository.Delete
func (mmDelete *mCategoryRepositoryMockDelete) Return(err error) *CategoryRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CategoryRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CategoryRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &CategoryRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the CategoryRepository.Delete method
func (mmDelete *mCategoryRepositoryMockDelete) Set(f func(ctx context.Context, id int) (err error)) *CategoryRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the CategoryRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the CategoryRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the CategoryRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mCategoryRepositoryMockDelete) When(ctx context.Context, id int) *CategoryRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CategoryRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &CategoryRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &CategoryRepositoryMockDeleteParams{ctx, id},
		expectationOrigins: CategoryRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up CategoryRepository.Delete return parameters for the expectation previously defined by the When method
func (e *CategoryRepositoryMockDeleteExpectation) Then(err error) *CategoryRepositoryMock {
	e.results = &CategoryRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times CategoryRepository.Delete should be invoked
func (mmDelete *mCategoryRepositoryMockDelete) Times(n uint64) *mCategoryRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of CategoryRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mCategoryRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_repository.CategoryRepository
func (mmDelete *CategoryRepositoryMock) Delete(ctx context.Context, id int) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := CategoryRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := CategoryRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("CategoryRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("CategoryRepositoryMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("CategoryRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the CategoryRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to CategoryRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished CategoryRepositoryMock.Delete invocations
func (mmDelete *CategoryRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of CategoryRepositoryMock.Delete invocations
func (mmDelete *CategoryRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to CategoryRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mCategoryRepositoryMockDelete) Calls() []*CategoryRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*CategoryRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *CategoryRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *CategoryRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CategoryRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CategoryRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CategoryRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to CategoryRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to CategoryRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mCategoryRepositoryMockGet struct {
	optional           bool
	mock               *CategoryRepositoryMock
	defaultExpectation *CategoryRepositoryMockGetExpectation
	expectations       []*CategoryRepositoryMockGetExpectation

	callArgs []*CategoryRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CategoryRepositoryMockGetExpectation specifies expectation struct of the CategoryRepository.Get
type CategoryRepositoryMockGetExpectation struct {
	mock               *CategoryRepositoryMock
	params             *CategoryRepositoryMockGetParams
	paramPtrs          *CategoryRepositoryMockGetParamPtrs
	expectationOrigins CategoryRepositoryMockGetExpectationOrigins
	results            *CategoryRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// CategoryRepositoryMockGetParams contains parameters of the CategoryRepository.Get
type CategoryRepositoryMockGetParams struct {
	ctx context.Context
	id  int
}

// CategoryRepositoryMockGetParamPtrs contains pointers to parameters of the CategoryRepository.Get
type CategoryRepositoryMockGetParamPtrs struct {
	ctx *context.Context
	id  *int
}

// CategoryRepositoryMockGetResults contains results of the CategoryRepository.Get
type CategoryRepositoryMockGetResults struct {
	cp1 *model.Category
	err error
}

// CategoryRepositoryMockGetOrigins contains origins of expectations of the CategoryRepository.Get
type CategoryRepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mCategoryRepositoryMockGet) Optional() *mCategoryRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for CategoryRepository.Get
func (mmGet *mCategoryRepositoryMockGet) Expect(ctx context.Context, id int) *mCategoryRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CategoryRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CategoryRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("CategoryRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &CategoryRepositoryMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for CategoryRepository.Get
func (mmGet *mCategoryRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mCategoryRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CategoryRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CategoryRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("CategoryRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &CategoryRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for CategoryRepository.Get
func (mmGet *mCategoryRepositoryMockGet) ExpectIdParam2(id int) *mCategoryRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CategoryRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CategoryRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("CategoryRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &CategoryRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the CategoryRepository.Get
func (mmGet *mCategoryRepositoryMockGet) Inspect(f func(ctx context.Context, id int)) *mCategoryRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for CategoryRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by CategoryRepository.Get
func (mmGet *mCategoryRepositoryMockGet) Return(cp1 *model.Category, err error) *CategoryRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CategoryRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CategoryRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &CategoryRepositoryMockGetResults{cp1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the CategoryRepository.Get method
func (mmGet *mCategoryRepositoryMockGet) Set(f func(ctx context.Context, id int) (cp1 *model.Category, err error)) *CategoryRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the CategoryRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the CategoryRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the CategoryRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mCategoryRepositoryMockGet) When(ctx context.Context, id int) *CategoryRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CategoryRepositoryMock.Get mock is already set by Set")
	}

	expectation := &CategoryRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &CategoryRepositoryMockGetParams{ctx, id},
		expectationOrigins: CategoryRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up CategoryRepository.Get return parameters for the expectation previously defined by the When method
func (e *CategoryRepositoryMockGetExpectation) Then(cp1 *model.Category, err error) *CategoryRepositoryMock {
	e.results = &CategoryRepositoryMockGetResults{cp1, err}
	return e.mock
}

// Times sets number of times CategoryRepository.Get should be invoked
func (mmGet *mCategoryRepositoryMockGet) Times(n uint64) *mCategoryRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of CategoryRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mCategoryRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.CategoryRepository
func (mmGet *CategoryRepositoryMock) Get(ctx context.Context, id int) (cp1 *model.Category, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := CategoryRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := CategoryRepositoryMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("CategoryRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("CategoryRepositoryMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("CategoryRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the CategoryRepositoryMock.Get")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to CategoryRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished CategoryRepositoryMock.Get invocations
func (mmGet *CategoryRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of CategoryRepositoryMock.Get invocations
func (mmGet *CategoryRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to CategoryRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mCategoryRepositoryMockGet) Calls() []*CategoryRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*CategoryRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *CategoryRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *CategoryRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CategoryRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CategoryRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CategoryRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to CategoryRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to CategoryRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mCategoryRepositoryMockUpdate struct {
	optional           bool
	mock               *CategoryRepositoryMock
	defaultExpectation *CategoryRepositoryMockUpdateExpectation
	expectations       []*CategoryRepositoryMockUpdateExpectation

	callArgs []*CategoryRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CategoryRepositoryMockUpdateExpectation specifies expectation struct of the CategoryRepository.Update
type CategoryRepositoryMockUpdateExpectation struct {
	mock               *CategoryRepositoryMock
	params             *CategoryRepositoryMockUpdateParams
	paramPtrs          *CategoryRepositoryMockUpdateParamPtrs
	expectationOrigins CategoryRepositoryMockUpdateExpectationOrigins
	results            *CategoryRepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// CategoryRepositoryMockUpdateParams contains parameters of the CategoryRepository.Update
type CategoryRepositoryMockUpdateParams struct {
	ctx             context.Context
	id              int
	updatedCategory *model.UpdatedCategory
}

// CategoryRepositoryMockUpdateParamPtrs contains pointers to parameters of the CategoryRepository.Update
type CategoryRepositoryMockUpdateParamPtrs struct {
	ctx             *context.Context
	id              *int
	updatedCategory **model.UpdatedCategory
}

// CategoryRepositoryMockUpdateResults contains results of the CategoryRepository.Update
type CategoryRepositoryMockUpdateResults struct {
	err error
}

// CategoryRepositoryMockUpdateOrigins contains origins of expectations of the CategoryRepository.Update
type CategoryRepositoryMockUpdateExpectationOrigins struct {
	origin                string
	originCtx             string
	originId              string
	originUpdatedCategory string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mCategoryRepositoryMockUpdate) Optional() *mCategoryRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for CategoryRepository.Update
func (mmUpdate *mCategoryRepositoryMockUpdate) Expect(ctx context.Context, id int, updatedCategory *model.UpdatedCategory) *mCategoryRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CategoryRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &CategoryRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("CategoryRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &CategoryRepositoryMockUpdateParams{ctx, id, updatedCategory}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for CategoryRepository.Update
func (mmUpdate *mCategoryRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mCategoryRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CategoryRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &CategoryRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("CategoryRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &CategoryRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectIdParam2 sets up expected param id for CategoryRepository.Update
func (mmUpdate *mCategoryRepositoryMockUpdate) ExpectIdParam2(id int) *mCategoryRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CategoryRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &CategoryRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("CategoryRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &CategoryRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.id = &id
	mmUpdate.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectUpdatedCategoryParam3 sets up expected param updatedCategory for CategoryRepository.Update
func (mmUpdate *mCategoryRepositoryMockUpdate) ExpectUpdatedCategoryParam3(updatedCategory *model.UpdatedCategory) *mCategoryRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CategoryRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &CategoryRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("CategoryRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &CategoryRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.updatedCategory = &updatedCategory
	mmUpdate.defaultExpectation.expectationOrigins.originUpdatedCategory = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the CategoryRepository.Update
func (mmUpdate *mCategoryRepositoryMockUpdate) Inspect(f func(ctx context.Context, id int, updatedCategory *model.UpdatedCategory)) *mCategoryRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for CategoryRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by CategoryRepository.Update
func (mmUpdate *mCategoryRepositoryMockUpdate) Return(err error) *CategoryRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CategoryRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &CategoryRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &CategoryRepositoryMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the CategoryRepository.Update method
func (mmUpdate *mCategoryRepositoryMockUpdate) Set(f func(ctx context.Context, id int, updatedCategory *model.UpdatedCategory) (err error)) *CategoryRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the CategoryRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the CategoryRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the CategoryRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mCategoryRepositoryMockUpdate) When(ctx context.Context, id int, updatedCategory *model.UpdatedCategory) *CategoryRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CategoryRepositoryMock.Update mock is already set by Set")
	}

	expectation := &CategoryRepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &CategoryRepositoryMockUpdateParams{ctx, id, updatedCategory},
		expectationOrigins: CategoryRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up CategoryRepository.Update return parameters for the expectation previously defined by the When method
func (e *CategoryRepositoryMockUpdateExpectation) Then(err error) *CategoryRepositoryMock {
	e.results = &CategoryRepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times CategoryRepository.Update should be invoked
func (mmUpdate *mCategoryRepositoryMockUpdate) Times(n uint64) *mCategoryRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of CategoryRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mCategoryRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_repository.CategoryRepository
func (mmUpdate *CategoryRepositoryMock) Update(ctx context.Context, id int, updatedCategory *model.UpdatedCategory) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, id, updatedCategory)
	}

	mm_params := CategoryRepositoryMockUpdateParams{ctx, id, updatedCategory}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := CategoryRepositoryMockUpdateParams{ctx, id, updatedCategory}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("CategoryRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdate.t.Errorf("CategoryRepositoryMock.Update got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.updatedCategory != nil && !minimock.Equal(*mm_want_ptrs.updatedCategory, mm_got.updatedCategory) {
				mmUpdate.t.Errorf("CategoryRepositoryMock.Update got unexpected parameter updatedCategory, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originUpdatedCategory, *mm_want_ptrs.updatedCategory, mm_got.updatedCategory, minimock.Diff(*mm_want_ptrs.updatedCategory, mm_got.updatedCategory))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("CategoryRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the CategoryRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, id, updatedCategory)
	}
	mmUpdate.t.Fatalf("Unexpected call to CategoryRepositoryMock.Update. %v %v %v", ctx, id, updatedCategory)
	return
}

// UpdateAfterCounter returns a count of finished CategoryRepositoryMock.Update invocations
func (mmUpdate *CategoryRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of CategoryRepositoryMock.Update invocations
func (mmUpdate *CategoryRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to CategoryRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mCategoryRepositoryMockUpdate) Calls() []*CategoryRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*CategoryRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *CategoryRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *CategoryRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CategoryRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CategoryRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CategoryRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to CategoryRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to CategoryRepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CategoryRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CategoryRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CategoryRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockUpdateDone()
}
